/* Options:
Date: 2025-11-06 11:47:32
Version: 8.91
Tip: To override a DTO option, remove "//" prefix before updating
BaseUrl: http://localhost:20000

//GlobalNamespace: 
//AddServiceStackTypes: True
//AddResponseStatus: False
//AddImplicitVersion: 
//AddDescriptionAsComments: True
//IncludeTypes: 
//ExcludeTypes: 
//DefaultImports: package:servicestack/servicestack.dart
*/

import 'package:servicestack/servicestack.dart';

// @DataContract
class Property implements IConvertible
{
    // @DataMember(Order=1)
    String? name;

    // @DataMember(Order=2)
    String? value;

    Property({this.name,this.value});
    Property.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        value = json['value'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'value': value
    };

    getTypeName() => "Property";
    TypeContext? context = _ctx;
}

// @DataContract
abstract class AiContent
{
    /**
    * The type of the content part.
    */
    // @DataMember(Name="type")
    String? type;

    AiContent({this.type});
    AiContent.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        type = json['type'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'type': type
    };

    getTypeName() => "AiContent";
    TypeContext? context = _ctx;
}

/**
* The tool calls generated by the model, such as function calls.
*/
// @DataContract
class ToolCall implements IConvertible
{
    /**
    * The ID of the tool call.
    */
    // @DataMember(Name="id")
    String? id;

    /**
    * The type of the tool. Currently, only `function` is supported.
    */
    // @DataMember(Name="type")
    String? type;

    /**
    * The function that the model called.
    */
    // @DataMember(Name="function")
    String? function;

    ToolCall({this.id,this.type,this.function});
    ToolCall.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        type = json['type'];
        function = json['function'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'type': type,
        'function': function
    };

    getTypeName() => "ToolCall";
    TypeContext? context = _ctx;
}

/**
* A list of messages comprising the conversation so far.
*/
// @DataContract
class AiMessage implements IConvertible
{
    /**
    * The contents of the message.
    */
    // @DataMember(Name="content")
    List<AiContent>? content;

    /**
    * The role of the author of this message. Valid values are `system`, `user`, `assistant` and `tool`.
    */
    // @DataMember(Name="role")
    String? role;

    /**
    * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    */
    // @DataMember(Name="name")
    String? name;

    /**
    * The tool calls generated by the model, such as function calls.
    */
    // @DataMember(Name="tool_calls")
    List<ToolCall>? tool_calls;

    /**
    * Tool call that this message is responding to.
    */
    // @DataMember(Name="tool_call_id")
    String? tool_call_id;

    AiMessage({this.content,this.role,this.name,this.tool_calls,this.tool_call_id});
    AiMessage.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        content = JsonConverters.fromJson(json['content'],'List<AiContent>',context!);
        role = json['role'];
        name = json['name'];
        tool_calls = JsonConverters.fromJson(json['toolCalls'],'List<ToolCall>',context!);
        tool_call_id = json['toolCallId'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'content': JsonConverters.toJson(content,'List<AiContent>',context!),
        'role': role,
        'name': name,
        'tool_calls': JsonConverters.toJson(tool_calls,'List<ToolCall>',context!),
        'tool_call_id': tool_call_id
    };

    getTypeName() => "AiMessage";
    TypeContext? context = _ctx;
}

/**
* Parameters for audio output. Required when audio output is requested with modalities: [audio]
*/
// @DataContract
class AiChatAudio implements IConvertible
{
    /**
    * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
    */
    // @DataMember(Name="format")
    String? format;

    /**
    * The voice the model uses to respond. Supported voices are alloy, ash, ballad, coral, echo, fable, nova, onyx, sage, and shimmer.
    */
    // @DataMember(Name="voice")
    String? voice;

    AiChatAudio({this.format,this.voice});
    AiChatAudio.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        format = json['format'];
        voice = json['voice'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'format': format,
        'voice': voice
    };

    getTypeName() => "AiChatAudio";
    TypeContext? context = _ctx;
}

enum ResponseFormat
{
    Text,
    JsonObject,
}

// @DataContract
class AiResponseFormat implements IConvertible
{
    /**
    * An object specifying the format that the model must output. Compatible with GPT-4 Turbo and all GPT-3.5 Turbo models newer than gpt-3.5-turbo-1106.
    */
    // @DataMember(Name="response_format")
    ResponseFormat? response_format;

    AiResponseFormat({this.response_format});
    AiResponseFormat.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        response_format = JsonConverters.fromJson(json['type'],'ResponseFormat',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'response_format': JsonConverters.toJson(response_format,'ResponseFormat',context!)
    };

    getTypeName() => "AiResponseFormat";
    TypeContext? context = _ctx;
}

enum ToolType
{
    Function,
}

// @DataContract
class Tool implements IConvertible
{
    /**
    * The type of the tool. Currently, only function is supported.
    */
    // @DataMember(Name="type")
    ToolType? type;

    Tool({this.type});
    Tool.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        type = JsonConverters.fromJson(json['type'],'ToolType',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'type': JsonConverters.toJson(type,'ToolType',context!)
    };

    getTypeName() => "Tool";
    TypeContext? context = _ctx;
}

// @DataContract
class ModelUsage implements IConvertible
{
    // @DataMember
    String? cost;

    // @DataMember
    String? input;

    // @DataMember
    String? output;

    // @DataMember
    int? duration;

    // @DataMember(Name="completion_tokens")
    int? completion_tokens;

    // @DataMember
    int? inputCachedTokens;

    // @DataMember
    int? outputCachedTokens;

    // @DataMember(Name="audio_tokens")
    int? audio_tokens;

    // @DataMember(Name="reasoning_tokens")
    int? reasoning_tokens;

    // @DataMember
    int? totalTokens;

    ModelUsage({this.cost,this.input,this.output,this.duration,this.completion_tokens,this.inputCachedTokens,this.outputCachedTokens,this.audio_tokens,this.reasoning_tokens,this.totalTokens});
    ModelUsage.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        cost = json['cost'];
        input = json['input'];
        output = json['output'];
        duration = json['duration'];
        completion_tokens = json['completionTokens'];
        inputCachedTokens = json['inputCachedTokens'];
        outputCachedTokens = json['outputCachedTokens'];
        audio_tokens = json['audioTokens'];
        reasoning_tokens = json['reasoningTokens'];
        totalTokens = json['totalTokens'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'cost': cost,
        'input': input,
        'output': output,
        'duration': duration,
        'completion_tokens': completion_tokens,
        'inputCachedTokens': inputCachedTokens,
        'outputCachedTokens': outputCachedTokens,
        'audio_tokens': audio_tokens,
        'reasoning_tokens': reasoning_tokens,
        'totalTokens': totalTokens
    };

    getTypeName() => "ModelUsage";
    TypeContext? context = _ctx;
}

class ChatCompletionLog implements IConvertible
{
    int? id;
    String? refId;
    String? userId;
    String? apiKey;
    String? model;
    String? provider;
    String? userPrompt;
    String? answer;
    // @StringLength(2147483647)
    String? requestBody;

    // @StringLength(2147483647)
    String? responseBody;

    String? errorCode;
    ResponseStatus? error;
    DateTime? createdDate;
    String? tag;
    int? durationMs;
    int? promptTokens;
    int? completionTokens;
    double? cost;
    String? providerRef;
    String? providerModel;
    String? finishReason;
    ModelUsage? usage;
    String? threadId;
    String? title;
    Map<String,String?>? meta;

    ChatCompletionLog({this.id,this.refId,this.userId,this.apiKey,this.model,this.provider,this.userPrompt,this.answer,this.requestBody,this.responseBody,this.errorCode,this.error,this.createdDate,this.tag,this.durationMs,this.promptTokens,this.completionTokens,this.cost,this.providerRef,this.providerModel,this.finishReason,this.usage,this.threadId,this.title,this.meta});
    ChatCompletionLog.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        refId = json['refId'];
        userId = json['userId'];
        apiKey = json['apiKey'];
        model = json['model'];
        provider = json['provider'];
        userPrompt = json['userPrompt'];
        answer = json['answer'];
        requestBody = json['requestBody'];
        responseBody = json['responseBody'];
        errorCode = json['errorCode'];
        error = JsonConverters.fromJson(json['error'],'ResponseStatus',context!);
        createdDate = JsonConverters.fromJson(json['createdDate'],'DateTime',context!);
        tag = json['tag'];
        durationMs = json['durationMs'];
        promptTokens = json['promptTokens'];
        completionTokens = json['completionTokens'];
        cost = JsonConverters.toDouble(json['cost']);
        providerRef = json['providerRef'];
        providerModel = json['providerModel'];
        finishReason = json['finishReason'];
        usage = JsonConverters.fromJson(json['usage'],'ModelUsage',context!);
        threadId = json['threadId'];
        title = json['title'];
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'refId': refId,
        'userId': userId,
        'apiKey': apiKey,
        'model': model,
        'provider': provider,
        'userPrompt': userPrompt,
        'answer': answer,
        'requestBody': requestBody,
        'responseBody': responseBody,
        'errorCode': errorCode,
        'error': JsonConverters.toJson(error,'ResponseStatus',context!),
        'createdDate': JsonConverters.toJson(createdDate,'DateTime',context!),
        'tag': tag,
        'durationMs': durationMs,
        'promptTokens': promptTokens,
        'completionTokens': completionTokens,
        'cost': cost,
        'providerRef': providerRef,
        'providerModel': providerModel,
        'finishReason': finishReason,
        'usage': JsonConverters.toJson(usage,'ModelUsage',context!),
        'threadId': threadId,
        'title': title,
        'meta': meta
    };

    getTypeName() => "ChatCompletionLog";
    TypeContext? context = _ctx;
}

// @DataContract
abstract class AdminUserBase
{
    // @DataMember(Order=1)
    String? userName;

    // @DataMember(Order=2)
    String? firstName;

    // @DataMember(Order=3)
    String? lastName;

    // @DataMember(Order=4)
    String? displayName;

    // @DataMember(Order=5)
    String? email;

    // @DataMember(Order=6)
    String? password;

    // @DataMember(Order=7)
    String? profileUrl;

    // @DataMember(Order=8)
    String? phoneNumber;

    // @DataMember(Order=9)
    Map<String,String?>? userAuthProperties;

    // @DataMember(Order=10)
    Map<String,String?>? meta;

    AdminUserBase({this.userName,this.firstName,this.lastName,this.displayName,this.email,this.password,this.profileUrl,this.phoneNumber,this.userAuthProperties,this.meta});
    AdminUserBase.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        userName = json['userName'];
        firstName = json['firstName'];
        lastName = json['lastName'];
        displayName = json['displayName'];
        email = json['email'];
        password = json['password'];
        profileUrl = json['profileUrl'];
        phoneNumber = json['phoneNumber'];
        userAuthProperties = JsonConverters.toStringMap(json['userAuthProperties']);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'userName': userName,
        'firstName': firstName,
        'lastName': lastName,
        'displayName': displayName,
        'email': email,
        'password': password,
        'profileUrl': profileUrl,
        'phoneNumber': phoneNumber,
        'userAuthProperties': userAuthProperties,
        'meta': meta
    };

    getTypeName() => "AdminUserBase";
    TypeContext? context = _ctx;
}

class RequestLog implements IConvertible
{
    int? id;
    String? traceId;
    String? operationName;
    DateTime? dateTime;
    int? statusCode;
    String? statusDescription;
    String? httpMethod;
    String? absoluteUri;
    String? pathInfo;
    String? request;
    // @StringLength(2147483647)
    String? requestBody;

    String? userAuthId;
    String? sessionId;
    String? ipAddress;
    String? forwardedFor;
    String? referer;
    Map<String,String?>? headers = {};
    Map<String,String?>? formData;
    Map<String,String?>? items = {};
    Map<String,String?>? responseHeaders;
    String? response;
    // @StringLength(2147483647)
    String? responseBody;

    // @StringLength(2147483647)
    String? sessionBody;

    ResponseStatus? error;
    String? exceptionSource;
    String? exceptionDataBody;
    Duration? requestDuration;
    Map<String,String?>? meta;

    RequestLog({this.id,this.traceId,this.operationName,this.dateTime,this.statusCode,this.statusDescription,this.httpMethod,this.absoluteUri,this.pathInfo,this.request,this.requestBody,this.userAuthId,this.sessionId,this.ipAddress,this.forwardedFor,this.referer,this.headers,this.formData,this.items,this.responseHeaders,this.response,this.responseBody,this.sessionBody,this.error,this.exceptionSource,this.exceptionDataBody,this.requestDuration,this.meta});
    RequestLog.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        traceId = json['traceId'];
        operationName = json['operationName'];
        dateTime = JsonConverters.fromJson(json['dateTime'],'DateTime',context!);
        statusCode = json['statusCode'];
        statusDescription = json['statusDescription'];
        httpMethod = json['httpMethod'];
        absoluteUri = json['absoluteUri'];
        pathInfo = json['pathInfo'];
        request = json['request'];
        requestBody = json['requestBody'];
        userAuthId = json['userAuthId'];
        sessionId = json['sessionId'];
        ipAddress = json['ipAddress'];
        forwardedFor = json['forwardedFor'];
        referer = json['referer'];
        headers = JsonConverters.toStringMap(json['headers']);
        formData = JsonConverters.toStringMap(json['formData']);
        items = JsonConverters.toStringMap(json['items']);
        responseHeaders = JsonConverters.toStringMap(json['responseHeaders']);
        response = json['response'];
        responseBody = json['responseBody'];
        sessionBody = json['sessionBody'];
        error = JsonConverters.fromJson(json['error'],'ResponseStatus',context!);
        exceptionSource = json['exceptionSource'];
        exceptionDataBody = json['exceptionDataBody'];
        requestDuration = JsonConverters.fromJson(json['requestDuration'],'Duration',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'traceId': traceId,
        'operationName': operationName,
        'dateTime': JsonConverters.toJson(dateTime,'DateTime',context!),
        'statusCode': statusCode,
        'statusDescription': statusDescription,
        'httpMethod': httpMethod,
        'absoluteUri': absoluteUri,
        'pathInfo': pathInfo,
        'request': request,
        'requestBody': requestBody,
        'userAuthId': userAuthId,
        'sessionId': sessionId,
        'ipAddress': ipAddress,
        'forwardedFor': forwardedFor,
        'referer': referer,
        'headers': headers,
        'formData': formData,
        'items': items,
        'responseHeaders': responseHeaders,
        'response': response,
        'responseBody': responseBody,
        'sessionBody': sessionBody,
        'error': JsonConverters.toJson(error,'ResponseStatus',context!),
        'exceptionSource': exceptionSource,
        'exceptionDataBody': exceptionDataBody,
        'requestDuration': JsonConverters.toJson(requestDuration,'Duration',context!),
        'meta': meta
    };

    getTypeName() => "RequestLog";
    TypeContext? context = _ctx;
}

class RedisEndpointInfo implements IConvertible
{
    String? host;
    int? port;
    bool? ssl;
    int? db;
    String? username;
    String? password;

    RedisEndpointInfo({this.host,this.port,this.ssl,this.db,this.username,this.password});
    RedisEndpointInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        host = json['host'];
        port = json['port'];
        ssl = json['ssl'];
        db = json['db'];
        username = json['username'];
        password = json['password'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'host': host,
        'port': port,
        'ssl': ssl,
        'db': db,
        'username': username,
        'password': password
    };

    getTypeName() => "RedisEndpointInfo";
    TypeContext? context = _ctx;
}

enum BackgroundJobState
{
    Queued,
    Started,
    Executed,
    Completed,
    Failed,
    Cancelled,
}

abstract class BackgroundJobBase
{
    int? id;
    int? parentId;
    String? refId;
    String? worker;
    String? tag;
    String? batchId;
    String? callback;
    int? dependsOn;
    DateTime? runAfter;
    DateTime? createdDate;
    String? createdBy;
    String? requestId;
    String? requestType;
    String? command;
    String? request;
    // @StringLength(2147483647)
    String? requestBody;

    String? userId;
    String? response;
    // @StringLength(2147483647)
    String? responseBody;

    BackgroundJobState? state;
    DateTime? startedDate;
    DateTime? completedDate;
    DateTime? notifiedDate;
    int? retryLimit;
    int? attempts;
    int? durationMs;
    int? timeoutSecs;
    double? progress;
    String? status;
    // @StringLength(2147483647)
    String? logs;

    DateTime? lastActivityDate;
    String? replyTo;
    String? errorCode;
    ResponseStatus? error;
    Map<String,String?>? args;
    Map<String,String?>? meta;

    BackgroundJobBase({this.id,this.parentId,this.refId,this.worker,this.tag,this.batchId,this.callback,this.dependsOn,this.runAfter,this.createdDate,this.createdBy,this.requestId,this.requestType,this.command,this.request,this.requestBody,this.userId,this.response,this.responseBody,this.state,this.startedDate,this.completedDate,this.notifiedDate,this.retryLimit,this.attempts,this.durationMs,this.timeoutSecs,this.progress,this.status,this.logs,this.lastActivityDate,this.replyTo,this.errorCode,this.error,this.args,this.meta});
    BackgroundJobBase.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        parentId = json['parentId'];
        refId = json['refId'];
        worker = json['worker'];
        tag = json['tag'];
        batchId = json['batchId'];
        callback = json['callback'];
        dependsOn = json['dependsOn'];
        runAfter = JsonConverters.fromJson(json['runAfter'],'DateTime',context!);
        createdDate = JsonConverters.fromJson(json['createdDate'],'DateTime',context!);
        createdBy = json['createdBy'];
        requestId = json['requestId'];
        requestType = json['requestType'];
        command = json['command'];
        request = json['request'];
        requestBody = json['requestBody'];
        userId = json['userId'];
        response = json['response'];
        responseBody = json['responseBody'];
        state = JsonConverters.fromJson(json['state'],'BackgroundJobState',context!);
        startedDate = JsonConverters.fromJson(json['startedDate'],'DateTime',context!);
        completedDate = JsonConverters.fromJson(json['completedDate'],'DateTime',context!);
        notifiedDate = JsonConverters.fromJson(json['notifiedDate'],'DateTime',context!);
        retryLimit = json['retryLimit'];
        attempts = json['attempts'];
        durationMs = json['durationMs'];
        timeoutSecs = json['timeoutSecs'];
        progress = JsonConverters.toDouble(json['progress']);
        status = json['status'];
        logs = json['logs'];
        lastActivityDate = JsonConverters.fromJson(json['lastActivityDate'],'DateTime',context!);
        replyTo = json['replyTo'];
        errorCode = json['errorCode'];
        error = JsonConverters.fromJson(json['error'],'ResponseStatus',context!);
        args = JsonConverters.toStringMap(json['args']);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'parentId': parentId,
        'refId': refId,
        'worker': worker,
        'tag': tag,
        'batchId': batchId,
        'callback': callback,
        'dependsOn': dependsOn,
        'runAfter': JsonConverters.toJson(runAfter,'DateTime',context!),
        'createdDate': JsonConverters.toJson(createdDate,'DateTime',context!),
        'createdBy': createdBy,
        'requestId': requestId,
        'requestType': requestType,
        'command': command,
        'request': request,
        'requestBody': requestBody,
        'userId': userId,
        'response': response,
        'responseBody': responseBody,
        'state': JsonConverters.toJson(state,'BackgroundJobState',context!),
        'startedDate': JsonConverters.toJson(startedDate,'DateTime',context!),
        'completedDate': JsonConverters.toJson(completedDate,'DateTime',context!),
        'notifiedDate': JsonConverters.toJson(notifiedDate,'DateTime',context!),
        'retryLimit': retryLimit,
        'attempts': attempts,
        'durationMs': durationMs,
        'timeoutSecs': timeoutSecs,
        'progress': progress,
        'status': status,
        'logs': logs,
        'lastActivityDate': JsonConverters.toJson(lastActivityDate,'DateTime',context!),
        'replyTo': replyTo,
        'errorCode': errorCode,
        'error': JsonConverters.toJson(error,'ResponseStatus',context!),
        'args': args,
        'meta': meta
    };

    getTypeName() => "BackgroundJobBase";
    TypeContext? context = _ctx;
}

class BackgroundJob extends BackgroundJobBase implements IConvertible
{
    int? id;

    BackgroundJob({this.id});
    BackgroundJob.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        id = json['id'];
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'id': id
    });

    getTypeName() => "BackgroundJob";
    TypeContext? context = _ctx;
}

class JobSummary implements IConvertible
{
    int? id;
    int? parentId;
    String? refId;
    String? worker;
    String? tag;
    String? batchId;
    DateTime? createdDate;
    String? createdBy;
    String? requestType;
    String? command;
    String? request;
    String? response;
    String? userId;
    String? callback;
    DateTime? startedDate;
    DateTime? completedDate;
    BackgroundJobState? state;
    int? durationMs;
    int? attempts;
    String? errorCode;
    String? errorMessage;

    JobSummary({this.id,this.parentId,this.refId,this.worker,this.tag,this.batchId,this.createdDate,this.createdBy,this.requestType,this.command,this.request,this.response,this.userId,this.callback,this.startedDate,this.completedDate,this.state,this.durationMs,this.attempts,this.errorCode,this.errorMessage});
    JobSummary.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        parentId = json['parentId'];
        refId = json['refId'];
        worker = json['worker'];
        tag = json['tag'];
        batchId = json['batchId'];
        createdDate = JsonConverters.fromJson(json['createdDate'],'DateTime',context!);
        createdBy = json['createdBy'];
        requestType = json['requestType'];
        command = json['command'];
        request = json['request'];
        response = json['response'];
        userId = json['userId'];
        callback = json['callback'];
        startedDate = JsonConverters.fromJson(json['startedDate'],'DateTime',context!);
        completedDate = JsonConverters.fromJson(json['completedDate'],'DateTime',context!);
        state = JsonConverters.fromJson(json['state'],'BackgroundJobState',context!);
        durationMs = json['durationMs'];
        attempts = json['attempts'];
        errorCode = json['errorCode'];
        errorMessage = json['errorMessage'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'parentId': parentId,
        'refId': refId,
        'worker': worker,
        'tag': tag,
        'batchId': batchId,
        'createdDate': JsonConverters.toJson(createdDate,'DateTime',context!),
        'createdBy': createdBy,
        'requestType': requestType,
        'command': command,
        'request': request,
        'response': response,
        'userId': userId,
        'callback': callback,
        'startedDate': JsonConverters.toJson(startedDate,'DateTime',context!),
        'completedDate': JsonConverters.toJson(completedDate,'DateTime',context!),
        'state': JsonConverters.toJson(state,'BackgroundJobState',context!),
        'durationMs': durationMs,
        'attempts': attempts,
        'errorCode': errorCode,
        'errorMessage': errorMessage
    };

    getTypeName() => "JobSummary";
    TypeContext? context = _ctx;
}

class BackgroundJobOptions implements IConvertible
{
    String? refId;
    int? parentId;
    String? worker;
    DateTime? runAfter;
    String? callback;
    int? dependsOn;
    String? userId;
    int? retryLimit;
    String? replyTo;
    String? tag;
    String? batchId;
    String? createdBy;
    int? timeoutSecs;
    Duration? timeout;
    Map<String,String?>? args;
    bool? runCommand;

    BackgroundJobOptions({this.refId,this.parentId,this.worker,this.runAfter,this.callback,this.dependsOn,this.userId,this.retryLimit,this.replyTo,this.tag,this.batchId,this.createdBy,this.timeoutSecs,this.timeout,this.args,this.runCommand});
    BackgroundJobOptions.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        refId = json['refId'];
        parentId = json['parentId'];
        worker = json['worker'];
        runAfter = JsonConverters.fromJson(json['runAfter'],'DateTime',context!);
        callback = json['callback'];
        dependsOn = json['dependsOn'];
        userId = json['userId'];
        retryLimit = json['retryLimit'];
        replyTo = json['replyTo'];
        tag = json['tag'];
        batchId = json['batchId'];
        createdBy = json['createdBy'];
        timeoutSecs = json['timeoutSecs'];
        timeout = JsonConverters.fromJson(json['timeout'],'Duration',context!);
        args = JsonConverters.toStringMap(json['args']);
        runCommand = json['runCommand'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'refId': refId,
        'parentId': parentId,
        'worker': worker,
        'runAfter': JsonConverters.toJson(runAfter,'DateTime',context!),
        'callback': callback,
        'dependsOn': dependsOn,
        'userId': userId,
        'retryLimit': retryLimit,
        'replyTo': replyTo,
        'tag': tag,
        'batchId': batchId,
        'createdBy': createdBy,
        'timeoutSecs': timeoutSecs,
        'timeout': JsonConverters.toJson(timeout,'Duration',context!),
        'args': args,
        'runCommand': runCommand
    };

    getTypeName() => "BackgroundJobOptions";
    TypeContext? context = _ctx;
}

class ScheduledTask implements IConvertible
{
    int? id;
    String? name;
    Duration? interval;
    String? cronExpression;
    String? requestType;
    String? command;
    String? request;
    String? requestBody;
    BackgroundJobOptions? options;
    DateTime? lastRun;
    int? lastJobId;

    ScheduledTask({this.id,this.name,this.interval,this.cronExpression,this.requestType,this.command,this.request,this.requestBody,this.options,this.lastRun,this.lastJobId});
    ScheduledTask.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        name = json['name'];
        interval = JsonConverters.fromJson(json['interval'],'Duration',context!);
        cronExpression = json['cronExpression'];
        requestType = json['requestType'];
        command = json['command'];
        request = json['request'];
        requestBody = json['requestBody'];
        options = JsonConverters.fromJson(json['options'],'BackgroundJobOptions',context!);
        lastRun = JsonConverters.fromJson(json['lastRun'],'DateTime',context!);
        lastJobId = json['lastJobId'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'interval': JsonConverters.toJson(interval,'Duration',context!),
        'cronExpression': cronExpression,
        'requestType': requestType,
        'command': command,
        'request': request,
        'requestBody': requestBody,
        'options': JsonConverters.toJson(options,'BackgroundJobOptions',context!),
        'lastRun': JsonConverters.toJson(lastRun,'DateTime',context!),
        'lastJobId': lastJobId
    };

    getTypeName() => "ScheduledTask";
    TypeContext? context = _ctx;
}

class CompletedJob extends BackgroundJobBase implements IConvertible
{
    CompletedJob();
    CompletedJob.fromJson(Map<String, dynamic> json) : super.fromJson(json);
    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson();
    getTypeName() => "CompletedJob";
    TypeContext? context = _ctx;
}

class FailedJob extends BackgroundJobBase implements IConvertible
{
    FailedJob();
    FailedJob.fromJson(Map<String, dynamic> json) : super.fromJson(json);
    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson();
    getTypeName() => "FailedJob";
    TypeContext? context = _ctx;
}

class ValidateRule implements IConvertible
{
    String? validator;
    String? condition;
    String? errorCode;
    String? message;

    ValidateRule({this.validator,this.condition,this.errorCode,this.message});
    ValidateRule.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        validator = json['validator'];
        condition = json['condition'];
        errorCode = json['errorCode'];
        message = json['message'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'validator': validator,
        'condition': condition,
        'errorCode': errorCode,
        'message': message
    };

    getTypeName() => "ValidateRule";
    TypeContext? context = _ctx;
}

class ValidationRule extends ValidateRule implements IConvertible
{
    int? id;
    // @required()
    String? type;

    String? field;
    String? createdBy;
    DateTime? createdDate;
    String? modifiedBy;
    DateTime? modifiedDate;
    String? suspendedBy;
    DateTime? suspendedDate;
    String? notes;

    ValidationRule({this.id,this.type,this.field,this.createdBy,this.createdDate,this.modifiedBy,this.modifiedDate,this.suspendedBy,this.suspendedDate,this.notes});
    ValidationRule.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        id = json['id'];
        type = json['type'];
        field = json['field'];
        createdBy = json['createdBy'];
        createdDate = JsonConverters.fromJson(json['createdDate'],'DateTime',context!);
        modifiedBy = json['modifiedBy'];
        modifiedDate = JsonConverters.fromJson(json['modifiedDate'],'DateTime',context!);
        suspendedBy = json['suspendedBy'];
        suspendedDate = JsonConverters.fromJson(json['suspendedDate'],'DateTime',context!);
        notes = json['notes'];
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'id': id,
        'type': type,
        'field': field,
        'createdBy': createdBy,
        'createdDate': JsonConverters.toJson(createdDate,'DateTime',context!),
        'modifiedBy': modifiedBy,
        'modifiedDate': JsonConverters.toJson(modifiedDate,'DateTime',context!),
        'suspendedBy': suspendedBy,
        'suspendedDate': JsonConverters.toJson(suspendedDate,'DateTime',context!),
        'notes': notes
    });

    getTypeName() => "ValidationRule";
    TypeContext? context = _ctx;
}

class AppInfo implements IConvertible
{
    String? baseUrl;
    String? serviceStackVersion;
    String? serviceName;
    String? apiVersion;
    String? serviceDescription;
    String? serviceIconUrl;
    String? brandUrl;
    String? brandImageUrl;
    String? textColor;
    String? linkColor;
    String? backgroundColor;
    String? backgroundImageUrl;
    String? iconUrl;
    String? jsTextCase;
    String? useSystemJson;
    List<String>? endpointRouting;
    Map<String,String?>? meta;

    AppInfo({this.baseUrl,this.serviceStackVersion,this.serviceName,this.apiVersion,this.serviceDescription,this.serviceIconUrl,this.brandUrl,this.brandImageUrl,this.textColor,this.linkColor,this.backgroundColor,this.backgroundImageUrl,this.iconUrl,this.jsTextCase,this.useSystemJson,this.endpointRouting,this.meta});
    AppInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        baseUrl = json['baseUrl'];
        serviceStackVersion = json['serviceStackVersion'];
        serviceName = json['serviceName'];
        apiVersion = json['apiVersion'];
        serviceDescription = json['serviceDescription'];
        serviceIconUrl = json['serviceIconUrl'];
        brandUrl = json['brandUrl'];
        brandImageUrl = json['brandImageUrl'];
        textColor = json['textColor'];
        linkColor = json['linkColor'];
        backgroundColor = json['backgroundColor'];
        backgroundImageUrl = json['backgroundImageUrl'];
        iconUrl = json['iconUrl'];
        jsTextCase = json['jsTextCase'];
        useSystemJson = json['useSystemJson'];
        endpointRouting = JsonConverters.fromJson(json['endpointRouting'],'List<String>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'baseUrl': baseUrl,
        'serviceStackVersion': serviceStackVersion,
        'serviceName': serviceName,
        'apiVersion': apiVersion,
        'serviceDescription': serviceDescription,
        'serviceIconUrl': serviceIconUrl,
        'brandUrl': brandUrl,
        'brandImageUrl': brandImageUrl,
        'textColor': textColor,
        'linkColor': linkColor,
        'backgroundColor': backgroundColor,
        'backgroundImageUrl': backgroundImageUrl,
        'iconUrl': iconUrl,
        'jsTextCase': jsTextCase,
        'useSystemJson': useSystemJson,
        'endpointRouting': JsonConverters.toJson(endpointRouting,'List<String>',context!),
        'meta': meta
    };

    getTypeName() => "AppInfo";
    TypeContext? context = _ctx;
}

class ImageInfo implements IConvertible
{
    String? svg;
    String? uri;
    String? alt;
    String? cls;

    ImageInfo({this.svg,this.uri,this.alt,this.cls});
    ImageInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        svg = json['svg'];
        uri = json['uri'];
        alt = json['alt'];
        cls = json['cls'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'svg': svg,
        'uri': uri,
        'alt': alt,
        'cls': cls
    };

    getTypeName() => "ImageInfo";
    TypeContext? context = _ctx;
}

class LinkInfo implements IConvertible
{
    String? id;
    String? href;
    String? label;
    ImageInfo? icon;
    String? Show;
    String? Hide;

    LinkInfo({this.id,this.href,this.label,this.icon,this.Show,this.Hide});
    LinkInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        href = json['href'];
        label = json['label'];
        icon = JsonConverters.fromJson(json['icon'],'ImageInfo',context!);
        Show = json['show'];
        Hide = json['hide'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'href': href,
        'label': label,
        'icon': JsonConverters.toJson(icon,'ImageInfo',context!),
        'show': Show,
        'hide': Hide
    };

    getTypeName() => "LinkInfo";
    TypeContext? context = _ctx;
}

class ThemeInfo implements IConvertible
{
    String? form;
    ImageInfo? modelIcon;

    ThemeInfo({this.form,this.modelIcon});
    ThemeInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        form = json['form'];
        modelIcon = JsonConverters.fromJson(json['modelIcon'],'ImageInfo',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'form': form,
        'modelIcon': JsonConverters.toJson(modelIcon,'ImageInfo',context!)
    };

    getTypeName() => "ThemeInfo";
    TypeContext? context = _ctx;
}

class ApiCss implements IConvertible
{
    String? form;
    String? fieldset;
    String? field;

    ApiCss({this.form,this.fieldset,this.field});
    ApiCss.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        form = json['form'];
        fieldset = json['fieldset'];
        field = json['field'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'form': form,
        'fieldset': fieldset,
        'field': field
    };

    getTypeName() => "ApiCss";
    TypeContext? context = _ctx;
}

class AppTags implements IConvertible
{
    String? Default;
    String? other;

    AppTags({this.Default,this.other});
    AppTags.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        Default = json['default'];
        other = json['other'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'default': Default,
        'other': other
    };

    getTypeName() => "AppTags";
    TypeContext? context = _ctx;
}

class LocodeUi implements IConvertible
{
    ApiCss? css;
    AppTags? tags;
    int? maxFieldLength;
    int? maxNestedFields;
    int? maxNestedFieldLength;

    LocodeUi({this.css,this.tags,this.maxFieldLength,this.maxNestedFields,this.maxNestedFieldLength});
    LocodeUi.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        css = JsonConverters.fromJson(json['css'],'ApiCss',context!);
        tags = JsonConverters.fromJson(json['tags'],'AppTags',context!);
        maxFieldLength = json['maxFieldLength'];
        maxNestedFields = json['maxNestedFields'];
        maxNestedFieldLength = json['maxNestedFieldLength'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'css': JsonConverters.toJson(css,'ApiCss',context!),
        'tags': JsonConverters.toJson(tags,'AppTags',context!),
        'maxFieldLength': maxFieldLength,
        'maxNestedFields': maxNestedFields,
        'maxNestedFieldLength': maxNestedFieldLength
    };

    getTypeName() => "LocodeUi";
    TypeContext? context = _ctx;
}

class ExplorerUi implements IConvertible
{
    ApiCss? css;
    AppTags? tags;
    String? jsConfig;

    ExplorerUi({this.css,this.tags,this.jsConfig});
    ExplorerUi.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        css = JsonConverters.fromJson(json['css'],'ApiCss',context!);
        tags = JsonConverters.fromJson(json['tags'],'AppTags',context!);
        jsConfig = json['jsConfig'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'css': JsonConverters.toJson(css,'ApiCss',context!),
        'tags': JsonConverters.toJson(tags,'AppTags',context!),
        'jsConfig': jsConfig
    };

    getTypeName() => "ExplorerUi";
    TypeContext? context = _ctx;
}

class PageInfo implements IConvertible
{
    String? page;
    String? component;

    PageInfo({this.page,this.component});
    PageInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        page = json['page'];
        component = json['component'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'page': page,
        'component': component
    };

    getTypeName() => "PageInfo";
    TypeContext? context = _ctx;
}

class AdminUi implements IConvertible
{
    ApiCss? css;
    List<PageInfo>? pages;

    AdminUi({this.css,this.pages});
    AdminUi.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        css = JsonConverters.fromJson(json['css'],'ApiCss',context!);
        pages = JsonConverters.fromJson(json['pages'],'List<PageInfo>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'css': JsonConverters.toJson(css,'ApiCss',context!),
        'pages': JsonConverters.toJson(pages,'List<PageInfo>',context!)
    };

    getTypeName() => "AdminUi";
    TypeContext? context = _ctx;
}

class FormatInfo implements IConvertible
{
    String? method;
    String? options;
    String? locale;

    FormatInfo({this.method,this.options,this.locale});
    FormatInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        method = json['method'];
        options = json['options'];
        locale = json['locale'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'method': method,
        'options': options,
        'locale': locale
    };

    getTypeName() => "FormatInfo";
    TypeContext? context = _ctx;
}

class ApiFormat implements IConvertible
{
    String? locale;
    bool? assumeUtc;
    FormatInfo? number;
    FormatInfo? date;

    ApiFormat({this.locale,this.assumeUtc,this.number,this.date});
    ApiFormat.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        locale = json['locale'];
        assumeUtc = json['assumeUtc'];
        number = JsonConverters.fromJson(json['number'],'FormatInfo',context!);
        date = JsonConverters.fromJson(json['date'],'FormatInfo',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'locale': locale,
        'assumeUtc': assumeUtc,
        'number': JsonConverters.toJson(number,'FormatInfo',context!),
        'date': JsonConverters.toJson(date,'FormatInfo',context!)
    };

    getTypeName() => "ApiFormat";
    TypeContext? context = _ctx;
}

class UiInfo implements IConvertible
{
    ImageInfo? brandIcon;
    ImageInfo? userIcon;
    List<String>? hideTags;
    List<String>? modules;
    List<String>? alwaysHideTags;
    List<LinkInfo>? adminLinks;
    List<String>? adminLinksOrder;
    ThemeInfo? theme;
    LocodeUi? locode;
    ExplorerUi? explorer;
    AdminUi? admin;
    ApiFormat? defaultFormats;
    Map<String,String?>? meta;

    UiInfo({this.brandIcon,this.userIcon,this.hideTags,this.modules,this.alwaysHideTags,this.adminLinks,this.adminLinksOrder,this.theme,this.locode,this.explorer,this.admin,this.defaultFormats,this.meta});
    UiInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        brandIcon = JsonConverters.fromJson(json['brandIcon'],'ImageInfo',context!);
        userIcon = JsonConverters.fromJson(json['userIcon'],'ImageInfo',context!);
        hideTags = JsonConverters.fromJson(json['hideTags'],'List<String>',context!);
        modules = JsonConverters.fromJson(json['modules'],'List<String>',context!);
        alwaysHideTags = JsonConverters.fromJson(json['alwaysHideTags'],'List<String>',context!);
        adminLinks = JsonConverters.fromJson(json['adminLinks'],'List<LinkInfo>',context!);
        adminLinksOrder = JsonConverters.fromJson(json['adminLinksOrder'],'List<String>',context!);
        theme = JsonConverters.fromJson(json['theme'],'ThemeInfo',context!);
        locode = JsonConverters.fromJson(json['locode'],'LocodeUi',context!);
        explorer = JsonConverters.fromJson(json['explorer'],'ExplorerUi',context!);
        admin = JsonConverters.fromJson(json['admin'],'AdminUi',context!);
        defaultFormats = JsonConverters.fromJson(json['defaultFormats'],'ApiFormat',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'brandIcon': JsonConverters.toJson(brandIcon,'ImageInfo',context!),
        'userIcon': JsonConverters.toJson(userIcon,'ImageInfo',context!),
        'hideTags': JsonConverters.toJson(hideTags,'List<String>',context!),
        'modules': JsonConverters.toJson(modules,'List<String>',context!),
        'alwaysHideTags': JsonConverters.toJson(alwaysHideTags,'List<String>',context!),
        'adminLinks': JsonConverters.toJson(adminLinks,'List<LinkInfo>',context!),
        'adminLinksOrder': JsonConverters.toJson(adminLinksOrder,'List<String>',context!),
        'theme': JsonConverters.toJson(theme,'ThemeInfo',context!),
        'locode': JsonConverters.toJson(locode,'LocodeUi',context!),
        'explorer': JsonConverters.toJson(explorer,'ExplorerUi',context!),
        'admin': JsonConverters.toJson(admin,'AdminUi',context!),
        'defaultFormats': JsonConverters.toJson(defaultFormats,'ApiFormat',context!),
        'meta': meta
    };

    getTypeName() => "UiInfo";
    TypeContext? context = _ctx;
}

class ConfigInfo implements IConvertible
{
    bool? debugMode;
    Map<String,String?>? meta;

    ConfigInfo({this.debugMode,this.meta});
    ConfigInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        debugMode = json['debugMode'];
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'debugMode': debugMode,
        'meta': meta
    };

    getTypeName() => "ConfigInfo";
    TypeContext? context = _ctx;
}

class FieldCss implements IConvertible
{
    String? field;
    String? input;
    String? label;

    FieldCss({this.field,this.input,this.label});
    FieldCss.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        field = json['field'];
        input = json['input'];
        label = json['label'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'field': field,
        'input': input,
        'label': label
    };

    getTypeName() => "FieldCss";
    TypeContext? context = _ctx;
}

class InputInfo implements IConvertible
{
    String? id;
    String? name;
    String? type;
    String? value;
    String? placeholder;
    String? help;
    String? label;
    String? title;
    String? size;
    String? pattern;
    bool? readOnly;
    bool? Required;
    bool? disabled;
    String? autocomplete;
    String? autofocus;
    String? min;
    String? max;
    String? step;
    int? minLength;
    int? maxLength;
    String? accept;
    String? capture;
    bool? multiple;
    List<String>? allowableValues;
    List<KeyValuePair><String,String>? allowableEntries;
    String? options;
    bool? ignore;
    FieldCss? css;
    Map<String,String?>? meta;

    InputInfo({this.id,this.name,this.type,this.value,this.placeholder,this.help,this.label,this.title,this.size,this.pattern,this.readOnly,this.Required,this.disabled,this.autocomplete,this.autofocus,this.min,this.max,this.step,this.minLength,this.maxLength,this.accept,this.capture,this.multiple,this.allowableValues,this.allowableEntries,this.options,this.ignore,this.css,this.meta});
    InputInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        name = json['name'];
        type = json['type'];
        value = json['value'];
        placeholder = json['placeholder'];
        help = json['help'];
        label = json['label'];
        title = json['title'];
        size = json['size'];
        pattern = json['pattern'];
        readOnly = json['readOnly'];
        Required = json['required'];
        disabled = json['disabled'];
        autocomplete = json['autocomplete'];
        autofocus = json['autofocus'];
        min = json['min'];
        max = json['max'];
        step = json['step'];
        minLength = json['minLength'];
        maxLength = json['maxLength'];
        accept = json['accept'];
        capture = json['capture'];
        multiple = json['multiple'];
        allowableValues = JsonConverters.fromJson(json['allowableValues'],'List<String>',context!);
        allowableEntries = JsonConverters.fromJson(json['allowableEntries'],'List<KeyValuePair><String,String>',context!);
        options = json['options'];
        ignore = json['ignore'];
        css = JsonConverters.fromJson(json['css'],'FieldCss',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'type': type,
        'value': value,
        'placeholder': placeholder,
        'help': help,
        'label': label,
        'title': title,
        'size': size,
        'pattern': pattern,
        'readOnly': readOnly,
        'required': Required,
        'disabled': disabled,
        'autocomplete': autocomplete,
        'autofocus': autofocus,
        'min': min,
        'max': max,
        'step': step,
        'minLength': minLength,
        'maxLength': maxLength,
        'accept': accept,
        'capture': capture,
        'multiple': multiple,
        'allowableValues': JsonConverters.toJson(allowableValues,'List<String>',context!),
        'allowableEntries': JsonConverters.toJson(allowableEntries,'List<KeyValuePair><String,String>',context!),
        'options': options,
        'ignore': ignore,
        'css': JsonConverters.toJson(css,'FieldCss',context!),
        'meta': meta
    };

    getTypeName() => "InputInfo";
    TypeContext? context = _ctx;
}

class MetaAuthProvider implements IConvertible
{
    String? name;
    String? label;
    String? type;
    NavItem? navItem;
    ImageInfo? icon;
    List<InputInfo>? formLayout;
    Map<String,String?>? meta;

    MetaAuthProvider({this.name,this.label,this.type,this.navItem,this.icon,this.formLayout,this.meta});
    MetaAuthProvider.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        label = json['label'];
        type = json['type'];
        navItem = JsonConverters.fromJson(json['navItem'],'NavItem',context!);
        icon = JsonConverters.fromJson(json['icon'],'ImageInfo',context!);
        formLayout = JsonConverters.fromJson(json['formLayout'],'List<InputInfo>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'label': label,
        'type': type,
        'navItem': JsonConverters.toJson(navItem,'NavItem',context!),
        'icon': JsonConverters.toJson(icon,'ImageInfo',context!),
        'formLayout': JsonConverters.toJson(formLayout,'List<InputInfo>',context!),
        'meta': meta
    };

    getTypeName() => "MetaAuthProvider";
    TypeContext? context = _ctx;
}

class IdentityAuthInfo implements IConvertible
{
    bool? hasRefreshToken;
    Map<String,String?>? meta;

    IdentityAuthInfo({this.hasRefreshToken,this.meta});
    IdentityAuthInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        hasRefreshToken = json['hasRefreshToken'];
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'hasRefreshToken': hasRefreshToken,
        'meta': meta
    };

    getTypeName() => "IdentityAuthInfo";
    TypeContext? context = _ctx;
}

class AuthInfo implements IConvertible
{
    bool? hasAuthSecret;
    bool? hasAuthRepository;
    bool? includesRoles;
    bool? includesOAuthTokens;
    String? htmlRedirect;
    List<MetaAuthProvider>? authProviders;
    IdentityAuthInfo? identityAuth;
    Map<String,List<LinkInfo>?>? roleLinks;
    Map<String,List<String>?>? serviceRoutes;
    Map<String,String?>? meta;

    AuthInfo({this.hasAuthSecret,this.hasAuthRepository,this.includesRoles,this.includesOAuthTokens,this.htmlRedirect,this.authProviders,this.identityAuth,this.roleLinks,this.serviceRoutes,this.meta});
    AuthInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        hasAuthSecret = json['hasAuthSecret'];
        hasAuthRepository = json['hasAuthRepository'];
        includesRoles = json['includesRoles'];
        includesOAuthTokens = json['includesOAuthTokens'];
        htmlRedirect = json['htmlRedirect'];
        authProviders = JsonConverters.fromJson(json['authProviders'],'List<MetaAuthProvider>',context!);
        identityAuth = JsonConverters.fromJson(json['identityAuth'],'IdentityAuthInfo',context!);
        roleLinks = JsonConverters.fromJson(json['roleLinks'],'Map<String,List<LinkInfo>?>',context!);
        serviceRoutes = JsonConverters.fromJson(json['serviceRoutes'],'Map<String,List<String>?>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'hasAuthSecret': hasAuthSecret,
        'hasAuthRepository': hasAuthRepository,
        'includesRoles': includesRoles,
        'includesOAuthTokens': includesOAuthTokens,
        'htmlRedirect': htmlRedirect,
        'authProviders': JsonConverters.toJson(authProviders,'List<MetaAuthProvider>',context!),
        'identityAuth': JsonConverters.toJson(identityAuth,'IdentityAuthInfo',context!),
        'roleLinks': JsonConverters.toJson(roleLinks,'Map<String,List<LinkInfo>?>',context!),
        'serviceRoutes': JsonConverters.toJson(serviceRoutes,'Map<String,List<String>?>',context!),
        'meta': meta
    };

    getTypeName() => "AuthInfo";
    TypeContext? context = _ctx;
}

class ApiKeyInfo implements IConvertible
{
    String? label;
    String? httpHeader;
    List<String>? scopes;
    List<String>? features;
    List<String>? requestTypes;
    List<KeyValuePair<String,String>>? expiresIn;
    List<String>? Hide;
    Map<String,String?>? meta;

    ApiKeyInfo({this.label,this.httpHeader,this.scopes,this.features,this.requestTypes,this.expiresIn,this.Hide,this.meta});
    ApiKeyInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        label = json['label'];
        httpHeader = json['httpHeader'];
        scopes = JsonConverters.fromJson(json['scopes'],'List<String>',context!);
        features = JsonConverters.fromJson(json['features'],'List<String>',context!);
        requestTypes = JsonConverters.fromJson(json['requestTypes'],'List<String>',context!);
        expiresIn = JsonConverters.fromJson(json['expiresIn'],'List<KeyValuePair<String,String>>',context!);
        Hide = JsonConverters.fromJson(json['hide'],'List<String>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'label': label,
        'httpHeader': httpHeader,
        'scopes': JsonConverters.toJson(scopes,'List<String>',context!),
        'features': JsonConverters.toJson(features,'List<String>',context!),
        'requestTypes': JsonConverters.toJson(requestTypes,'List<String>',context!),
        'expiresIn': JsonConverters.toJson(expiresIn,'List<KeyValuePair<String,String>>',context!),
        'hide': JsonConverters.toJson(Hide,'List<String>',context!),
        'meta': meta
    };

    getTypeName() => "ApiKeyInfo";
    TypeContext? context = _ctx;
}

class MetadataTypeName implements IConvertible
{
    String? name;
    String? namespace;
    List<String>? genericArgs;

    MetadataTypeName({this.name,this.namespace,this.genericArgs});
    MetadataTypeName.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        namespace = json['namespace'];
        genericArgs = JsonConverters.fromJson(json['genericArgs'],'List<String>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'namespace': namespace,
        'genericArgs': JsonConverters.toJson(genericArgs,'List<String>',context!)
    };

    getTypeName() => "MetadataTypeName";
    TypeContext? context = _ctx;
}

class MetadataDataContract implements IConvertible
{
    String? name;
    String? namespace;

    MetadataDataContract({this.name,this.namespace});
    MetadataDataContract.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        namespace = json['namespace'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'namespace': namespace
    };

    getTypeName() => "MetadataDataContract";
    TypeContext? context = _ctx;
}

class MetadataDataMember implements IConvertible
{
    String? name;
    int? order;
    bool? isRequired;
    bool? emitDefaultValue;

    MetadataDataMember({this.name,this.order,this.isRequired,this.emitDefaultValue});
    MetadataDataMember.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        order = json['order'];
        isRequired = json['isRequired'];
        emitDefaultValue = json['emitDefaultValue'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'order': order,
        'isRequired': isRequired,
        'emitDefaultValue': emitDefaultValue
    };

    getTypeName() => "MetadataDataMember";
    TypeContext? context = _ctx;
}

class MetadataAttribute implements IConvertible
{
    String? name;
    List<MetadataPropertyType>? constructorArgs;
    List<MetadataPropertyType>? args;

    MetadataAttribute({this.name,this.constructorArgs,this.args});
    MetadataAttribute.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        constructorArgs = JsonConverters.fromJson(json['constructorArgs'],'List<MetadataPropertyType>',context!);
        args = JsonConverters.fromJson(json['args'],'List<MetadataPropertyType>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'constructorArgs': JsonConverters.toJson(constructorArgs,'List<MetadataPropertyType>',context!),
        'args': JsonConverters.toJson(args,'List<MetadataPropertyType>',context!)
    };

    getTypeName() => "MetadataAttribute";
    TypeContext? context = _ctx;
}

class RefInfo implements IConvertible
{
    String? model;
    String? selfId;
    String? refId;
    String? refLabel;
    String? queryApi;

    RefInfo({this.model,this.selfId,this.refId,this.refLabel,this.queryApi});
    RefInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        model = json['model'];
        selfId = json['selfId'];
        refId = json['refId'];
        refLabel = json['refLabel'];
        queryApi = json['queryApi'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'model': model,
        'selfId': selfId,
        'refId': refId,
        'refLabel': refLabel,
        'queryApi': queryApi
    };

    getTypeName() => "RefInfo";
    TypeContext? context = _ctx;
}

class MetadataPropertyType implements IConvertible
{
    String? name;
    String? type;
    String? namespace;
    bool? isValueType;
    bool? isEnum;
    bool? isPrimaryKey;
    List<String>? genericArgs;
    String? value;
    String? description;
    MetadataDataMember? dataMember;
    bool? readOnly;
    String? paramType;
    String? displayType;
    bool? isRequired;
    List<String>? allowableValues;
    int? allowableMin;
    int? allowableMax;
    List<MetadataAttribute>? attributes;
    String? uploadTo;
    InputInfo? input;
    FormatInfo? format;
    RefInfo? ref;

    MetadataPropertyType({this.name,this.type,this.namespace,this.isValueType,this.isEnum,this.isPrimaryKey,this.genericArgs,this.value,this.description,this.dataMember,this.readOnly,this.paramType,this.displayType,this.isRequired,this.allowableValues,this.allowableMin,this.allowableMax,this.attributes,this.uploadTo,this.input,this.format,this.ref});
    MetadataPropertyType.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        type = json['type'];
        namespace = json['namespace'];
        isValueType = json['isValueType'];
        isEnum = json['isEnum'];
        isPrimaryKey = json['isPrimaryKey'];
        genericArgs = JsonConverters.fromJson(json['genericArgs'],'List<String>',context!);
        value = json['value'];
        description = json['description'];
        dataMember = JsonConverters.fromJson(json['dataMember'],'MetadataDataMember',context!);
        readOnly = json['readOnly'];
        paramType = json['paramType'];
        displayType = json['displayType'];
        isRequired = json['isRequired'];
        allowableValues = JsonConverters.fromJson(json['allowableValues'],'List<String>',context!);
        allowableMin = json['allowableMin'];
        allowableMax = json['allowableMax'];
        attributes = JsonConverters.fromJson(json['attributes'],'List<MetadataAttribute>',context!);
        uploadTo = json['uploadTo'];
        input = JsonConverters.fromJson(json['input'],'InputInfo',context!);
        format = JsonConverters.fromJson(json['format'],'FormatInfo',context!);
        ref = JsonConverters.fromJson(json['ref'],'RefInfo',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'type': type,
        'namespace': namespace,
        'isValueType': isValueType,
        'isEnum': isEnum,
        'isPrimaryKey': isPrimaryKey,
        'genericArgs': JsonConverters.toJson(genericArgs,'List<String>',context!),
        'value': value,
        'description': description,
        'dataMember': JsonConverters.toJson(dataMember,'MetadataDataMember',context!),
        'readOnly': readOnly,
        'paramType': paramType,
        'displayType': displayType,
        'isRequired': isRequired,
        'allowableValues': JsonConverters.toJson(allowableValues,'List<String>',context!),
        'allowableMin': allowableMin,
        'allowableMax': allowableMax,
        'attributes': JsonConverters.toJson(attributes,'List<MetadataAttribute>',context!),
        'uploadTo': uploadTo,
        'input': JsonConverters.toJson(input,'InputInfo',context!),
        'format': JsonConverters.toJson(format,'FormatInfo',context!),
        'ref': JsonConverters.toJson(ref,'RefInfo',context!)
    };

    getTypeName() => "MetadataPropertyType";
    TypeContext? context = _ctx;
}

class MetadataType implements IConvertible
{
    String? name;
    String? namespace;
    List<String>? genericArgs;
    MetadataTypeName? inherits;
    List<MetadataTypeName>? Implements;
    String? displayType;
    String? description;
    String? notes;
    ImageInfo? icon;
    bool? isNested;
    bool? isEnum;
    bool? isEnumInt;
    bool? isInterface;
    bool? isAbstract;
    bool? isGenericTypeDef;
    MetadataDataContract? dataContract;
    List<MetadataPropertyType>? properties;
    List<MetadataAttribute>? attributes;
    List<MetadataTypeName>? innerTypes;
    List<String>? enumNames;
    List<String>? enumValues;
    List<String>? enumMemberValues;
    List<String>? enumDescriptions;
    Map<String,String?>? meta;

    MetadataType({this.name,this.namespace,this.genericArgs,this.inherits,this.Implements,this.displayType,this.description,this.notes,this.icon,this.isNested,this.isEnum,this.isEnumInt,this.isInterface,this.isAbstract,this.isGenericTypeDef,this.dataContract,this.properties,this.attributes,this.innerTypes,this.enumNames,this.enumValues,this.enumMemberValues,this.enumDescriptions,this.meta});
    MetadataType.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        namespace = json['namespace'];
        genericArgs = JsonConverters.fromJson(json['genericArgs'],'List<String>',context!);
        inherits = JsonConverters.fromJson(json['inherits'],'MetadataTypeName',context!);
        Implements = JsonConverters.fromJson(json['implements'],'List<MetadataTypeName>',context!);
        displayType = json['displayType'];
        description = json['description'];
        notes = json['notes'];
        icon = JsonConverters.fromJson(json['icon'],'ImageInfo',context!);
        isNested = json['isNested'];
        isEnum = json['isEnum'];
        isEnumInt = json['isEnumInt'];
        isInterface = json['isInterface'];
        isAbstract = json['isAbstract'];
        isGenericTypeDef = json['isGenericTypeDef'];
        dataContract = JsonConverters.fromJson(json['dataContract'],'MetadataDataContract',context!);
        properties = JsonConverters.fromJson(json['properties'],'List<MetadataPropertyType>',context!);
        attributes = JsonConverters.fromJson(json['attributes'],'List<MetadataAttribute>',context!);
        innerTypes = JsonConverters.fromJson(json['innerTypes'],'List<MetadataTypeName>',context!);
        enumNames = JsonConverters.fromJson(json['enumNames'],'List<String>',context!);
        enumValues = JsonConverters.fromJson(json['enumValues'],'List<String>',context!);
        enumMemberValues = JsonConverters.fromJson(json['enumMemberValues'],'List<String>',context!);
        enumDescriptions = JsonConverters.fromJson(json['enumDescriptions'],'List<String>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'namespace': namespace,
        'genericArgs': JsonConverters.toJson(genericArgs,'List<String>',context!),
        'inherits': JsonConverters.toJson(inherits,'MetadataTypeName',context!),
        'implements': JsonConverters.toJson(Implements,'List<MetadataTypeName>',context!),
        'displayType': displayType,
        'description': description,
        'notes': notes,
        'icon': JsonConverters.toJson(icon,'ImageInfo',context!),
        'isNested': isNested,
        'isEnum': isEnum,
        'isEnumInt': isEnumInt,
        'isInterface': isInterface,
        'isAbstract': isAbstract,
        'isGenericTypeDef': isGenericTypeDef,
        'dataContract': JsonConverters.toJson(dataContract,'MetadataDataContract',context!),
        'properties': JsonConverters.toJson(properties,'List<MetadataPropertyType>',context!),
        'attributes': JsonConverters.toJson(attributes,'List<MetadataAttribute>',context!),
        'innerTypes': JsonConverters.toJson(innerTypes,'List<MetadataTypeName>',context!),
        'enumNames': JsonConverters.toJson(enumNames,'List<String>',context!),
        'enumValues': JsonConverters.toJson(enumValues,'List<String>',context!),
        'enumMemberValues': JsonConverters.toJson(enumMemberValues,'List<String>',context!),
        'enumDescriptions': JsonConverters.toJson(enumDescriptions,'List<String>',context!),
        'meta': meta
    };

    getTypeName() => "MetadataType";
    TypeContext? context = _ctx;
}

class CommandInfo implements IConvertible
{
    String? name;
    String? tag;
    MetadataType? request;
    MetadataType? response;

    CommandInfo({this.name,this.tag,this.request,this.response});
    CommandInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        tag = json['tag'];
        request = JsonConverters.fromJson(json['request'],'MetadataType',context!);
        response = JsonConverters.fromJson(json['response'],'MetadataType',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'tag': tag,
        'request': JsonConverters.toJson(request,'MetadataType',context!),
        'response': JsonConverters.toJson(response,'MetadataType',context!)
    };

    getTypeName() => "CommandInfo";
    TypeContext? context = _ctx;
}

class CommandsInfo implements IConvertible
{
    List<CommandInfo>? commands;
    Map<String,String?>? meta;

    CommandsInfo({this.commands,this.meta});
    CommandsInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        commands = JsonConverters.fromJson(json['commands'],'List<CommandInfo>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'commands': JsonConverters.toJson(commands,'List<CommandInfo>',context!),
        'meta': meta
    };

    getTypeName() => "CommandsInfo";
    TypeContext? context = _ctx;
}

class AutoQueryConvention implements IConvertible
{
    String? name;
    String? value;
    String? types;
    String? valueType;

    AutoQueryConvention({this.name,this.value,this.types,this.valueType});
    AutoQueryConvention.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        value = json['value'];
        types = json['types'];
        valueType = json['valueType'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'value': value,
        'types': types,
        'valueType': valueType
    };

    getTypeName() => "AutoQueryConvention";
    TypeContext? context = _ctx;
}

class AutoQueryInfo implements IConvertible
{
    int? maxLimit;
    bool? untypedQueries;
    bool? rawSqlFilters;
    bool? autoQueryViewer;
    bool? Async;
    bool? orderByPrimaryKey;
    bool? crudEvents;
    bool? crudEventsServices;
    String? accessRole;
    String? namedConnection;
    List<AutoQueryConvention>? viewerConventions;
    Map<String,String?>? meta;

    AutoQueryInfo({this.maxLimit,this.untypedQueries,this.rawSqlFilters,this.autoQueryViewer,this.Async,this.orderByPrimaryKey,this.crudEvents,this.crudEventsServices,this.accessRole,this.namedConnection,this.viewerConventions,this.meta});
    AutoQueryInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        maxLimit = json['maxLimit'];
        untypedQueries = json['untypedQueries'];
        rawSqlFilters = json['rawSqlFilters'];
        autoQueryViewer = json['autoQueryViewer'];
        Async = json['async'];
        orderByPrimaryKey = json['orderByPrimaryKey'];
        crudEvents = json['crudEvents'];
        crudEventsServices = json['crudEventsServices'];
        accessRole = json['accessRole'];
        namedConnection = json['namedConnection'];
        viewerConventions = JsonConverters.fromJson(json['viewerConventions'],'List<AutoQueryConvention>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'maxLimit': maxLimit,
        'untypedQueries': untypedQueries,
        'rawSqlFilters': rawSqlFilters,
        'autoQueryViewer': autoQueryViewer,
        'async': Async,
        'orderByPrimaryKey': orderByPrimaryKey,
        'crudEvents': crudEvents,
        'crudEventsServices': crudEventsServices,
        'accessRole': accessRole,
        'namedConnection': namedConnection,
        'viewerConventions': JsonConverters.toJson(viewerConventions,'List<AutoQueryConvention>',context!),
        'meta': meta
    };

    getTypeName() => "AutoQueryInfo";
    TypeContext? context = _ctx;
}

class ScriptMethodType implements IConvertible
{
    String? name;
    List<String>? paramNames;
    List<String>? paramTypes;
    String? returnType;

    ScriptMethodType({this.name,this.paramNames,this.paramTypes,this.returnType});
    ScriptMethodType.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        paramNames = JsonConverters.fromJson(json['paramNames'],'List<String>',context!);
        paramTypes = JsonConverters.fromJson(json['paramTypes'],'List<String>',context!);
        returnType = json['returnType'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'paramNames': JsonConverters.toJson(paramNames,'List<String>',context!),
        'paramTypes': JsonConverters.toJson(paramTypes,'List<String>',context!),
        'returnType': returnType
    };

    getTypeName() => "ScriptMethodType";
    TypeContext? context = _ctx;
}

class ValidationInfo implements IConvertible
{
    bool? hasValidationSource;
    bool? hasValidationSourceAdmin;
    Map<String,List<String>?>? serviceRoutes;
    List<ScriptMethodType>? typeValidators;
    List<ScriptMethodType>? propertyValidators;
    String? accessRole;
    Map<String,String?>? meta;

    ValidationInfo({this.hasValidationSource,this.hasValidationSourceAdmin,this.serviceRoutes,this.typeValidators,this.propertyValidators,this.accessRole,this.meta});
    ValidationInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        hasValidationSource = json['hasValidationSource'];
        hasValidationSourceAdmin = json['hasValidationSourceAdmin'];
        serviceRoutes = JsonConverters.fromJson(json['serviceRoutes'],'Map<String,List<String>?>',context!);
        typeValidators = JsonConverters.fromJson(json['typeValidators'],'List<ScriptMethodType>',context!);
        propertyValidators = JsonConverters.fromJson(json['propertyValidators'],'List<ScriptMethodType>',context!);
        accessRole = json['accessRole'];
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'hasValidationSource': hasValidationSource,
        'hasValidationSourceAdmin': hasValidationSourceAdmin,
        'serviceRoutes': JsonConverters.toJson(serviceRoutes,'Map<String,List<String>?>',context!),
        'typeValidators': JsonConverters.toJson(typeValidators,'List<ScriptMethodType>',context!),
        'propertyValidators': JsonConverters.toJson(propertyValidators,'List<ScriptMethodType>',context!),
        'accessRole': accessRole,
        'meta': meta
    };

    getTypeName() => "ValidationInfo";
    TypeContext? context = _ctx;
}

class SharpPagesInfo implements IConvertible
{
    String? apiPath;
    String? scriptAdminRole;
    String? metadataDebugAdminRole;
    bool? metadataDebug;
    bool? spaFallback;
    Map<String,String?>? meta;

    SharpPagesInfo({this.apiPath,this.scriptAdminRole,this.metadataDebugAdminRole,this.metadataDebug,this.spaFallback,this.meta});
    SharpPagesInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        apiPath = json['apiPath'];
        scriptAdminRole = json['scriptAdminRole'];
        metadataDebugAdminRole = json['metadataDebugAdminRole'];
        metadataDebug = json['metadataDebug'];
        spaFallback = json['spaFallback'];
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'apiPath': apiPath,
        'scriptAdminRole': scriptAdminRole,
        'metadataDebugAdminRole': metadataDebugAdminRole,
        'metadataDebug': metadataDebug,
        'spaFallback': spaFallback,
        'meta': meta
    };

    getTypeName() => "SharpPagesInfo";
    TypeContext? context = _ctx;
}

class RequestLogsAnalytics implements IConvertible
{
    List<String>? months;
    Map<String,String?>? tabs;
    bool? disableAnalytics;
    bool? disableUserAnalytics;
    bool? disableApiKeyAnalytics;

    RequestLogsAnalytics({this.months,this.tabs,this.disableAnalytics,this.disableUserAnalytics,this.disableApiKeyAnalytics});
    RequestLogsAnalytics.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        months = JsonConverters.fromJson(json['months'],'List<String>',context!);
        tabs = JsonConverters.toStringMap(json['tabs']);
        disableAnalytics = json['disableAnalytics'];
        disableUserAnalytics = json['disableUserAnalytics'];
        disableApiKeyAnalytics = json['disableApiKeyAnalytics'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'months': JsonConverters.toJson(months,'List<String>',context!),
        'tabs': tabs,
        'disableAnalytics': disableAnalytics,
        'disableUserAnalytics': disableUserAnalytics,
        'disableApiKeyAnalytics': disableApiKeyAnalytics
    };

    getTypeName() => "RequestLogsAnalytics";
    TypeContext? context = _ctx;
}

class RequestLogsInfo implements IConvertible
{
    String? accessRole;
    String? requestLogger;
    int? defaultLimit;
    Map<String,List<String>?>? serviceRoutes;
    RequestLogsAnalytics? analytics;
    Map<String,String?>? meta;

    RequestLogsInfo({this.accessRole,this.requestLogger,this.defaultLimit,this.serviceRoutes,this.analytics,this.meta});
    RequestLogsInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        accessRole = json['accessRole'];
        requestLogger = json['requestLogger'];
        defaultLimit = json['defaultLimit'];
        serviceRoutes = JsonConverters.fromJson(json['serviceRoutes'],'Map<String,List<String>?>',context!);
        analytics = JsonConverters.fromJson(json['analytics'],'RequestLogsAnalytics',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'accessRole': accessRole,
        'requestLogger': requestLogger,
        'defaultLimit': defaultLimit,
        'serviceRoutes': JsonConverters.toJson(serviceRoutes,'Map<String,List<String>?>',context!),
        'analytics': JsonConverters.toJson(analytics,'RequestLogsAnalytics',context!),
        'meta': meta
    };

    getTypeName() => "RequestLogsInfo";
    TypeContext? context = _ctx;
}

class ProfilingInfo implements IConvertible
{
    String? accessRole;
    int? defaultLimit;
    List<String>? summaryFields;
    String? tagLabel;
    Map<String,String?>? meta;

    ProfilingInfo({this.accessRole,this.defaultLimit,this.summaryFields,this.tagLabel,this.meta});
    ProfilingInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        accessRole = json['accessRole'];
        defaultLimit = json['defaultLimit'];
        summaryFields = JsonConverters.fromJson(json['summaryFields'],'List<String>',context!);
        tagLabel = json['tagLabel'];
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'accessRole': accessRole,
        'defaultLimit': defaultLimit,
        'summaryFields': JsonConverters.toJson(summaryFields,'List<String>',context!),
        'tagLabel': tagLabel,
        'meta': meta
    };

    getTypeName() => "ProfilingInfo";
    TypeContext? context = _ctx;
}

class FilesUploadLocation implements IConvertible
{
    String? name;
    String? readAccessRole;
    String? writeAccessRole;
    List<String>? allowExtensions;
    String? allowOperations;
    int? maxFileCount;
    int? minFileBytes;
    int? maxFileBytes;

    FilesUploadLocation({this.name,this.readAccessRole,this.writeAccessRole,this.allowExtensions,this.allowOperations,this.maxFileCount,this.minFileBytes,this.maxFileBytes});
    FilesUploadLocation.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        readAccessRole = json['readAccessRole'];
        writeAccessRole = json['writeAccessRole'];
        allowExtensions = JsonConverters.fromJson(json['allowExtensions'],'List<String>',context!);
        allowOperations = json['allowOperations'];
        maxFileCount = json['maxFileCount'];
        minFileBytes = json['minFileBytes'];
        maxFileBytes = json['maxFileBytes'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'readAccessRole': readAccessRole,
        'writeAccessRole': writeAccessRole,
        'allowExtensions': JsonConverters.toJson(allowExtensions,'List<String>',context!),
        'allowOperations': allowOperations,
        'maxFileCount': maxFileCount,
        'minFileBytes': minFileBytes,
        'maxFileBytes': maxFileBytes
    };

    getTypeName() => "FilesUploadLocation";
    TypeContext? context = _ctx;
}

class FilesUploadInfo implements IConvertible
{
    String? basePath;
    List<FilesUploadLocation>? locations;
    Map<String,String?>? meta;

    FilesUploadInfo({this.basePath,this.locations,this.meta});
    FilesUploadInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        basePath = json['basePath'];
        locations = JsonConverters.fromJson(json['locations'],'List<FilesUploadLocation>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'basePath': basePath,
        'locations': JsonConverters.toJson(locations,'List<FilesUploadLocation>',context!),
        'meta': meta
    };

    getTypeName() => "FilesUploadInfo";
    TypeContext? context = _ctx;
}

class MediaRule implements IConvertible
{
    String? size;
    String? rule;
    List<String>? applyTo;
    Map<String,String?>? meta;

    MediaRule({this.size,this.rule,this.applyTo,this.meta});
    MediaRule.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        size = json['size'];
        rule = json['rule'];
        applyTo = JsonConverters.fromJson(json['applyTo'],'List<String>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'size': size,
        'rule': rule,
        'applyTo': JsonConverters.toJson(applyTo,'List<String>',context!),
        'meta': meta
    };

    getTypeName() => "MediaRule";
    TypeContext? context = _ctx;
}

class AdminUsersInfo implements IConvertible
{
    String? accessRole;
    List<String>? enabled;
    MetadataType? userAuth;
    List<String>? allRoles;
    List<String>? allPermissions;
    List<String>? queryUserAuthProperties;
    List<MediaRule>? queryMediaRules;
    List<InputInfo>? formLayout;
    ApiCss? css;
    Map<String,String?>? meta;

    AdminUsersInfo({this.accessRole,this.enabled,this.userAuth,this.allRoles,this.allPermissions,this.queryUserAuthProperties,this.queryMediaRules,this.formLayout,this.css,this.meta});
    AdminUsersInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        accessRole = json['accessRole'];
        enabled = JsonConverters.fromJson(json['enabled'],'List<String>',context!);
        userAuth = JsonConverters.fromJson(json['userAuth'],'MetadataType',context!);
        allRoles = JsonConverters.fromJson(json['allRoles'],'List<String>',context!);
        allPermissions = JsonConverters.fromJson(json['allPermissions'],'List<String>',context!);
        queryUserAuthProperties = JsonConverters.fromJson(json['queryUserAuthProperties'],'List<String>',context!);
        queryMediaRules = JsonConverters.fromJson(json['queryMediaRules'],'List<MediaRule>',context!);
        formLayout = JsonConverters.fromJson(json['formLayout'],'List<InputInfo>',context!);
        css = JsonConverters.fromJson(json['css'],'ApiCss',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'accessRole': accessRole,
        'enabled': JsonConverters.toJson(enabled,'List<String>',context!),
        'userAuth': JsonConverters.toJson(userAuth,'MetadataType',context!),
        'allRoles': JsonConverters.toJson(allRoles,'List<String>',context!),
        'allPermissions': JsonConverters.toJson(allPermissions,'List<String>',context!),
        'queryUserAuthProperties': JsonConverters.toJson(queryUserAuthProperties,'List<String>',context!),
        'queryMediaRules': JsonConverters.toJson(queryMediaRules,'List<MediaRule>',context!),
        'formLayout': JsonConverters.toJson(formLayout,'List<InputInfo>',context!),
        'css': JsonConverters.toJson(css,'ApiCss',context!),
        'meta': meta
    };

    getTypeName() => "AdminUsersInfo";
    TypeContext? context = _ctx;
}

class AdminIdentityUsersInfo implements IConvertible
{
    String? accessRole;
    List<String>? enabled;
    MetadataType? identityUser;
    List<String>? allRoles;
    List<String>? allPermissions;
    List<String>? queryIdentityUserProperties;
    List<MediaRule>? queryMediaRules;
    List<InputInfo>? formLayout;
    ApiCss? css;
    Map<String,String?>? meta;

    AdminIdentityUsersInfo({this.accessRole,this.enabled,this.identityUser,this.allRoles,this.allPermissions,this.queryIdentityUserProperties,this.queryMediaRules,this.formLayout,this.css,this.meta});
    AdminIdentityUsersInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        accessRole = json['accessRole'];
        enabled = JsonConverters.fromJson(json['enabled'],'List<String>',context!);
        identityUser = JsonConverters.fromJson(json['identityUser'],'MetadataType',context!);
        allRoles = JsonConverters.fromJson(json['allRoles'],'List<String>',context!);
        allPermissions = JsonConverters.fromJson(json['allPermissions'],'List<String>',context!);
        queryIdentityUserProperties = JsonConverters.fromJson(json['queryIdentityUserProperties'],'List<String>',context!);
        queryMediaRules = JsonConverters.fromJson(json['queryMediaRules'],'List<MediaRule>',context!);
        formLayout = JsonConverters.fromJson(json['formLayout'],'List<InputInfo>',context!);
        css = JsonConverters.fromJson(json['css'],'ApiCss',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'accessRole': accessRole,
        'enabled': JsonConverters.toJson(enabled,'List<String>',context!),
        'identityUser': JsonConverters.toJson(identityUser,'MetadataType',context!),
        'allRoles': JsonConverters.toJson(allRoles,'List<String>',context!),
        'allPermissions': JsonConverters.toJson(allPermissions,'List<String>',context!),
        'queryIdentityUserProperties': JsonConverters.toJson(queryIdentityUserProperties,'List<String>',context!),
        'queryMediaRules': JsonConverters.toJson(queryMediaRules,'List<MediaRule>',context!),
        'formLayout': JsonConverters.toJson(formLayout,'List<InputInfo>',context!),
        'css': JsonConverters.toJson(css,'ApiCss',context!),
        'meta': meta
    };

    getTypeName() => "AdminIdentityUsersInfo";
    TypeContext? context = _ctx;
}

class AdminRedisInfo implements IConvertible
{
    int? queryLimit;
    List<int>? databases;
    bool? modifiableConnection;
    RedisEndpointInfo? endpoint;
    Map<String,String?>? meta;

    AdminRedisInfo({this.queryLimit,this.databases,this.modifiableConnection,this.endpoint,this.meta});
    AdminRedisInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        queryLimit = json['queryLimit'];
        databases = JsonConverters.fromJson(json['databases'],'List<int>',context!);
        modifiableConnection = json['modifiableConnection'];
        endpoint = JsonConverters.fromJson(json['endpoint'],'RedisEndpointInfo',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'queryLimit': queryLimit,
        'databases': JsonConverters.toJson(databases,'List<int>',context!),
        'modifiableConnection': modifiableConnection,
        'endpoint': JsonConverters.toJson(endpoint,'RedisEndpointInfo',context!),
        'meta': meta
    };

    getTypeName() => "AdminRedisInfo";
    TypeContext? context = _ctx;
}

class SchemaInfo implements IConvertible
{
    String? alias;
    String? name;
    List<String>? tables;

    SchemaInfo({this.alias,this.name,this.tables});
    SchemaInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        alias = json['alias'];
        name = json['name'];
        tables = JsonConverters.fromJson(json['tables'],'List<String>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'alias': alias,
        'name': name,
        'tables': JsonConverters.toJson(tables,'List<String>',context!)
    };

    getTypeName() => "SchemaInfo";
    TypeContext? context = _ctx;
}

class DatabaseInfo implements IConvertible
{
    String? alias;
    String? name;
    List<SchemaInfo>? schemas;

    DatabaseInfo({this.alias,this.name,this.schemas});
    DatabaseInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        alias = json['alias'];
        name = json['name'];
        schemas = JsonConverters.fromJson(json['schemas'],'List<SchemaInfo>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'alias': alias,
        'name': name,
        'schemas': JsonConverters.toJson(schemas,'List<SchemaInfo>',context!)
    };

    getTypeName() => "DatabaseInfo";
    TypeContext? context = _ctx;
}

class AdminDatabaseInfo implements IConvertible
{
    int? queryLimit;
    List<DatabaseInfo>? databases;
    Map<String,String?>? meta;

    AdminDatabaseInfo({this.queryLimit,this.databases,this.meta});
    AdminDatabaseInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        queryLimit = json['queryLimit'];
        databases = JsonConverters.fromJson(json['databases'],'List<DatabaseInfo>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'queryLimit': queryLimit,
        'databases': JsonConverters.toJson(databases,'List<DatabaseInfo>',context!),
        'meta': meta
    };

    getTypeName() => "AdminDatabaseInfo";
    TypeContext? context = _ctx;
}

class PluginInfo implements IConvertible
{
    List<String>? loaded;
    AuthInfo? auth;
    ApiKeyInfo? apiKey;
    CommandsInfo? commands;
    AutoQueryInfo? autoQuery;
    ValidationInfo? validation;
    SharpPagesInfo? sharpPages;
    RequestLogsInfo? requestLogs;
    ProfilingInfo? profiling;
    FilesUploadInfo? filesUpload;
    AdminUsersInfo? adminUsers;
    AdminIdentityUsersInfo? adminIdentityUsers;
    AdminRedisInfo? adminRedis;
    AdminDatabaseInfo? adminDatabase;
    Map<String,String?>? meta;

    PluginInfo({this.loaded,this.auth,this.apiKey,this.commands,this.autoQuery,this.validation,this.sharpPages,this.requestLogs,this.profiling,this.filesUpload,this.adminUsers,this.adminIdentityUsers,this.adminRedis,this.adminDatabase,this.meta});
    PluginInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        loaded = JsonConverters.fromJson(json['loaded'],'List<String>',context!);
        auth = JsonConverters.fromJson(json['auth'],'AuthInfo',context!);
        apiKey = JsonConverters.fromJson(json['apiKey'],'ApiKeyInfo',context!);
        commands = JsonConverters.fromJson(json['commands'],'CommandsInfo',context!);
        autoQuery = JsonConverters.fromJson(json['autoQuery'],'AutoQueryInfo',context!);
        validation = JsonConverters.fromJson(json['validation'],'ValidationInfo',context!);
        sharpPages = JsonConverters.fromJson(json['sharpPages'],'SharpPagesInfo',context!);
        requestLogs = JsonConverters.fromJson(json['requestLogs'],'RequestLogsInfo',context!);
        profiling = JsonConverters.fromJson(json['profiling'],'ProfilingInfo',context!);
        filesUpload = JsonConverters.fromJson(json['filesUpload'],'FilesUploadInfo',context!);
        adminUsers = JsonConverters.fromJson(json['adminUsers'],'AdminUsersInfo',context!);
        adminIdentityUsers = JsonConverters.fromJson(json['adminIdentityUsers'],'AdminIdentityUsersInfo',context!);
        adminRedis = JsonConverters.fromJson(json['adminRedis'],'AdminRedisInfo',context!);
        adminDatabase = JsonConverters.fromJson(json['adminDatabase'],'AdminDatabaseInfo',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'loaded': JsonConverters.toJson(loaded,'List<String>',context!),
        'auth': JsonConverters.toJson(auth,'AuthInfo',context!),
        'apiKey': JsonConverters.toJson(apiKey,'ApiKeyInfo',context!),
        'commands': JsonConverters.toJson(commands,'CommandsInfo',context!),
        'autoQuery': JsonConverters.toJson(autoQuery,'AutoQueryInfo',context!),
        'validation': JsonConverters.toJson(validation,'ValidationInfo',context!),
        'sharpPages': JsonConverters.toJson(sharpPages,'SharpPagesInfo',context!),
        'requestLogs': JsonConverters.toJson(requestLogs,'RequestLogsInfo',context!),
        'profiling': JsonConverters.toJson(profiling,'ProfilingInfo',context!),
        'filesUpload': JsonConverters.toJson(filesUpload,'FilesUploadInfo',context!),
        'adminUsers': JsonConverters.toJson(adminUsers,'AdminUsersInfo',context!),
        'adminIdentityUsers': JsonConverters.toJson(adminIdentityUsers,'AdminIdentityUsersInfo',context!),
        'adminRedis': JsonConverters.toJson(adminRedis,'AdminRedisInfo',context!),
        'adminDatabase': JsonConverters.toJson(adminDatabase,'AdminDatabaseInfo',context!),
        'meta': meta
    };

    getTypeName() => "PluginInfo";
    TypeContext? context = _ctx;
}

class CustomPluginInfo implements IConvertible
{
    String? accessRole;
    Map<String,List<String>?>? serviceRoutes;
    List<String>? enabled;
    Map<String,String?>? meta;

    CustomPluginInfo({this.accessRole,this.serviceRoutes,this.enabled,this.meta});
    CustomPluginInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        accessRole = json['accessRole'];
        serviceRoutes = JsonConverters.fromJson(json['serviceRoutes'],'Map<String,List<String>?>',context!);
        enabled = JsonConverters.fromJson(json['enabled'],'List<String>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'accessRole': accessRole,
        'serviceRoutes': JsonConverters.toJson(serviceRoutes,'Map<String,List<String>?>',context!),
        'enabled': JsonConverters.toJson(enabled,'List<String>',context!),
        'meta': meta
    };

    getTypeName() => "CustomPluginInfo";
    TypeContext? context = _ctx;
}

class MetadataTypesConfig implements IConvertible
{
    String? baseUrl;
    bool? makePartial;
    bool? makeVirtual;
    bool? makeInternal;
    String? baseClass;
    String? package;
    bool? addReturnMarker;
    bool? addDescriptionAsComments;
    bool? addDocAnnotations;
    bool? addDataContractAttributes;
    bool? addIndexesToDataMembers;
    bool? addGeneratedCodeAttributes;
    int? addImplicitVersion;
    bool? addResponseStatus;
    bool? addServiceStackTypes;
    bool? addModelExtensions;
    bool? addPropertyAccessors;
    bool? excludeGenericBaseTypes;
    bool? settersReturnThis;
    bool? addNullableAnnotations;
    bool? makePropertiesOptional;
    bool? exportAsTypes;
    bool? excludeImplementedInterfaces;
    String? addDefaultXmlNamespace;
    bool? makeDataContractsExtensible;
    bool? initializeCollections;
    List<String>? addNamespaces;
    List<String>? defaultNamespaces;
    List<String>? defaultImports;
    List<String>? includeTypes;
    List<String>? excludeTypes;
    List<String>? exportTags;
    List<String>? treatTypesAsStrings;
    bool? exportValueTypes;
    String? globalNamespace;
    bool? excludeNamespace;
    String? dataClass;
    String? dataClassJson;
    List<String>? ignoreTypes;
    List<String>? exportTypes;
    List<String>? exportAttributes;
    List<String>? ignoreTypesInNamespaces;

    MetadataTypesConfig({this.baseUrl,this.makePartial,this.makeVirtual,this.makeInternal,this.baseClass,this.package,this.addReturnMarker,this.addDescriptionAsComments,this.addDocAnnotations,this.addDataContractAttributes,this.addIndexesToDataMembers,this.addGeneratedCodeAttributes,this.addImplicitVersion,this.addResponseStatus,this.addServiceStackTypes,this.addModelExtensions,this.addPropertyAccessors,this.excludeGenericBaseTypes,this.settersReturnThis,this.addNullableAnnotations,this.makePropertiesOptional,this.exportAsTypes,this.excludeImplementedInterfaces,this.addDefaultXmlNamespace,this.makeDataContractsExtensible,this.initializeCollections,this.addNamespaces,this.defaultNamespaces,this.defaultImports,this.includeTypes,this.excludeTypes,this.exportTags,this.treatTypesAsStrings,this.exportValueTypes,this.globalNamespace,this.excludeNamespace,this.dataClass,this.dataClassJson,this.ignoreTypes,this.exportTypes,this.exportAttributes,this.ignoreTypesInNamespaces});
    MetadataTypesConfig.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        baseUrl = json['baseUrl'];
        makePartial = json['makePartial'];
        makeVirtual = json['makeVirtual'];
        makeInternal = json['makeInternal'];
        baseClass = json['baseClass'];
        package = json['package'];
        addReturnMarker = json['addReturnMarker'];
        addDescriptionAsComments = json['addDescriptionAsComments'];
        addDocAnnotations = json['addDocAnnotations'];
        addDataContractAttributes = json['addDataContractAttributes'];
        addIndexesToDataMembers = json['addIndexesToDataMembers'];
        addGeneratedCodeAttributes = json['addGeneratedCodeAttributes'];
        addImplicitVersion = json['addImplicitVersion'];
        addResponseStatus = json['addResponseStatus'];
        addServiceStackTypes = json['addServiceStackTypes'];
        addModelExtensions = json['addModelExtensions'];
        addPropertyAccessors = json['addPropertyAccessors'];
        excludeGenericBaseTypes = json['excludeGenericBaseTypes'];
        settersReturnThis = json['settersReturnThis'];
        addNullableAnnotations = json['addNullableAnnotations'];
        makePropertiesOptional = json['makePropertiesOptional'];
        exportAsTypes = json['exportAsTypes'];
        excludeImplementedInterfaces = json['excludeImplementedInterfaces'];
        addDefaultXmlNamespace = json['addDefaultXmlNamespace'];
        makeDataContractsExtensible = json['makeDataContractsExtensible'];
        initializeCollections = json['initializeCollections'];
        addNamespaces = JsonConverters.fromJson(json['addNamespaces'],'List<String>',context!);
        defaultNamespaces = JsonConverters.fromJson(json['defaultNamespaces'],'List<String>',context!);
        defaultImports = JsonConverters.fromJson(json['defaultImports'],'List<String>',context!);
        includeTypes = JsonConverters.fromJson(json['includeTypes'],'List<String>',context!);
        excludeTypes = JsonConverters.fromJson(json['excludeTypes'],'List<String>',context!);
        exportTags = JsonConverters.fromJson(json['exportTags'],'List<String>',context!);
        treatTypesAsStrings = JsonConverters.fromJson(json['treatTypesAsStrings'],'List<String>',context!);
        exportValueTypes = json['exportValueTypes'];
        globalNamespace = json['globalNamespace'];
        excludeNamespace = json['excludeNamespace'];
        dataClass = json['dataClass'];
        dataClassJson = json['dataClassJson'];
        ignoreTypes = JsonConverters.fromJson(json['ignoreTypes'],'List<String>',context!);
        exportTypes = JsonConverters.fromJson(json['exportTypes'],'List<String>',context!);
        exportAttributes = JsonConverters.fromJson(json['exportAttributes'],'List<String>',context!);
        ignoreTypesInNamespaces = JsonConverters.fromJson(json['ignoreTypesInNamespaces'],'List<String>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'baseUrl': baseUrl,
        'makePartial': makePartial,
        'makeVirtual': makeVirtual,
        'makeInternal': makeInternal,
        'baseClass': baseClass,
        'package': package,
        'addReturnMarker': addReturnMarker,
        'addDescriptionAsComments': addDescriptionAsComments,
        'addDocAnnotations': addDocAnnotations,
        'addDataContractAttributes': addDataContractAttributes,
        'addIndexesToDataMembers': addIndexesToDataMembers,
        'addGeneratedCodeAttributes': addGeneratedCodeAttributes,
        'addImplicitVersion': addImplicitVersion,
        'addResponseStatus': addResponseStatus,
        'addServiceStackTypes': addServiceStackTypes,
        'addModelExtensions': addModelExtensions,
        'addPropertyAccessors': addPropertyAccessors,
        'excludeGenericBaseTypes': excludeGenericBaseTypes,
        'settersReturnThis': settersReturnThis,
        'addNullableAnnotations': addNullableAnnotations,
        'makePropertiesOptional': makePropertiesOptional,
        'exportAsTypes': exportAsTypes,
        'excludeImplementedInterfaces': excludeImplementedInterfaces,
        'addDefaultXmlNamespace': addDefaultXmlNamespace,
        'makeDataContractsExtensible': makeDataContractsExtensible,
        'initializeCollections': initializeCollections,
        'addNamespaces': JsonConverters.toJson(addNamespaces,'List<String>',context!),
        'defaultNamespaces': JsonConverters.toJson(defaultNamespaces,'List<String>',context!),
        'defaultImports': JsonConverters.toJson(defaultImports,'List<String>',context!),
        'includeTypes': JsonConverters.toJson(includeTypes,'List<String>',context!),
        'excludeTypes': JsonConverters.toJson(excludeTypes,'List<String>',context!),
        'exportTags': JsonConverters.toJson(exportTags,'List<String>',context!),
        'treatTypesAsStrings': JsonConverters.toJson(treatTypesAsStrings,'List<String>',context!),
        'exportValueTypes': exportValueTypes,
        'globalNamespace': globalNamespace,
        'excludeNamespace': excludeNamespace,
        'dataClass': dataClass,
        'dataClassJson': dataClassJson,
        'ignoreTypes': JsonConverters.toJson(ignoreTypes,'List<String>',context!),
        'exportTypes': JsonConverters.toJson(exportTypes,'List<String>',context!),
        'exportAttributes': JsonConverters.toJson(exportAttributes,'List<String>',context!),
        'ignoreTypesInNamespaces': JsonConverters.toJson(ignoreTypesInNamespaces,'List<String>',context!)
    };

    getTypeName() => "MetadataTypesConfig";
    TypeContext? context = _ctx;
}

class MetadataRoute implements IConvertible
{
    String? path;
    String? verbs;
    String? notes;
    String? summary;

    MetadataRoute({this.path,this.verbs,this.notes,this.summary});
    MetadataRoute.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        path = json['path'];
        verbs = json['verbs'];
        notes = json['notes'];
        summary = json['summary'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'path': path,
        'verbs': verbs,
        'notes': notes,
        'summary': summary
    };

    getTypeName() => "MetadataRoute";
    TypeContext? context = _ctx;
}

class ApiUiInfo implements IConvertible
{
    ApiCss? locodeCss;
    ApiCss? explorerCss;
    List<InputInfo>? formLayout;
    Map<String,String?>? meta;

    ApiUiInfo({this.locodeCss,this.explorerCss,this.formLayout,this.meta});
    ApiUiInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        locodeCss = JsonConverters.fromJson(json['locodeCss'],'ApiCss',context!);
        explorerCss = JsonConverters.fromJson(json['explorerCss'],'ApiCss',context!);
        formLayout = JsonConverters.fromJson(json['formLayout'],'List<InputInfo>',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'locodeCss': JsonConverters.toJson(locodeCss,'ApiCss',context!),
        'explorerCss': JsonConverters.toJson(explorerCss,'ApiCss',context!),
        'formLayout': JsonConverters.toJson(formLayout,'List<InputInfo>',context!),
        'meta': meta
    };

    getTypeName() => "ApiUiInfo";
    TypeContext? context = _ctx;
}

class MetadataOperationType implements IConvertible
{
    MetadataType? request;
    MetadataType? response;
    List<String>? actions;
    bool? returnsVoid;
    String? method;
    MetadataTypeName? returnType;
    List<MetadataRoute>? routes;
    MetadataTypeName? dataModel;
    MetadataTypeName? viewModel;
    bool? requiresAuth;
    bool? requiresApiKey;
    List<String>? requiredRoles;
    List<String>? requiresAnyRole;
    List<String>? requiredPermissions;
    List<String>? requiresAnyPermission;
    List<String>? tags;
    ApiUiInfo? ui;

    MetadataOperationType({this.request,this.response,this.actions,this.returnsVoid,this.method,this.returnType,this.routes,this.dataModel,this.viewModel,this.requiresAuth,this.requiresApiKey,this.requiredRoles,this.requiresAnyRole,this.requiredPermissions,this.requiresAnyPermission,this.tags,this.ui});
    MetadataOperationType.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        request = JsonConverters.fromJson(json['request'],'MetadataType',context!);
        response = JsonConverters.fromJson(json['response'],'MetadataType',context!);
        actions = JsonConverters.fromJson(json['actions'],'List<String>',context!);
        returnsVoid = json['returnsVoid'];
        method = json['method'];
        returnType = JsonConverters.fromJson(json['returnType'],'MetadataTypeName',context!);
        routes = JsonConverters.fromJson(json['routes'],'List<MetadataRoute>',context!);
        dataModel = JsonConverters.fromJson(json['dataModel'],'MetadataTypeName',context!);
        viewModel = JsonConverters.fromJson(json['viewModel'],'MetadataTypeName',context!);
        requiresAuth = json['requiresAuth'];
        requiresApiKey = json['requiresApiKey'];
        requiredRoles = JsonConverters.fromJson(json['requiredRoles'],'List<String>',context!);
        requiresAnyRole = JsonConverters.fromJson(json['requiresAnyRole'],'List<String>',context!);
        requiredPermissions = JsonConverters.fromJson(json['requiredPermissions'],'List<String>',context!);
        requiresAnyPermission = JsonConverters.fromJson(json['requiresAnyPermission'],'List<String>',context!);
        tags = JsonConverters.fromJson(json['tags'],'List<String>',context!);
        ui = JsonConverters.fromJson(json['ui'],'ApiUiInfo',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'request': JsonConverters.toJson(request,'MetadataType',context!),
        'response': JsonConverters.toJson(response,'MetadataType',context!),
        'actions': JsonConverters.toJson(actions,'List<String>',context!),
        'returnsVoid': returnsVoid,
        'method': method,
        'returnType': JsonConverters.toJson(returnType,'MetadataTypeName',context!),
        'routes': JsonConverters.toJson(routes,'List<MetadataRoute>',context!),
        'dataModel': JsonConverters.toJson(dataModel,'MetadataTypeName',context!),
        'viewModel': JsonConverters.toJson(viewModel,'MetadataTypeName',context!),
        'requiresAuth': requiresAuth,
        'requiresApiKey': requiresApiKey,
        'requiredRoles': JsonConverters.toJson(requiredRoles,'List<String>',context!),
        'requiresAnyRole': JsonConverters.toJson(requiresAnyRole,'List<String>',context!),
        'requiredPermissions': JsonConverters.toJson(requiredPermissions,'List<String>',context!),
        'requiresAnyPermission': JsonConverters.toJson(requiresAnyPermission,'List<String>',context!),
        'tags': JsonConverters.toJson(tags,'List<String>',context!),
        'ui': JsonConverters.toJson(ui,'ApiUiInfo',context!)
    };

    getTypeName() => "MetadataOperationType";
    TypeContext? context = _ctx;
}

class MetadataTypes implements IConvertible
{
    MetadataTypesConfig? config;
    List<String>? namespaces;
    List<MetadataType>? types;
    List<MetadataOperationType>? operations;

    MetadataTypes({this.config,this.namespaces,this.types,this.operations});
    MetadataTypes.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        config = JsonConverters.fromJson(json['config'],'MetadataTypesConfig',context!);
        namespaces = JsonConverters.fromJson(json['namespaces'],'List<String>',context!);
        types = JsonConverters.fromJson(json['types'],'List<MetadataType>',context!);
        operations = JsonConverters.fromJson(json['operations'],'List<MetadataOperationType>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'config': JsonConverters.toJson(config,'MetadataTypesConfig',context!),
        'namespaces': JsonConverters.toJson(namespaces,'List<String>',context!),
        'types': JsonConverters.toJson(types,'List<MetadataType>',context!),
        'operations': JsonConverters.toJson(operations,'List<MetadataOperationType>',context!)
    };

    getTypeName() => "MetadataTypes";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminRole implements IConvertible
{
    AdminRole();
    AdminRole.fromJson(Map<String, dynamic> json) : super();
    fromMap(Map<String, dynamic> json) {
        return this;
    }

    Map<String, dynamic> toJson() => {};
    getTypeName() => "AdminRole";
    TypeContext? context = _ctx;
}

class ServerStats implements IConvertible
{
    Map<String,int?>? redis;
    Map<String,String?>? serverEvents;
    String? mqDescription;
    Map<String,int?>? mqWorkers;

    ServerStats({this.redis,this.serverEvents,this.mqDescription,this.mqWorkers});
    ServerStats.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        redis = JsonConverters.fromJson(json['redis'],'Map<String,int?>',context!);
        serverEvents = JsonConverters.toStringMap(json['serverEvents']);
        mqDescription = json['mqDescription'];
        mqWorkers = JsonConverters.fromJson(json['mqWorkers'],'Map<String,int?>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'redis': JsonConverters.toJson(redis,'Map<String,int?>',context!),
        'serverEvents': serverEvents,
        'mqDescription': mqDescription,
        'mqWorkers': JsonConverters.toJson(mqWorkers,'Map<String,int?>',context!)
    };

    getTypeName() => "ServerStats";
    TypeContext? context = _ctx;
}

// @DataContract
class PartialApiKey implements IConvertible
{
    // @DataMember(Order=1)
    int? id;

    // @DataMember(Order=2)
    String? name;

    // @DataMember(Order=3)
    String? userId;

    // @DataMember(Order=4)
    String? userName;

    // @DataMember(Order=5)
    String? visibleKey;

    // @DataMember(Order=6)
    String? environment;

    // @DataMember(Order=7)
    DateTime? createdDate;

    // @DataMember(Order=8)
    DateTime? expiryDate;

    // @DataMember(Order=9)
    DateTime? cancelledDate;

    // @DataMember(Order=10)
    DateTime? lastUsedDate;

    // @DataMember(Order=11)
    List<String>? scopes;

    // @DataMember(Order=12)
    List<String>? features;

    // @DataMember(Order=13)
    List<String>? restrictTo;

    // @DataMember(Order=14)
    String? notes;

    // @DataMember(Order=15)
    int? refId;

    // @DataMember(Order=16)
    String? refIdStr;

    // @DataMember(Order=17)
    Map<String,String?>? meta;

    // @DataMember(Order=18)
    bool? active;

    PartialApiKey({this.id,this.name,this.userId,this.userName,this.visibleKey,this.environment,this.createdDate,this.expiryDate,this.cancelledDate,this.lastUsedDate,this.scopes,this.features,this.restrictTo,this.notes,this.refId,this.refIdStr,this.meta,this.active});
    PartialApiKey.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        name = json['name'];
        userId = json['userId'];
        userName = json['userName'];
        visibleKey = json['visibleKey'];
        environment = json['environment'];
        createdDate = JsonConverters.fromJson(json['createdDate'],'DateTime',context!);
        expiryDate = JsonConverters.fromJson(json['expiryDate'],'DateTime',context!);
        cancelledDate = JsonConverters.fromJson(json['cancelledDate'],'DateTime',context!);
        lastUsedDate = JsonConverters.fromJson(json['lastUsedDate'],'DateTime',context!);
        scopes = JsonConverters.fromJson(json['scopes'],'List<String>',context!);
        features = JsonConverters.fromJson(json['features'],'List<String>',context!);
        restrictTo = JsonConverters.fromJson(json['restrictTo'],'List<String>',context!);
        notes = json['notes'];
        refId = json['refId'];
        refIdStr = json['refIdStr'];
        meta = JsonConverters.toStringMap(json['meta']);
        active = json['active'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'userId': userId,
        'userName': userName,
        'visibleKey': visibleKey,
        'environment': environment,
        'createdDate': JsonConverters.toJson(createdDate,'DateTime',context!),
        'expiryDate': JsonConverters.toJson(expiryDate,'DateTime',context!),
        'cancelledDate': JsonConverters.toJson(cancelledDate,'DateTime',context!),
        'lastUsedDate': JsonConverters.toJson(lastUsedDate,'DateTime',context!),
        'scopes': JsonConverters.toJson(scopes,'List<String>',context!),
        'features': JsonConverters.toJson(features,'List<String>',context!),
        'restrictTo': JsonConverters.toJson(restrictTo,'List<String>',context!),
        'notes': notes,
        'refId': refId,
        'refIdStr': refIdStr,
        'meta': meta,
        'active': active
    };

    getTypeName() => "PartialApiKey";
    TypeContext? context = _ctx;
}

/**
* Annotations for the message, when applicable, as when using the web search tool.
*/
// @DataContract
class UrlCitation implements IConvertible
{
    /**
    * The index of the last character of the URL citation in the message.
    */
    // @DataMember(Name="end_index")
    int? end_index;

    /**
    * The index of the first character of the URL citation in the message.
    */
    // @DataMember(Name="start_index")
    int? start_index;

    /**
    * The title of the web resource.
    */
    // @DataMember(Name="title")
    String? title;

    /**
    * The URL of the web resource.
    */
    // @DataMember(Name="url")
    String? url;

    UrlCitation({this.end_index,this.start_index,this.title,this.url});
    UrlCitation.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        end_index = json['endIndex'];
        start_index = json['startIndex'];
        title = json['title'];
        url = json['url'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'end_index': end_index,
        'start_index': start_index,
        'title': title,
        'url': url
    };

    getTypeName() => "UrlCitation";
    TypeContext? context = _ctx;
}

/**
* Annotations for the message, when applicable, as when using the web search tool.
*/
// @DataContract
class ChoiceAnnotation implements IConvertible
{
    /**
    * The type of the URL citation. Always url_citation.
    */
    // @DataMember(Name="type")
    String? type;

    /**
    * A URL citation when using web search.
    */
    // @DataMember(Name="url_citation")
    UrlCitation? url_citation;

    ChoiceAnnotation({this.type,this.url_citation});
    ChoiceAnnotation.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        type = json['type'];
        url_citation = JsonConverters.fromJson(json['urlCitation'],'UrlCitation',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'type': type,
        'url_citation': JsonConverters.toJson(url_citation,'UrlCitation',context!)
    };

    getTypeName() => "ChoiceAnnotation";
    TypeContext? context = _ctx;
}

/**
* If the audio output modality is requested, this object contains data about the audio response from the model.
*/
// @DataContract
class ChoiceAudio implements IConvertible
{
    /**
    * Base64 encoded audio bytes generated by the model, in the format specified in the request.
    */
    // @DataMember(Name="data")
    String? data;

    /**
    * The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server for use in multi-turn conversations.
    */
    // @DataMember(Name="expires_at")
    int? expires_at;

    /**
    * Unique identifier for this audio response.
    */
    // @DataMember(Name="id")
    String? id;

    /**
    * Transcript of the audio generated by the model.
    */
    // @DataMember(Name="transcript")
    String? transcript;

    ChoiceAudio({this.data,this.expires_at,this.id,this.transcript});
    ChoiceAudio.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        data = json['data'];
        expires_at = json['expiresAt'];
        id = json['id'];
        transcript = json['transcript'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'data': data,
        'expires_at': expires_at,
        'id': id,
        'transcript': transcript
    };

    getTypeName() => "ChoiceAudio";
    TypeContext? context = _ctx;
}

// @DataContract
class ChoiceMessage implements IConvertible
{
    /**
    * The contents of the message.
    */
    // @DataMember(Name="content")
    String? content;

    /**
    * The refusal message generated by the model.
    */
    // @DataMember(Name="refusal")
    String? refusal;

    /**
    * The reasoning process used by the model.
    */
    // @DataMember(Name="reasoning")
    String? reasoning;

    /**
    * The role of the author of this message.
    */
    // @DataMember(Name="role")
    String? role;

    /**
    * Annotations for the message, when applicable, as when using the web search tool.
    */
    // @DataMember(Name="annotations")
    List<ChoiceAnnotation>? annotations;

    /**
    * If the audio output modality is requested, this object contains data about the audio response from the model.
    */
    // @DataMember(Name="audio")
    ChoiceAudio? audio;

    /**
    * The tool calls generated by the model, such as function calls.
    */
    // @DataMember(Name="tool_calls")
    List<ToolCall>? tool_calls;

    ChoiceMessage({this.content,this.refusal,this.reasoning,this.role,this.annotations,this.audio,this.tool_calls});
    ChoiceMessage.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        content = json['content'];
        refusal = json['refusal'];
        reasoning = json['reasoning'];
        role = json['role'];
        annotations = JsonConverters.fromJson(json['annotations'],'List<ChoiceAnnotation>',context!);
        audio = JsonConverters.fromJson(json['audio'],'ChoiceAudio',context!);
        tool_calls = JsonConverters.fromJson(json['toolCalls'],'List<ToolCall>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'content': content,
        'refusal': refusal,
        'reasoning': reasoning,
        'role': role,
        'annotations': JsonConverters.toJson(annotations,'List<ChoiceAnnotation>',context!),
        'audio': JsonConverters.toJson(audio,'ChoiceAudio',context!),
        'tool_calls': JsonConverters.toJson(tool_calls,'List<ToolCall>',context!)
    };

    getTypeName() => "ChoiceMessage";
    TypeContext? context = _ctx;
}

// @DataContract
class Choice implements IConvertible
{
    /**
    * The reason the model stopped generating tokens. This will be stop if the model hit a natural stop point or a provided stop sequence, length if the maximum number of tokens specified in the request was reached, content_filter if content was omitted due to a flag from our content filters, tool_calls if the model called a tool
    */
    // @DataMember(Name="finish_reason")
    String? finish_reason;

    /**
    * The index of the choice in the list of choices.
    */
    // @DataMember(Name="index")
    int? index;

    /**
    * A chat completion message generated by the model.
    */
    // @DataMember(Name="message")
    ChoiceMessage? message;

    Choice({this.finish_reason,this.index,this.message});
    Choice.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        finish_reason = json['finishReason'];
        index = json['index'];
        message = JsonConverters.fromJson(json['message'],'ChoiceMessage',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'finish_reason': finish_reason,
        'index': index,
        'message': JsonConverters.toJson(message,'ChoiceMessage',context!)
    };

    getTypeName() => "Choice";
    TypeContext? context = _ctx;
}

/**
* Usage statistics for the completion request.
*/
// @DataContract
class AiCompletionUsage implements IConvertible
{
    /**
    * When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion.
    */
    // @DataMember(Name="accepted_prediction_tokens")
    int? accepted_prediction_tokens;

    /**
    * Audio input tokens generated by the model.
    */
    // @DataMember(Name="audio_tokens")
    int? audio_tokens;

    /**
    * Tokens generated by the model for reasoning.
    */
    // @DataMember(Name="reasoning_tokens")
    int? reasoning_tokens;

    /**
    * When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion.
    */
    // @DataMember(Name="rejected_prediction_tokens")
    int? rejected_prediction_tokens;

    AiCompletionUsage({this.accepted_prediction_tokens,this.audio_tokens,this.reasoning_tokens,this.rejected_prediction_tokens});
    AiCompletionUsage.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        accepted_prediction_tokens = json['acceptedPredictionTokens'];
        audio_tokens = json['audioTokens'];
        reasoning_tokens = json['reasoningTokens'];
        rejected_prediction_tokens = json['rejectedPredictionTokens'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'accepted_prediction_tokens': accepted_prediction_tokens,
        'audio_tokens': audio_tokens,
        'reasoning_tokens': reasoning_tokens,
        'rejected_prediction_tokens': rejected_prediction_tokens
    };

    getTypeName() => "AiCompletionUsage";
    TypeContext? context = _ctx;
}

/**
* Breakdown of tokens used in the prompt.
*/
// @DataContract
class AiPromptUsage implements IConvertible
{
    /**
    * When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion.
    */
    // @DataMember(Name="accepted_prediction_tokens")
    int? accepted_prediction_tokens;

    /**
    * Audio input tokens present in the prompt.
    */
    // @DataMember(Name="audio_tokens")
    int? audio_tokens;

    /**
    * Cached tokens present in the prompt.
    */
    // @DataMember(Name="cached_tokens")
    int? cached_tokens;

    AiPromptUsage({this.accepted_prediction_tokens,this.audio_tokens,this.cached_tokens});
    AiPromptUsage.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        accepted_prediction_tokens = json['acceptedPredictionTokens'];
        audio_tokens = json['audioTokens'];
        cached_tokens = json['cachedTokens'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'accepted_prediction_tokens': accepted_prediction_tokens,
        'audio_tokens': audio_tokens,
        'cached_tokens': cached_tokens
    };

    getTypeName() => "AiPromptUsage";
    TypeContext? context = _ctx;
}

/**
* Usage statistics for the completion request.
*/
// @DataContract
class AiUsage implements IConvertible
{
    /**
    * Number of tokens in the generated completion.
    */
    // @DataMember(Name="completion_tokens")
    int? completion_tokens;

    /**
    * Number of tokens in the prompt.
    */
    // @DataMember(Name="prompt_tokens")
    int? prompt_tokens;

    /**
    * Total number of tokens used in the request (prompt + completion).
    */
    // @DataMember(Name="total_tokens")
    int? total_tokens;

    /**
    * Breakdown of tokens used in a completion.
    */
    // @DataMember(Name="completion_tokens_details")
    AiCompletionUsage? completion_tokens_details;

    /**
    * Breakdown of tokens used in the prompt.
    */
    // @DataMember(Name="prompt_tokens_details")
    AiPromptUsage? prompt_tokens_details;

    AiUsage({this.completion_tokens,this.prompt_tokens,this.total_tokens,this.completion_tokens_details,this.prompt_tokens_details});
    AiUsage.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        completion_tokens = json['completionTokens'];
        prompt_tokens = json['promptTokens'];
        total_tokens = json['totalTokens'];
        completion_tokens_details = JsonConverters.fromJson(json['completionTokensDetails'],'AiCompletionUsage',context!);
        prompt_tokens_details = JsonConverters.fromJson(json['promptTokensDetails'],'AiPromptUsage',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'completion_tokens': completion_tokens,
        'prompt_tokens': prompt_tokens,
        'total_tokens': total_tokens,
        'completion_tokens_details': JsonConverters.toJson(completion_tokens_details,'AiCompletionUsage',context!),
        'prompt_tokens_details': JsonConverters.toJson(prompt_tokens_details,'AiPromptUsage',context!)
    };

    getTypeName() => "AiUsage";
    TypeContext? context = _ctx;
}

class ChatCompletionStat implements IConvertible
{
    String? name;
    int? requests;
    int? inputTokens;
    int? outputTokens;
    double? cost;

    ChatCompletionStat({this.name,this.requests,this.inputTokens,this.outputTokens,this.cost});
    ChatCompletionStat.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        requests = json['requests'];
        inputTokens = json['inputTokens'];
        outputTokens = json['outputTokens'];
        cost = JsonConverters.toDouble(json['cost']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'requests': requests,
        'inputTokens': inputTokens,
        'outputTokens': outputTokens,
        'cost': cost
    };

    getTypeName() => "ChatCompletionStat";
    TypeContext? context = _ctx;
}

class DiagnosticEntry implements IConvertible
{
    int? id;
    String? traceId;
    String? source;
    String? eventType;
    String? message;
    String? operation;
    int? threadId;
    ResponseStatus? error;
    String? commandType;
    String? command;
    String? userAuthId;
    String? sessionId;
    String? arg;
    List<String>? args;
    List<int>? argLengths;
    Map<String,dynamic?>? namedArgs;
    Duration? duration;
    int? timestamp;
    DateTime? date;
    String? tag;
    String? stackTrace;
    Map<String,String?>? meta = {};

    DiagnosticEntry({this.id,this.traceId,this.source,this.eventType,this.message,this.operation,this.threadId,this.error,this.commandType,this.command,this.userAuthId,this.sessionId,this.arg,this.args,this.argLengths,this.namedArgs,this.duration,this.timestamp,this.date,this.tag,this.stackTrace,this.meta});
    DiagnosticEntry.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        traceId = json['traceId'];
        source = json['source'];
        eventType = json['eventType'];
        message = json['message'];
        operation = json['operation'];
        threadId = json['threadId'];
        error = JsonConverters.fromJson(json['error'],'ResponseStatus',context!);
        commandType = json['commandType'];
        command = json['command'];
        userAuthId = json['userAuthId'];
        sessionId = json['sessionId'];
        arg = json['arg'];
        args = JsonConverters.fromJson(json['args'],'List<String>',context!);
        argLengths = JsonConverters.fromJson(json['argLengths'],'List<int>',context!);
        namedArgs = JsonConverters.fromJson(json['namedArgs'],'Map<String,dynamic?>',context!);
        duration = JsonConverters.fromJson(json['duration'],'Duration',context!);
        timestamp = json['timestamp'];
        date = JsonConverters.fromJson(json['date'],'DateTime',context!);
        tag = json['tag'];
        stackTrace = json['stackTrace'];
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'traceId': traceId,
        'source': source,
        'eventType': eventType,
        'message': message,
        'operation': operation,
        'threadId': threadId,
        'error': JsonConverters.toJson(error,'ResponseStatus',context!),
        'commandType': commandType,
        'command': command,
        'userAuthId': userAuthId,
        'sessionId': sessionId,
        'arg': arg,
        'args': JsonConverters.toJson(args,'List<String>',context!),
        'argLengths': JsonConverters.toJson(argLengths,'List<int>',context!),
        'namedArgs': JsonConverters.toJson(namedArgs,'Map<String,dynamic?>',context!),
        'duration': JsonConverters.toJson(duration,'Duration',context!),
        'timestamp': timestamp,
        'date': JsonConverters.toJson(date,'DateTime',context!),
        'tag': tag,
        'stackTrace': stackTrace,
        'meta': meta
    };

    getTypeName() => "DiagnosticEntry";
    TypeContext? context = _ctx;
}

class RedisSearchResult implements IConvertible
{
    String? id;
    String? type;
    int? ttl;
    int? size;

    RedisSearchResult({this.id,this.type,this.ttl,this.size});
    RedisSearchResult.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        type = json['type'];
        ttl = json['ttl'];
        size = json['size'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'type': type,
        'ttl': ttl,
        'size': size
    };

    getTypeName() => "RedisSearchResult";
    TypeContext? context = _ctx;
}

class RedisText implements IConvertible
{
    String? text;
    List<RedisText>? children;

    RedisText({this.text,this.children});
    RedisText.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        text = json['text'];
        children = JsonConverters.fromJson(json['children'],'List<RedisText>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'text': text,
        'children': JsonConverters.toJson(children,'List<RedisText>',context!)
    };

    getTypeName() => "RedisText";
    TypeContext? context = _ctx;
}

class CommandSummary implements IConvertible
{
    String? type;
    String? name;
    int? count;
    int? failed;
    int? retries;
    int? totalMs;
    int? minMs;
    int? maxMs;
    double? averageMs;
    double? medianMs;
    ResponseStatus? lastError;
    List<int>? timings;

    CommandSummary({this.type,this.name,this.count,this.failed,this.retries,this.totalMs,this.minMs,this.maxMs,this.averageMs,this.medianMs,this.lastError,this.timings});
    CommandSummary.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        type = json['type'];
        name = json['name'];
        count = json['count'];
        failed = json['failed'];
        retries = json['retries'];
        totalMs = json['totalMs'];
        minMs = json['minMs'];
        maxMs = json['maxMs'];
        averageMs = JsonConverters.toDouble(json['averageMs']);
        medianMs = JsonConverters.toDouble(json['medianMs']);
        lastError = JsonConverters.fromJson(json['lastError'],'ResponseStatus',context!);
        timings = JsonConverters.fromJson(json['timings'],'List<int>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'type': type,
        'name': name,
        'count': count,
        'failed': failed,
        'retries': retries,
        'totalMs': totalMs,
        'minMs': minMs,
        'maxMs': maxMs,
        'averageMs': averageMs,
        'medianMs': medianMs,
        'lastError': JsonConverters.toJson(lastError,'ResponseStatus',context!),
        'timings': JsonConverters.toJson(timings,'List<int>',context!)
    };

    getTypeName() => "CommandSummary";
    TypeContext? context = _ctx;
}

class CommandResult implements IConvertible
{
    String? type;
    String? name;
    int? ms;
    DateTime? at;
    String? request;
    int? retries;
    int? attempt;
    ResponseStatus? error;

    CommandResult({this.type,this.name,this.ms,this.at,this.request,this.retries,this.attempt,this.error});
    CommandResult.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        type = json['type'];
        name = json['name'];
        ms = json['ms'];
        at = JsonConverters.fromJson(json['at'],'DateTime',context!);
        request = json['request'];
        retries = json['retries'];
        attempt = json['attempt'];
        error = JsonConverters.fromJson(json['error'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'type': type,
        'name': name,
        'ms': ms,
        'at': JsonConverters.toJson(at,'DateTime',context!),
        'request': request,
        'retries': retries,
        'attempt': attempt,
        'error': JsonConverters.toJson(error,'ResponseStatus',context!)
    };

    getTypeName() => "CommandResult";
    TypeContext? context = _ctx;
}

class JobStatSummary implements IConvertible
{
    String? name;
    int? total;
    int? completed;
    int? retries;
    int? failed;
    int? cancelled;

    JobStatSummary({this.name,this.total,this.completed,this.retries,this.failed,this.cancelled});
    JobStatSummary.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        total = json['total'];
        completed = json['completed'];
        retries = json['retries'];
        failed = json['failed'];
        cancelled = json['cancelled'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'total': total,
        'completed': completed,
        'retries': retries,
        'failed': failed,
        'cancelled': cancelled
    };

    getTypeName() => "JobStatSummary";
    TypeContext? context = _ctx;
}

class HourSummary implements IConvertible
{
    String? hour;
    int? total;
    int? completed;
    int? failed;
    int? cancelled;

    HourSummary({this.hour,this.total,this.completed,this.failed,this.cancelled});
    HourSummary.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        hour = json['hour'];
        total = json['total'];
        completed = json['completed'];
        failed = json['failed'];
        cancelled = json['cancelled'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'hour': hour,
        'total': total,
        'completed': completed,
        'failed': failed,
        'cancelled': cancelled
    };

    getTypeName() => "HourSummary";
    TypeContext? context = _ctx;
}

class WorkerStats implements IConvertible
{
    String? name;
    int? queued;
    int? received;
    int? completed;
    int? retries;
    int? failed;
    int? runningJob;
    Duration? runningTime;

    WorkerStats({this.name,this.queued,this.received,this.completed,this.retries,this.failed,this.runningJob,this.runningTime});
    WorkerStats.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        queued = json['queued'];
        received = json['received'];
        completed = json['completed'];
        retries = json['retries'];
        failed = json['failed'];
        runningJob = json['runningJob'];
        runningTime = JsonConverters.fromJson(json['runningTime'],'Duration',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'queued': queued,
        'received': received,
        'completed': completed,
        'retries': retries,
        'failed': failed,
        'runningJob': runningJob,
        'runningTime': JsonConverters.toJson(runningTime,'Duration',context!)
    };

    getTypeName() => "WorkerStats";
    TypeContext? context = _ctx;
}

class RequestLogEntry implements IConvertible
{
    int? id;
    String? traceId;
    String? operationName;
    DateTime? dateTime;
    int? statusCode;
    String? statusDescription;
    String? httpMethod;
    String? absoluteUri;
    String? pathInfo;
    // @StringLength(2147483647)
    String? requestBody;

    dynamic? requestDto;
    String? userAuthId;
    String? sessionId;
    String? ipAddress;
    String? forwardedFor;
    String? referer;
    Map<String,String?>? headers;
    Map<String,String?>? formData;
    Map<String,String?>? items;
    Map<String,String?>? responseHeaders;
    dynamic? session;
    dynamic? responseDto;
    dynamic? errorResponse;
    String? exceptionSource;
    dynamic? exceptionData;
    Duration? requestDuration;
    Map<String,String?>? meta;

    RequestLogEntry({this.id,this.traceId,this.operationName,this.dateTime,this.statusCode,this.statusDescription,this.httpMethod,this.absoluteUri,this.pathInfo,this.requestBody,this.requestDto,this.userAuthId,this.sessionId,this.ipAddress,this.forwardedFor,this.referer,this.headers,this.formData,this.items,this.responseHeaders,this.session,this.responseDto,this.errorResponse,this.exceptionSource,this.exceptionData,this.requestDuration,this.meta});
    RequestLogEntry.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        traceId = json['traceId'];
        operationName = json['operationName'];
        dateTime = JsonConverters.fromJson(json['dateTime'],'DateTime',context!);
        statusCode = json['statusCode'];
        statusDescription = json['statusDescription'];
        httpMethod = json['httpMethod'];
        absoluteUri = json['absoluteUri'];
        pathInfo = json['pathInfo'];
        requestBody = json['requestBody'];
        requestDto = JsonConverters.fromJson(json['requestDto'],'dynamic',context!);
        userAuthId = json['userAuthId'];
        sessionId = json['sessionId'];
        ipAddress = json['ipAddress'];
        forwardedFor = json['forwardedFor'];
        referer = json['referer'];
        headers = JsonConverters.toStringMap(json['headers']);
        formData = JsonConverters.toStringMap(json['formData']);
        items = JsonConverters.toStringMap(json['items']);
        responseHeaders = JsonConverters.toStringMap(json['responseHeaders']);
        session = JsonConverters.fromJson(json['session'],'dynamic',context!);
        responseDto = JsonConverters.fromJson(json['responseDto'],'dynamic',context!);
        errorResponse = JsonConverters.fromJson(json['errorResponse'],'dynamic',context!);
        exceptionSource = json['exceptionSource'];
        exceptionData = JsonConverters.fromJson(json['exceptionData'],'dynamic',context!);
        requestDuration = JsonConverters.fromJson(json['requestDuration'],'Duration',context!);
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'traceId': traceId,
        'operationName': operationName,
        'dateTime': JsonConverters.toJson(dateTime,'DateTime',context!),
        'statusCode': statusCode,
        'statusDescription': statusDescription,
        'httpMethod': httpMethod,
        'absoluteUri': absoluteUri,
        'pathInfo': pathInfo,
        'requestBody': requestBody,
        'requestDto': JsonConverters.toJson(requestDto,'dynamic',context!),
        'userAuthId': userAuthId,
        'sessionId': sessionId,
        'ipAddress': ipAddress,
        'forwardedFor': forwardedFor,
        'referer': referer,
        'headers': headers,
        'formData': formData,
        'items': items,
        'responseHeaders': responseHeaders,
        'session': JsonConverters.toJson(session,'dynamic',context!),
        'responseDto': JsonConverters.toJson(responseDto,'dynamic',context!),
        'errorResponse': JsonConverters.toJson(errorResponse,'dynamic',context!),
        'exceptionSource': exceptionSource,
        'exceptionData': JsonConverters.toJson(exceptionData,'dynamic',context!),
        'requestDuration': JsonConverters.toJson(requestDuration,'Duration',context!),
        'meta': meta
    };

    getTypeName() => "RequestLogEntry";
    TypeContext? context = _ctx;
}

// @DataContract
class AnalyticsLogInfo implements IConvertible
{
    // @DataMember(Order=1)
    int? id;

    // @DataMember(Order=2)
    DateTime? dateTime;

    // @DataMember(Order=3)
    String? browser;

    // @DataMember(Order=4)
    String? device;

    // @DataMember(Order=5)
    String? bot;

    // @DataMember(Order=6)
    String? op;

    // @DataMember(Order=7)
    String? userId;

    // @DataMember(Order=8)
    String? userName;

    // @DataMember(Order=9)
    String? apiKey;

    // @DataMember(Order=10)
    String? ip;

    AnalyticsLogInfo({this.id,this.dateTime,this.browser,this.device,this.bot,this.op,this.userId,this.userName,this.apiKey,this.ip});
    AnalyticsLogInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        dateTime = JsonConverters.fromJson(json['dateTime'],'DateTime',context!);
        browser = json['browser'];
        device = json['device'];
        bot = json['bot'];
        op = json['op'];
        userId = json['userId'];
        userName = json['userName'];
        apiKey = json['apiKey'];
        ip = json['ip'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'dateTime': JsonConverters.toJson(dateTime,'DateTime',context!),
        'browser': browser,
        'device': device,
        'bot': bot,
        'op': op,
        'userId': userId,
        'userName': userName,
        'apiKey': apiKey,
        'ip': ip
    };

    getTypeName() => "AnalyticsLogInfo";
    TypeContext? context = _ctx;
}

// @DataContract
class RequestSummary implements IConvertible
{
    // @DataMember(Order=1)
    String? name;

    // @DataMember(Order=2)
    int? totalRequests;

    // @DataMember(Order=3)
    int? totalRequestLength;

    // @DataMember(Order=4)
    int? minRequestLength;

    // @DataMember(Order=5)
    int? maxRequestLength;

    // @DataMember(Order=6)
    double? totalDuration;

    // @DataMember(Order=7)
    double? minDuration;

    // @DataMember(Order=8)
    double? maxDuration;

    // @DataMember(Order=9)
    Map<int,int?>? status;

    // @DataMember(Order=10)
    Map<String,int?>? durations;

    // @DataMember(Order=11)
    Map<String,int?>? apis;

    // @DataMember(Order=12)
    Map<String,int?>? users;

    // @DataMember(Order=13)
    Map<String,int?>? ips;

    // @DataMember(Order=14)
    Map<String,int?>? apiKeys;

    RequestSummary({this.name,this.totalRequests,this.totalRequestLength,this.minRequestLength,this.maxRequestLength,this.totalDuration,this.minDuration,this.maxDuration,this.status,this.durations,this.apis,this.users,this.ips,this.apiKeys});
    RequestSummary.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        totalRequests = json['totalRequests'];
        totalRequestLength = json['totalRequestLength'];
        minRequestLength = json['minRequestLength'];
        maxRequestLength = json['maxRequestLength'];
        totalDuration = JsonConverters.toDouble(json['totalDuration']);
        minDuration = JsonConverters.toDouble(json['minDuration']);
        maxDuration = JsonConverters.toDouble(json['maxDuration']);
        status = JsonConverters.fromJson(json['status'],'Map<int,int?>',context!);
        durations = JsonConverters.fromJson(json['durations'],'Map<String,int?>',context!);
        apis = JsonConverters.fromJson(json['apis'],'Map<String,int?>',context!);
        users = JsonConverters.fromJson(json['users'],'Map<String,int?>',context!);
        ips = JsonConverters.fromJson(json['ips'],'Map<String,int?>',context!);
        apiKeys = JsonConverters.fromJson(json['apiKeys'],'Map<String,int?>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'totalRequests': totalRequests,
        'totalRequestLength': totalRequestLength,
        'minRequestLength': minRequestLength,
        'maxRequestLength': maxRequestLength,
        'totalDuration': totalDuration,
        'minDuration': minDuration,
        'maxDuration': maxDuration,
        'status': JsonConverters.toJson(status,'Map<int,int?>',context!),
        'durations': JsonConverters.toJson(durations,'Map<String,int?>',context!),
        'apis': JsonConverters.toJson(apis,'Map<String,int?>',context!),
        'users': JsonConverters.toJson(users,'Map<String,int?>',context!),
        'ips': JsonConverters.toJson(ips,'Map<String,int?>',context!),
        'apiKeys': JsonConverters.toJson(apiKeys,'Map<String,int?>',context!)
    };

    getTypeName() => "RequestSummary";
    TypeContext? context = _ctx;
}

// @DataContract
class AnalyticsReports implements IConvertible
{
    // @DataMember(Order=1)
    int? id;

    // @DataMember(Order=2)
    DateTime? created;

    // @DataMember(Order=3)
    double? version;

    // @DataMember(Order=4)
    Map<String,RequestSummary?>? apis;

    // @DataMember(Order=5)
    Map<String,RequestSummary?>? users;

    // @DataMember(Order=6)
    Map<String,RequestSummary?>? tags;

    // @DataMember(Order=7)
    Map<String,RequestSummary?>? status;

    // @DataMember(Order=8)
    Map<String,RequestSummary?>? days;

    // @DataMember(Order=9)
    Map<String,RequestSummary?>? apiKeys;

    // @DataMember(Order=10)
    Map<String,RequestSummary?>? ips;

    // @DataMember(Order=11)
    Map<String,RequestSummary?>? browsers;

    // @DataMember(Order=12)
    Map<String,RequestSummary?>? devices;

    // @DataMember(Order=13)
    Map<String,RequestSummary?>? bots;

    // @DataMember(Order=14)
    Map<String,int?>? durations;

    AnalyticsReports({this.id,this.created,this.version,this.apis,this.users,this.tags,this.status,this.days,this.apiKeys,this.ips,this.browsers,this.devices,this.bots,this.durations});
    AnalyticsReports.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        created = JsonConverters.fromJson(json['created'],'DateTime',context!);
        version = JsonConverters.toDouble(json['version']);
        apis = JsonConverters.fromJson(json['apis'],'Map<String,RequestSummary?>',context!);
        users = JsonConverters.fromJson(json['users'],'Map<String,RequestSummary?>',context!);
        tags = JsonConverters.fromJson(json['tags'],'Map<String,RequestSummary?>',context!);
        status = JsonConverters.fromJson(json['status'],'Map<String,RequestSummary?>',context!);
        days = JsonConverters.fromJson(json['days'],'Map<String,RequestSummary?>',context!);
        apiKeys = JsonConverters.fromJson(json['apiKeys'],'Map<String,RequestSummary?>',context!);
        ips = JsonConverters.fromJson(json['ips'],'Map<String,RequestSummary?>',context!);
        browsers = JsonConverters.fromJson(json['browsers'],'Map<String,RequestSummary?>',context!);
        devices = JsonConverters.fromJson(json['devices'],'Map<String,RequestSummary?>',context!);
        bots = JsonConverters.fromJson(json['bots'],'Map<String,RequestSummary?>',context!);
        durations = JsonConverters.fromJson(json['durations'],'Map<String,int?>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'created': JsonConverters.toJson(created,'DateTime',context!),
        'version': version,
        'apis': JsonConverters.toJson(apis,'Map<String,RequestSummary?>',context!),
        'users': JsonConverters.toJson(users,'Map<String,RequestSummary?>',context!),
        'tags': JsonConverters.toJson(tags,'Map<String,RequestSummary?>',context!),
        'status': JsonConverters.toJson(status,'Map<String,RequestSummary?>',context!),
        'days': JsonConverters.toJson(days,'Map<String,RequestSummary?>',context!),
        'apiKeys': JsonConverters.toJson(apiKeys,'Map<String,RequestSummary?>',context!),
        'ips': JsonConverters.toJson(ips,'Map<String,RequestSummary?>',context!),
        'browsers': JsonConverters.toJson(browsers,'Map<String,RequestSummary?>',context!),
        'devices': JsonConverters.toJson(devices,'Map<String,RequestSummary?>',context!),
        'bots': JsonConverters.toJson(bots,'Map<String,RequestSummary?>',context!),
        'durations': JsonConverters.toJson(durations,'Map<String,int?>',context!)
    };

    getTypeName() => "AnalyticsReports";
    TypeContext? context = _ctx;
}

/**
* Text content part
*/
// @DataContract
class AiTextContent extends AiContent implements IConvertible
{
    /**
    * The text content.
    */
    // @DataMember(Name="text")
    String? text;

    AiTextContent({this.text});
    AiTextContent.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        text = json['text'];
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'text': text
    });

    getTypeName() => "AiTextContent";
    TypeContext? context = _ctx;
}

// @DataContract
class AiImageUrl implements IConvertible
{
    /**
    * Either a URL of the image or the base64 encoded image data.
    */
    // @DataMember(Name="url")
    String? url;

    AiImageUrl({this.url});
    AiImageUrl.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        url = json['url'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'url': url
    };

    getTypeName() => "AiImageUrl";
    TypeContext? context = _ctx;
}

/**
* Image content part
*/
// @DataContract
class AiImageContent extends AiContent implements IConvertible
{
    /**
    * The image for this content.
    */
    // @DataMember(Name="image_url")
    AiImageUrl? image_url;

    AiImageContent({this.image_url});
    AiImageContent.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        image_url = JsonConverters.fromJson(json['imageUrl'],'AiImageUrl',context!);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'image_url': JsonConverters.toJson(image_url,'AiImageUrl',context!)
    });

    getTypeName() => "AiImageContent";
    TypeContext? context = _ctx;
}

/**
* Audio content part
*/
// @DataContract
class AiInputAudio implements IConvertible
{
    /**
    * URL or Base64 encoded audio data.
    */
    // @DataMember(Name="data")
    String? data;

    /**
    * The format of the encoded audio data. Currently supports 'wav' and 'mp3'.
    */
    // @DataMember(Name="format")
    String? format;

    AiInputAudio({this.data,this.format});
    AiInputAudio.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        data = json['data'];
        format = json['format'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'data': data,
        'format': format
    };

    getTypeName() => "AiInputAudio";
    TypeContext? context = _ctx;
}

/**
* Audio content part
*/
// @DataContract
class AiAudioContent extends AiContent implements IConvertible
{
    /**
    * The audio input for this content.
    */
    // @DataMember(Name="input_audio")
    AiInputAudio? input_audio;

    AiAudioContent({this.input_audio});
    AiAudioContent.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        input_audio = JsonConverters.fromJson(json['inputAudio'],'AiInputAudio',context!);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'input_audio': JsonConverters.toJson(input_audio,'AiInputAudio',context!)
    });

    getTypeName() => "AiAudioContent";
    TypeContext? context = _ctx;
}

/**
* File content part
*/
// @DataContract
class AiFile implements IConvertible
{
    /**
    * The URL or base64 encoded file data, used when passing the file to the model as a string.
    */
    // @DataMember(Name="file_data")
    String? file_data;

    /**
    * The name of the file, used when passing the file to the model as a string.
    */
    // @DataMember(Name="filename")
    String? filename;

    /**
    * The ID of an uploaded file to use as input.
    */
    // @DataMember(Name="file_id")
    String? file_id;

    AiFile({this.file_data,this.filename,this.file_id});
    AiFile.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        file_data = json['fileData'];
        filename = json['filename'];
        file_id = json['fileId'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'file_data': file_data,
        'filename': filename,
        'file_id': file_id
    };

    getTypeName() => "AiFile";
    TypeContext? context = _ctx;
}

/**
* File content part
*/
// @DataContract
class AiFileContent extends AiContent implements IConvertible
{
    /**
    * The file input for this content.
    */
    // @DataMember(Name="file")
    AiFile? file;

    AiFileContent({this.file});
    AiFileContent.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        file = JsonConverters.fromJson(json['file'],'AiFile',context!);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'file': JsonConverters.toJson(file,'AiFile',context!)
    });

    getTypeName() => "AiFileContent";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminGetRolesResponse implements IConvertible
{
    // @DataMember(Order=1)
    List<AdminRole>? results;

    // @DataMember(Order=2)
    ResponseStatus? responseStatus;

    AdminGetRolesResponse({this.results,this.responseStatus});
    AdminGetRolesResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        results = JsonConverters.fromJson(json['results'],'List<AdminRole>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'results': JsonConverters.toJson(results,'List<AdminRole>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminGetRolesResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminGetRoleResponse implements IConvertible
{
    // @DataMember(Order=1)
    AdminRole? result;

    // @DataMember(Order=2)
    List<Property>? claims;

    // @DataMember(Order=3)
    ResponseStatus? responseStatus;

    AdminGetRoleResponse({this.result,this.claims,this.responseStatus});
    AdminGetRoleResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        result = JsonConverters.fromJson(json['result'],'AdminRole',context!);
        claims = JsonConverters.fromJson(json['claims'],'List<Property>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'result': JsonConverters.toJson(result,'AdminRole',context!),
        'claims': JsonConverters.toJson(claims,'List<Property>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminGetRoleResponse";
    TypeContext? context = _ctx;
}

class AdminDashboardResponse implements IConvertible
{
    ServerStats? serverStats;
    ResponseStatus? responseStatus;

    AdminDashboardResponse({this.serverStats,this.responseStatus});
    AdminDashboardResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        serverStats = JsonConverters.fromJson(json['serverStats'],'ServerStats',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'serverStats': JsonConverters.toJson(serverStats,'ServerStats',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminDashboardResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminApiKeysResponse implements IConvertible
{
    // @DataMember(Order=1)
    List<PartialApiKey>? results;

    // @DataMember(Order=2)
    ResponseStatus? responseStatus;

    AdminApiKeysResponse({this.results,this.responseStatus});
    AdminApiKeysResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        results = JsonConverters.fromJson(json['results'],'List<PartialApiKey>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'results': JsonConverters.toJson(results,'List<PartialApiKey>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminApiKeysResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminApiKeyResponse implements IConvertible
{
    // @DataMember(Order=1)
    String? result;

    // @DataMember(Order=2)
    ResponseStatus? responseStatus;

    AdminApiKeyResponse({this.result,this.responseStatus});
    AdminApiKeyResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        result = json['result'];
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'result': result,
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminApiKeyResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class ChatResponse implements IConvertible
{
    /**
    * A unique identifier for the chat completion.
    */
    // @DataMember(Name="id")
    String? id;

    /**
    * A list of chat completion choices. Can be more than one if n is greater than 1.
    */
    // @DataMember(Name="choices")
    List<Choice>? choices = [];

    /**
    * The Unix timestamp (in seconds) of when the chat completion was created.
    */
    // @DataMember(Name="created")
    int? created;

    /**
    * The model used for the chat completion.
    */
    // @DataMember(Name="model")
    String? model;

    /**
    * This fingerprint represents the backend configuration that the model runs with.
    */
    // @DataMember(Name="system_fingerprint")
    String? system_fingerprint;

    /**
    * The object type, which is always chat.completion.
    */
    // @DataMember(Name="object")
    String? object;

    /**
    * Specifies the processing type used for serving the request.
    */
    // @DataMember(Name="service_tier")
    String? service_tier;

    /**
    * Usage statistics for the completion request.
    */
    // @DataMember(Name="usage")
    AiUsage? usage;

    /**
    * The provider used for the chat completion.
    */
    // @DataMember(Name="provider")
    String? provider;

    /**
    * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format.
    */
    // @DataMember(Name="metadata")
    Map<String,String?>? metadata;

    // @DataMember(Name="responseStatus")
    ResponseStatus? responseStatus;

    ChatResponse({this.id,this.choices,this.created,this.model,this.system_fingerprint,this.object,this.service_tier,this.usage,this.provider,this.metadata,this.responseStatus});
    ChatResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        choices = JsonConverters.fromJson(json['choices'],'List<Choice>',context!);
        created = json['created'];
        model = json['model'];
        system_fingerprint = json['systemFingerprint'];
        object = json['object'];
        service_tier = json['serviceTier'];
        usage = JsonConverters.fromJson(json['usage'],'AiUsage',context!);
        provider = json['provider'];
        metadata = JsonConverters.toStringMap(json['metadata']);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'choices': JsonConverters.toJson(choices,'List<Choice>',context!),
        'created': created,
        'model': model,
        'system_fingerprint': system_fingerprint,
        'object': object,
        'service_tier': service_tier,
        'usage': JsonConverters.toJson(usage,'AiUsage',context!),
        'provider': provider,
        'metadata': metadata,
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "ChatResponse";
    TypeContext? context = _ctx;
}

class AdminMonthlyChatCompletionAnalyticsResponse implements IConvertible
{
    String? month;
    List<String>? availableMonths = [];
    List<ChatCompletionStat>? modelStats = [];
    List<ChatCompletionStat>? providerStats = [];
    List<ChatCompletionStat>? dailyStats = [];

    AdminMonthlyChatCompletionAnalyticsResponse({this.month,this.availableMonths,this.modelStats,this.providerStats,this.dailyStats});
    AdminMonthlyChatCompletionAnalyticsResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        month = json['month'];
        availableMonths = JsonConverters.fromJson(json['availableMonths'],'List<String>',context!);
        modelStats = JsonConverters.fromJson(json['modelStats'],'List<ChatCompletionStat>',context!);
        providerStats = JsonConverters.fromJson(json['providerStats'],'List<ChatCompletionStat>',context!);
        dailyStats = JsonConverters.fromJson(json['dailyStats'],'List<ChatCompletionStat>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'month': month,
        'availableMonths': JsonConverters.toJson(availableMonths,'List<String>',context!),
        'modelStats': JsonConverters.toJson(modelStats,'List<ChatCompletionStat>',context!),
        'providerStats': JsonConverters.toJson(providerStats,'List<ChatCompletionStat>',context!),
        'dailyStats': JsonConverters.toJson(dailyStats,'List<ChatCompletionStat>',context!)
    };

    getTypeName() => "AdminMonthlyChatCompletionAnalyticsResponse";
    TypeContext? context = _ctx;
}

class AdminDailyChatCompletionAnalyticsResponse implements IConvertible
{
    List<ChatCompletionStat>? modelStats = [];
    List<ChatCompletionStat>? providerStats = [];

    AdminDailyChatCompletionAnalyticsResponse({this.modelStats,this.providerStats});
    AdminDailyChatCompletionAnalyticsResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        modelStats = JsonConverters.fromJson(json['modelStats'],'List<ChatCompletionStat>',context!);
        providerStats = JsonConverters.fromJson(json['providerStats'],'List<ChatCompletionStat>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'modelStats': JsonConverters.toJson(modelStats,'List<ChatCompletionStat>',context!),
        'providerStats': JsonConverters.toJson(providerStats,'List<ChatCompletionStat>',context!)
    };

    getTypeName() => "AdminDailyChatCompletionAnalyticsResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminUserResponse implements IConvertible
{
    // @DataMember(Order=1)
    String? id;

    // @DataMember(Order=2)
    Map<String,dynamic?>? result;

    // @DataMember(Order=3)
    List<Map<String,dynamic>>? details;

    // @DataMember(Order=4)
    List<Property>? claims;

    // @DataMember(Order=5)
    ResponseStatus? responseStatus;

    AdminUserResponse({this.id,this.result,this.details,this.claims,this.responseStatus});
    AdminUserResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        result = JsonConverters.fromJson(json['result'],'Map<String,dynamic?>',context!);
        details = JsonConverters.fromJson(json['details'],'List<Map<String,dynamic>>',context!);
        claims = JsonConverters.fromJson(json['claims'],'List<Property>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'result': JsonConverters.toJson(result,'Map<String,dynamic?>',context!),
        'details': JsonConverters.toJson(details,'List<Map<String,dynamic>>',context!),
        'claims': JsonConverters.toJson(claims,'List<Property>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminUserResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminUsersResponse implements IConvertible
{
    // @DataMember(Order=1)
    List<Map<String,dynamic>>? results;

    // @DataMember(Order=2)
    ResponseStatus? responseStatus;

    AdminUsersResponse({this.results,this.responseStatus});
    AdminUsersResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        results = JsonConverters.fromJson(json['results'],'List<Map<String,dynamic>>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'results': JsonConverters.toJson(results,'List<Map<String,dynamic>>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminUsersResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminDeleteUserResponse implements IConvertible
{
    // @DataMember(Order=1)
    String? id;

    // @DataMember(Order=2)
    ResponseStatus? responseStatus;

    AdminDeleteUserResponse({this.id,this.responseStatus});
    AdminDeleteUserResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminDeleteUserResponse";
    TypeContext? context = _ctx;
}

class AdminProfilingResponse implements IConvertible
{
    List<DiagnosticEntry>? results = [];
    int? total;
    ResponseStatus? responseStatus;

    AdminProfilingResponse({this.results,this.total,this.responseStatus});
    AdminProfilingResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        results = JsonConverters.fromJson(json['results'],'List<DiagnosticEntry>',context!);
        total = json['total'];
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'results': JsonConverters.toJson(results,'List<DiagnosticEntry>',context!),
        'total': total,
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminProfilingResponse";
    TypeContext? context = _ctx;
}

class AdminRedisResponse implements IConvertible
{
    int? db;
    List<RedisSearchResult>? searchResults;
    Map<String,String?>? info;
    RedisEndpointInfo? endpoint;
    RedisText? result;
    ResponseStatus? responseStatus;

    AdminRedisResponse({this.db,this.searchResults,this.info,this.endpoint,this.result,this.responseStatus});
    AdminRedisResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        db = json['db'];
        searchResults = JsonConverters.fromJson(json['searchResults'],'List<RedisSearchResult>',context!);
        info = JsonConverters.toStringMap(json['info']);
        endpoint = JsonConverters.fromJson(json['endpoint'],'RedisEndpointInfo',context!);
        result = JsonConverters.fromJson(json['result'],'RedisText',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'db': db,
        'searchResults': JsonConverters.toJson(searchResults,'List<RedisSearchResult>',context!),
        'info': info,
        'endpoint': JsonConverters.toJson(endpoint,'RedisEndpointInfo',context!),
        'result': JsonConverters.toJson(result,'RedisText',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminRedisResponse";
    TypeContext? context = _ctx;
}

class AdminDatabaseResponse implements IConvertible
{
    List<Map<String,dynamic>>? results = [];
    int? total;
    List<MetadataPropertyType>? columns;
    ResponseStatus? responseStatus;

    AdminDatabaseResponse({this.results,this.total,this.columns,this.responseStatus});
    AdminDatabaseResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        results = JsonConverters.fromJson(json['results'],'List<Map<String,dynamic>>',context!);
        total = json['total'];
        columns = JsonConverters.fromJson(json['columns'],'List<MetadataPropertyType>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'results': JsonConverters.toJson(results,'List<Map<String,dynamic>>',context!),
        'total': total,
        'columns': JsonConverters.toJson(columns,'List<MetadataPropertyType>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminDatabaseResponse";
    TypeContext? context = _ctx;
}

class ViewCommandsResponse implements IConvertible
{
    List<CommandSummary>? commandTotals = [];
    List<CommandResult>? latestCommands = [];
    List<CommandResult>? latestFailed = [];
    ResponseStatus? responseStatus;

    ViewCommandsResponse({this.commandTotals,this.latestCommands,this.latestFailed,this.responseStatus});
    ViewCommandsResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        commandTotals = JsonConverters.fromJson(json['commandTotals'],'List<CommandSummary>',context!);
        latestCommands = JsonConverters.fromJson(json['latestCommands'],'List<CommandResult>',context!);
        latestFailed = JsonConverters.fromJson(json['latestFailed'],'List<CommandResult>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'commandTotals': JsonConverters.toJson(commandTotals,'List<CommandSummary>',context!),
        'latestCommands': JsonConverters.toJson(latestCommands,'List<CommandResult>',context!),
        'latestFailed': JsonConverters.toJson(latestFailed,'List<CommandResult>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "ViewCommandsResponse";
    TypeContext? context = _ctx;
}

class ExecuteCommandResponse implements IConvertible
{
    CommandResult? commandResult;
    String? result;
    ResponseStatus? responseStatus;

    ExecuteCommandResponse({this.commandResult,this.result,this.responseStatus});
    ExecuteCommandResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        commandResult = JsonConverters.fromJson(json['commandResult'],'CommandResult',context!);
        result = json['result'];
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'commandResult': JsonConverters.toJson(commandResult,'CommandResult',context!),
        'result': result,
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "ExecuteCommandResponse";
    TypeContext? context = _ctx;
}

class AdminJobDashboardResponse implements IConvertible
{
    List<JobStatSummary>? commands = [];
    List<JobStatSummary>? apis = [];
    List<JobStatSummary>? workers = [];
    List<HourSummary>? today = [];
    ResponseStatus? responseStatus;

    AdminJobDashboardResponse({this.commands,this.apis,this.workers,this.today,this.responseStatus});
    AdminJobDashboardResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        commands = JsonConverters.fromJson(json['commands'],'List<JobStatSummary>',context!);
        apis = JsonConverters.fromJson(json['apis'],'List<JobStatSummary>',context!);
        workers = JsonConverters.fromJson(json['workers'],'List<JobStatSummary>',context!);
        today = JsonConverters.fromJson(json['today'],'List<HourSummary>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'commands': JsonConverters.toJson(commands,'List<JobStatSummary>',context!),
        'apis': JsonConverters.toJson(apis,'List<JobStatSummary>',context!),
        'workers': JsonConverters.toJson(workers,'List<JobStatSummary>',context!),
        'today': JsonConverters.toJson(today,'List<HourSummary>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminJobDashboardResponse";
    TypeContext? context = _ctx;
}

class AdminJobInfoResponse implements IConvertible
{
    List<DateTime>? monthDbs;
    Map<String,int?>? tableCounts;
    List<WorkerStats>? workerStats;
    Map<String,int?>? queueCounts;
    Map<String,int?>? workerCounts;
    Map<BackgroundJobState,int?>? stateCounts;
    ResponseStatus? responseStatus;

    AdminJobInfoResponse({this.monthDbs,this.tableCounts,this.workerStats,this.queueCounts,this.workerCounts,this.stateCounts,this.responseStatus});
    AdminJobInfoResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        monthDbs = JsonConverters.fromJson(json['monthDbs'],'List<DateTime>',context!);
        tableCounts = JsonConverters.fromJson(json['tableCounts'],'Map<String,int?>',context!);
        workerStats = JsonConverters.fromJson(json['workerStats'],'List<WorkerStats>',context!);
        queueCounts = JsonConverters.fromJson(json['queueCounts'],'Map<String,int?>',context!);
        workerCounts = JsonConverters.fromJson(json['workerCounts'],'Map<String,int?>',context!);
        stateCounts = JsonConverters.fromJson(json['stateCounts'],'Map<BackgroundJobState,int?>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'monthDbs': JsonConverters.toJson(monthDbs,'List<DateTime>',context!),
        'tableCounts': JsonConverters.toJson(tableCounts,'Map<String,int?>',context!),
        'workerStats': JsonConverters.toJson(workerStats,'List<WorkerStats>',context!),
        'queueCounts': JsonConverters.toJson(queueCounts,'Map<String,int?>',context!),
        'workerCounts': JsonConverters.toJson(workerCounts,'Map<String,int?>',context!),
        'stateCounts': JsonConverters.toJson(stateCounts,'Map<BackgroundJobState,int?>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminJobInfoResponse";
    TypeContext? context = _ctx;
}

class AdminGetJobResponse implements IConvertible
{
    JobSummary? result;
    BackgroundJob? queued;
    CompletedJob? completed;
    FailedJob? failed;
    ResponseStatus? responseStatus;

    AdminGetJobResponse({this.result,this.queued,this.completed,this.failed,this.responseStatus});
    AdminGetJobResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        result = JsonConverters.fromJson(json['result'],'JobSummary',context!);
        queued = JsonConverters.fromJson(json['queued'],'BackgroundJob',context!);
        completed = JsonConverters.fromJson(json['completed'],'CompletedJob',context!);
        failed = JsonConverters.fromJson(json['failed'],'FailedJob',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'result': JsonConverters.toJson(result,'JobSummary',context!),
        'queued': JsonConverters.toJson(queued,'BackgroundJob',context!),
        'completed': JsonConverters.toJson(completed,'CompletedJob',context!),
        'failed': JsonConverters.toJson(failed,'FailedJob',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminGetJobResponse";
    TypeContext? context = _ctx;
}

class AdminGetJobProgressResponse implements IConvertible
{
    BackgroundJobState? state;
    double? progress;
    String? status;
    String? logs;
    int? durationMs;
    ResponseStatus? error;
    ResponseStatus? responseStatus;

    AdminGetJobProgressResponse({this.state,this.progress,this.status,this.logs,this.durationMs,this.error,this.responseStatus});
    AdminGetJobProgressResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        state = JsonConverters.fromJson(json['state'],'BackgroundJobState',context!);
        progress = JsonConverters.toDouble(json['progress']);
        status = json['status'];
        logs = json['logs'];
        durationMs = json['durationMs'];
        error = JsonConverters.fromJson(json['error'],'ResponseStatus',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'state': JsonConverters.toJson(state,'BackgroundJobState',context!),
        'progress': progress,
        'status': status,
        'logs': logs,
        'durationMs': durationMs,
        'error': JsonConverters.toJson(error,'ResponseStatus',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminGetJobProgressResponse";
    TypeContext? context = _ctx;
}

class AdminRequeueFailedJobsJobsResponse implements IConvertible
{
    List<int>? results = [];
    Map<int,String?>? errors = {};
    ResponseStatus? responseStatus;

    AdminRequeueFailedJobsJobsResponse({this.results,this.errors,this.responseStatus});
    AdminRequeueFailedJobsJobsResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        results = JsonConverters.fromJson(json['results'],'List<int>',context!);
        errors = JsonConverters.fromJson(json['errors'],'Map<int,String?>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'results': JsonConverters.toJson(results,'List<int>',context!),
        'errors': JsonConverters.toJson(errors,'Map<int,String?>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminRequeueFailedJobsJobsResponse";
    TypeContext? context = _ctx;
}

class AdminCancelJobsResponse implements IConvertible
{
    List<int>? results = [];
    Map<int,String?>? errors = {};
    ResponseStatus? responseStatus;

    AdminCancelJobsResponse({this.results,this.errors,this.responseStatus});
    AdminCancelJobsResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        results = JsonConverters.fromJson(json['results'],'List<int>',context!);
        errors = JsonConverters.fromJson(json['errors'],'Map<int,String?>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'results': JsonConverters.toJson(results,'List<int>',context!),
        'errors': JsonConverters.toJson(errors,'Map<int,String?>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "AdminCancelJobsResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class RequestLogsResponse implements IConvertible
{
    // @DataMember(Order=1)
    List<RequestLogEntry>? results;

    // @DataMember(Order=2)
    Map<String,String?>? usage;

    // @DataMember(Order=3)
    int? total;

    // @DataMember(Order=4)
    ResponseStatus? responseStatus;

    RequestLogsResponse({this.results,this.usage,this.total,this.responseStatus});
    RequestLogsResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        results = JsonConverters.fromJson(json['results'],'List<RequestLogEntry>',context!);
        usage = JsonConverters.toStringMap(json['usage']);
        total = json['total'];
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'results': JsonConverters.toJson(results,'List<RequestLogEntry>',context!),
        'usage': usage,
        'total': total,
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "RequestLogsResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class GetAnalyticsInfoResponse implements IConvertible
{
    // @DataMember(Order=1)
    List<String>? months;

    // @DataMember(Order=2)
    AnalyticsLogInfo? result;

    // @DataMember(Order=3)
    ResponseStatus? responseStatus;

    GetAnalyticsInfoResponse({this.months,this.result,this.responseStatus});
    GetAnalyticsInfoResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        months = JsonConverters.fromJson(json['months'],'List<String>',context!);
        result = JsonConverters.fromJson(json['result'],'AnalyticsLogInfo',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'months': JsonConverters.toJson(months,'List<String>',context!),
        'result': JsonConverters.toJson(result,'AnalyticsLogInfo',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "GetAnalyticsInfoResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class GetAnalyticsReportsResponse implements IConvertible
{
    // @DataMember(Order=1)
    AnalyticsReports? result;

    // @DataMember(Order=2)
    ResponseStatus? responseStatus;

    GetAnalyticsReportsResponse({this.result,this.responseStatus});
    GetAnalyticsReportsResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        result = JsonConverters.fromJson(json['result'],'AnalyticsReports',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'result': JsonConverters.toJson(result,'AnalyticsReports',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "GetAnalyticsReportsResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class GetValidationRulesResponse implements IConvertible
{
    // @DataMember(Order=1)
    List<ValidationRule>? results;

    // @DataMember(Order=2)
    ResponseStatus? responseStatus;

    GetValidationRulesResponse({this.results,this.responseStatus});
    GetValidationRulesResponse.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        results = JsonConverters.fromJson(json['results'],'List<ValidationRule>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'results': JsonConverters.toJson(results,'List<ValidationRule>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    getTypeName() => "GetValidationRulesResponse";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminCreateRole implements IReturn<IdResponse>, IPost, IConvertible
{
    // @DataMember(Order=1)
    String? name;

    AdminCreateRole({this.name});
    AdminCreateRole.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name
    };

    createResponse() => IdResponse();
    getResponseTypeName() => "IdResponse";
    getTypeName() => "AdminCreateRole";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminGetRoles implements IReturn<AdminGetRolesResponse>, IGet, IConvertible
{
    AdminGetRoles();
    AdminGetRoles.fromJson(Map<String, dynamic> json) : super();
    fromMap(Map<String, dynamic> json) {
        return this;
    }

    Map<String, dynamic> toJson() => {};
    createResponse() => AdminGetRolesResponse();
    getResponseTypeName() => "AdminGetRolesResponse";
    getTypeName() => "AdminGetRoles";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminGetRole implements IReturn<AdminGetRoleResponse>, IGet, IConvertible
{
    // @DataMember(Order=1)
    String? id;

    AdminGetRole({this.id});
    AdminGetRole.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id
    };

    createResponse() => AdminGetRoleResponse();
    getResponseTypeName() => "AdminGetRoleResponse";
    getTypeName() => "AdminGetRole";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminUpdateRole implements IReturn<IdResponse>, IPost, IConvertible
{
    // @DataMember(Order=1)
    String? id;

    // @DataMember(Order=2)
    String? name;

    // @DataMember(Order=3)
    List<Property>? addClaims;

    // @DataMember(Order=4)
    List<Property>? removeClaims;

    // @DataMember(Order=5)
    ResponseStatus? responseStatus;

    AdminUpdateRole({this.id,this.name,this.addClaims,this.removeClaims,this.responseStatus});
    AdminUpdateRole.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        name = json['name'];
        addClaims = JsonConverters.fromJson(json['addClaims'],'List<Property>',context!);
        removeClaims = JsonConverters.fromJson(json['removeClaims'],'List<Property>',context!);
        responseStatus = JsonConverters.fromJson(json['responseStatus'],'ResponseStatus',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'addClaims': JsonConverters.toJson(addClaims,'List<Property>',context!),
        'removeClaims': JsonConverters.toJson(removeClaims,'List<Property>',context!),
        'responseStatus': JsonConverters.toJson(responseStatus,'ResponseStatus',context!)
    };

    createResponse() => IdResponse();
    getResponseTypeName() => "IdResponse";
    getTypeName() => "AdminUpdateRole";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminDeleteRole implements IReturnVoid, IDelete, IConvertible
{
    // @DataMember(Order=1)
    String? id;

    AdminDeleteRole({this.id});
    AdminDeleteRole.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id
    };

    createResponse() {}
    getTypeName() => "AdminDeleteRole";
    TypeContext? context = _ctx;
}

class AdminDashboard implements IReturn<AdminDashboardResponse>, IGet, IConvertible
{
    AdminDashboard();
    AdminDashboard.fromJson(Map<String, dynamic> json) : super();
    fromMap(Map<String, dynamic> json) {
        return this;
    }

    Map<String, dynamic> toJson() => {};
    createResponse() => AdminDashboardResponse();
    getResponseTypeName() => "AdminDashboardResponse";
    getTypeName() => "AdminDashboard";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminQueryApiKeys implements IReturn<AdminApiKeysResponse>, IGet, IConvertible
{
    // @DataMember(Order=1)
    int? id;

    // @DataMember(Order=2)
    String? apiKey;

    // @DataMember(Order=3)
    String? search;

    // @DataMember(Order=4)
    String? userId;

    // @DataMember(Order=5)
    String? userName;

    // @DataMember(Order=6)
    String? orderBy;

    // @DataMember(Order=7)
    int? skip;

    // @DataMember(Order=8)
    int? take;

    AdminQueryApiKeys({this.id,this.apiKey,this.search,this.userId,this.userName,this.orderBy,this.skip,this.take});
    AdminQueryApiKeys.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        apiKey = json['apiKey'];
        search = json['search'];
        userId = json['userId'];
        userName = json['userName'];
        orderBy = json['orderBy'];
        skip = json['skip'];
        take = json['take'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'apiKey': apiKey,
        'search': search,
        'userId': userId,
        'userName': userName,
        'orderBy': orderBy,
        'skip': skip,
        'take': take
    };

    createResponse() => AdminApiKeysResponse();
    getResponseTypeName() => "AdminApiKeysResponse";
    getTypeName() => "AdminQueryApiKeys";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminCreateApiKey implements IReturn<AdminApiKeyResponse>, IPost, IConvertible
{
    // @DataMember(Order=1)
    String? name;

    // @DataMember(Order=2)
    String? userId;

    // @DataMember(Order=3)
    String? userName;

    // @DataMember(Order=4)
    List<String>? scopes;

    // @DataMember(Order=5)
    List<String>? features;

    // @DataMember(Order=6)
    List<String>? restrictTo;

    // @DataMember(Order=7)
    DateTime? expiryDate;

    // @DataMember(Order=8)
    String? notes;

    // @DataMember(Order=9)
    int? refId;

    // @DataMember(Order=10)
    String? refIdStr;

    // @DataMember(Order=11)
    Map<String,String?>? meta;

    AdminCreateApiKey({this.name,this.userId,this.userName,this.scopes,this.features,this.restrictTo,this.expiryDate,this.notes,this.refId,this.refIdStr,this.meta});
    AdminCreateApiKey.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        name = json['name'];
        userId = json['userId'];
        userName = json['userName'];
        scopes = JsonConverters.fromJson(json['scopes'],'List<String>',context!);
        features = JsonConverters.fromJson(json['features'],'List<String>',context!);
        restrictTo = JsonConverters.fromJson(json['restrictTo'],'List<String>',context!);
        expiryDate = JsonConverters.fromJson(json['expiryDate'],'DateTime',context!);
        notes = json['notes'];
        refId = json['refId'];
        refIdStr = json['refIdStr'];
        meta = JsonConverters.toStringMap(json['meta']);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'name': name,
        'userId': userId,
        'userName': userName,
        'scopes': JsonConverters.toJson(scopes,'List<String>',context!),
        'features': JsonConverters.toJson(features,'List<String>',context!),
        'restrictTo': JsonConverters.toJson(restrictTo,'List<String>',context!),
        'expiryDate': JsonConverters.toJson(expiryDate,'DateTime',context!),
        'notes': notes,
        'refId': refId,
        'refIdStr': refIdStr,
        'meta': meta
    };

    createResponse() => AdminApiKeyResponse();
    getResponseTypeName() => "AdminApiKeyResponse";
    getTypeName() => "AdminCreateApiKey";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminUpdateApiKey implements IReturn<EmptyResponse>, IPatch, IConvertible
{
    // @DataMember(Order=1)
    // @Validate(Validator="GreaterThan(0)")
    int? id;

    // @DataMember(Order=2)
    String? name;

    // @DataMember(Order=3)
    String? userId;

    // @DataMember(Order=4)
    String? userName;

    // @DataMember(Order=5)
    List<String>? scopes;

    // @DataMember(Order=6)
    List<String>? features;

    // @DataMember(Order=7)
    List<String>? restrictTo;

    // @DataMember(Order=8)
    DateTime? expiryDate;

    // @DataMember(Order=9)
    DateTime? cancelledDate;

    // @DataMember(Order=10)
    String? notes;

    // @DataMember(Order=11)
    int? refId;

    // @DataMember(Order=12)
    String? refIdStr;

    // @DataMember(Order=13)
    Map<String,String?>? meta;

    // @DataMember(Order=14)
    List<String>? reset;

    AdminUpdateApiKey({this.id,this.name,this.userId,this.userName,this.scopes,this.features,this.restrictTo,this.expiryDate,this.cancelledDate,this.notes,this.refId,this.refIdStr,this.meta,this.reset});
    AdminUpdateApiKey.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        name = json['name'];
        userId = json['userId'];
        userName = json['userName'];
        scopes = JsonConverters.fromJson(json['scopes'],'List<String>',context!);
        features = JsonConverters.fromJson(json['features'],'List<String>',context!);
        restrictTo = JsonConverters.fromJson(json['restrictTo'],'List<String>',context!);
        expiryDate = JsonConverters.fromJson(json['expiryDate'],'DateTime',context!);
        cancelledDate = JsonConverters.fromJson(json['cancelledDate'],'DateTime',context!);
        notes = json['notes'];
        refId = json['refId'];
        refIdStr = json['refIdStr'];
        meta = JsonConverters.toStringMap(json['meta']);
        reset = JsonConverters.fromJson(json['reset'],'List<String>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'userId': userId,
        'userName': userName,
        'scopes': JsonConverters.toJson(scopes,'List<String>',context!),
        'features': JsonConverters.toJson(features,'List<String>',context!),
        'restrictTo': JsonConverters.toJson(restrictTo,'List<String>',context!),
        'expiryDate': JsonConverters.toJson(expiryDate,'DateTime',context!),
        'cancelledDate': JsonConverters.toJson(cancelledDate,'DateTime',context!),
        'notes': notes,
        'refId': refId,
        'refIdStr': refIdStr,
        'meta': meta,
        'reset': JsonConverters.toJson(reset,'List<String>',context!)
    };

    createResponse() => EmptyResponse();
    getResponseTypeName() => "EmptyResponse";
    getTypeName() => "AdminUpdateApiKey";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminDeleteApiKey implements IReturn<EmptyResponse>, IDelete, IConvertible
{
    // @DataMember(Order=1)
    // @Validate(Validator="GreaterThan(0)")
    int? id;

    AdminDeleteApiKey({this.id});
    AdminDeleteApiKey.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id
    };

    createResponse() => EmptyResponse();
    getResponseTypeName() => "EmptyResponse";
    getTypeName() => "AdminDeleteApiKey";
    TypeContext? context = _ctx;
}

/**
* Chat Completions API (OpenAI-Compatible)
*/
// @Route("/v1/chat/completions", "POST")
// @DataContract
class ChatCompletion implements IReturn<ChatResponse>, IPost, IConvertible
{
    /**
    * The messages to generate chat completions for.
    */
    // @DataMember(Name="messages")
    List<AiMessage>? messages = [];

    /**
    * ID of the model to use. See the model endpoint compatibility table for details on which models work with the Chat API
    */
    // @DataMember(Name="model")
    String? model;

    /**
    * Parameters for audio output. Required when audio output is requested with modalities: [audio]
    */
    // @DataMember(Name="audio")
    AiChatAudio? audio;

    /**
    * Modify the likelihood of specified tokens appearing in the completion.
    */
    // @DataMember(Name="logit_bias")
    Map<int,int?>? logit_bias;

    /**
    * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format.
    */
    // @DataMember(Name="metadata")
    Map<String,String?>? metadata;

    /**
    * Constrains effort on reasoning for reasoning models. Currently supported values are minimal, low, medium, and high (none, default). Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
    */
    // @DataMember(Name="reasoning_effort")
    String? reasoning_effort;

    /**
    * An object specifying the format that the model must output. Compatible with GPT-4 Turbo and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`. Setting Type to ResponseFormat.JsonObject enables JSON mode, which guarantees the message the model generates is valid JSON.
    */
    // @DataMember(Name="response_format")
    AiResponseFormat? response_format;

    /**
    * Specifies the processing type used for serving the request.
    */
    // @DataMember(Name="service_tier")
    String? service_tier;

    /**
    * A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies. The IDs should be a string that uniquely identifies each user.
    */
    // @DataMember(Name="safety_identifier")
    String? safety_identifier;

    /**
    * Up to 4 sequences where the API will stop generating further tokens.
    */
    // @DataMember(Name="stop")
    List<String>? stop;

    /**
    * Output types that you would like the model to generate. Most models are capable of generating text, which is the default:
    */
    // @DataMember(Name="modalities")
    List<String>? modalities;

    /**
    * Used by OpenAI to cache responses for similar requests to optimize your cache hit rates.
    */
    // @DataMember(Name="prompt_cache_key")
    String? prompt_cache_key;

    /**
    * A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.
    */
    // @DataMember(Name="tools")
    List<Tool>? tools;

    /**
    * Constrains the verbosity of the model's response. Lower values will result in more concise responses, while higher values will result in more verbose responses. Currently supported values are low, medium, and high.
    */
    // @DataMember(Name="verbosity")
    String? verbosity;

    /**
    * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
    */
    // @DataMember(Name="temperature")
    double? temperature;

    /**
    * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens.
    */
    // @DataMember(Name="max_completion_tokens")
    int? max_completion_tokens;

    /**
    * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
    */
    // @DataMember(Name="top_logprobs")
    int? top_logprobs;

    /**
    * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
    */
    // @DataMember(Name="top_p")
    double? top_p;

    /**
    * Number between `-2.0` and `2.0`. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
    */
    // @DataMember(Name="frequency_penalty")
    double? frequency_penalty;

    /**
    * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
    */
    // @DataMember(Name="presence_penalty")
    double? presence_penalty;

    /**
    * This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result. Determinism is not guaranteed, and you should refer to the system_fingerprint response parameter to monitor changes in the backend.
    */
    // @DataMember(Name="seed")
    int? seed;

    /**
    * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
    */
    // @DataMember(Name="n")
    int? n;

    /**
    * Whether or not to store the output of this chat completion request for use in our model distillation or evals products.
    */
    // @DataMember(Name="store")
    bool? store;

    /**
    * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
    */
    // @DataMember(Name="logprobs")
    bool? logprobs;

    /**
    * Whether to enable parallel function calling during tool use.
    */
    // @DataMember(Name="parallel_tool_calls")
    bool? parallel_tool_calls;

    /**
    * Whether to enable thinking mode for some Qwen models and providers.
    */
    // @DataMember(Name="enable_thinking")
    bool? enable_thinking;

    /**
    * If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a `data: [DONE]` message.
    */
    // @DataMember(Name="stream")
    bool? stream;

    ChatCompletion({this.messages,this.model,this.audio,this.logit_bias,this.metadata,this.reasoning_effort,this.response_format,this.service_tier,this.safety_identifier,this.stop,this.modalities,this.prompt_cache_key,this.tools,this.verbosity,this.temperature,this.max_completion_tokens,this.top_logprobs,this.top_p,this.frequency_penalty,this.presence_penalty,this.seed,this.n,this.store,this.logprobs,this.parallel_tool_calls,this.enable_thinking,this.stream});
    ChatCompletion.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        messages = JsonConverters.fromJson(json['messages'],'List<AiMessage>',context!);
        model = json['model'];
        audio = JsonConverters.fromJson(json['audio'],'AiChatAudio',context!);
        logit_bias = JsonConverters.fromJson(json['logitBias'],'Map<int,int?>',context!);
        metadata = JsonConverters.toStringMap(json['metadata']);
        reasoning_effort = json['reasoningEffort'];
        response_format = JsonConverters.fromJson(json['responseFormat'],'AiResponseFormat',context!);
        service_tier = json['serviceTier'];
        safety_identifier = json['safetyIdentifier'];
        stop = JsonConverters.fromJson(json['stop'],'List<String>',context!);
        modalities = JsonConverters.fromJson(json['modalities'],'List<String>',context!);
        prompt_cache_key = json['promptCacheKey'];
        tools = JsonConverters.fromJson(json['tools'],'List<Tool>',context!);
        verbosity = json['verbosity'];
        temperature = JsonConverters.toDouble(json['temperature']);
        max_completion_tokens = json['maxCompletionTokens'];
        top_logprobs = json['topLogprobs'];
        top_p = JsonConverters.toDouble(json['topP']);
        frequency_penalty = JsonConverters.toDouble(json['frequencyPenalty']);
        presence_penalty = JsonConverters.toDouble(json['presencePenalty']);
        seed = json['seed'];
        n = json['n'];
        store = json['store'];
        logprobs = json['logprobs'];
        parallel_tool_calls = json['parallelToolCalls'];
        enable_thinking = json['enableThinking'];
        stream = json['stream'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'messages': JsonConverters.toJson(messages,'List<AiMessage>',context!),
        'model': model,
        'audio': JsonConverters.toJson(audio,'AiChatAudio',context!),
        'logit_bias': JsonConverters.toJson(logit_bias,'Map<int,int?>',context!),
        'metadata': metadata,
        'reasoning_effort': reasoning_effort,
        'response_format': JsonConverters.toJson(response_format,'AiResponseFormat',context!),
        'service_tier': service_tier,
        'safety_identifier': safety_identifier,
        'stop': JsonConverters.toJson(stop,'List<String>',context!),
        'modalities': JsonConverters.toJson(modalities,'List<String>',context!),
        'prompt_cache_key': prompt_cache_key,
        'tools': JsonConverters.toJson(tools,'List<Tool>',context!),
        'verbosity': verbosity,
        'temperature': temperature,
        'max_completion_tokens': max_completion_tokens,
        'top_logprobs': top_logprobs,
        'top_p': top_p,
        'frequency_penalty': frequency_penalty,
        'presence_penalty': presence_penalty,
        'seed': seed,
        'n': n,
        'store': store,
        'logprobs': logprobs,
        'parallel_tool_calls': parallel_tool_calls,
        'enable_thinking': enable_thinking,
        'stream': stream
    };

    createResponse() => ChatResponse();
    getResponseTypeName() => "ChatResponse";
    getTypeName() => "ChatCompletion";
    TypeContext? context = _ctx;
}

class AdminQueryChatCompletionLogs extends QueryDb<ChatCompletionLog> implements IReturn<QueryResponse<ChatCompletionLog>>, IConvertible, IGet
{
    DateTime? month;

    AdminQueryChatCompletionLogs({this.month});
    AdminQueryChatCompletionLogs.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        month = JsonConverters.fromJson(json['month'],'DateTime',context!);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'month': JsonConverters.toJson(month,'DateTime',context!)
    });

    createResponse() => QueryResponse<ChatCompletionLog>();
    getResponseTypeName() => "QueryResponse<ChatCompletionLog>";
    getTypeName() => "AdminQueryChatCompletionLogs";
    TypeContext? context = _ctx;
}

class AdminMonthlyChatCompletionAnalytics implements IReturn<AdminMonthlyChatCompletionAnalyticsResponse>, IGet, IConvertible
{
    DateTime? month;

    AdminMonthlyChatCompletionAnalytics({this.month});
    AdminMonthlyChatCompletionAnalytics.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        month = JsonConverters.fromJson(json['month'],'DateTime',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'month': JsonConverters.toJson(month,'DateTime',context!)
    };

    createResponse() => AdminMonthlyChatCompletionAnalyticsResponse();
    getResponseTypeName() => "AdminMonthlyChatCompletionAnalyticsResponse";
    getTypeName() => "AdminMonthlyChatCompletionAnalytics";
    TypeContext? context = _ctx;
}

class AdminDailyChatCompletionAnalytics implements IReturn<AdminDailyChatCompletionAnalyticsResponse>, IGet, IConvertible
{
    DateTime? day;

    AdminDailyChatCompletionAnalytics({this.day});
    AdminDailyChatCompletionAnalytics.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        day = JsonConverters.fromJson(json['day'],'DateTime',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'day': JsonConverters.toJson(day,'DateTime',context!)
    };

    createResponse() => AdminDailyChatCompletionAnalyticsResponse();
    getResponseTypeName() => "AdminDailyChatCompletionAnalyticsResponse";
    getTypeName() => "AdminDailyChatCompletionAnalytics";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminGetUser implements IReturn<AdminUserResponse>, IGet, IConvertible
{
    // @DataMember(Order=10)
    String? id;

    AdminGetUser({this.id});
    AdminGetUser.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id
    };

    createResponse() => AdminUserResponse();
    getResponseTypeName() => "AdminUserResponse";
    getTypeName() => "AdminGetUser";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminQueryUsers implements IReturn<AdminUsersResponse>, IGet, IConvertible
{
    // @DataMember(Order=1)
    String? query;

    // @DataMember(Order=2)
    String? orderBy;

    // @DataMember(Order=3)
    int? skip;

    // @DataMember(Order=4)
    int? take;

    AdminQueryUsers({this.query,this.orderBy,this.skip,this.take});
    AdminQueryUsers.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        query = json['query'];
        orderBy = json['orderBy'];
        skip = json['skip'];
        take = json['take'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'query': query,
        'orderBy': orderBy,
        'skip': skip,
        'take': take
    };

    createResponse() => AdminUsersResponse();
    getResponseTypeName() => "AdminUsersResponse";
    getTypeName() => "AdminQueryUsers";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminCreateUser extends AdminUserBase implements IReturn<AdminUserResponse>, IPost, IConvertible
{
    // @DataMember(Order=10)
    List<String>? roles;

    // @DataMember(Order=11)
    List<String>? permissions;

    AdminCreateUser({this.roles,this.permissions});
    AdminCreateUser.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        roles = JsonConverters.fromJson(json['roles'],'List<String>',context!);
        permissions = JsonConverters.fromJson(json['permissions'],'List<String>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'roles': JsonConverters.toJson(roles,'List<String>',context!),
        'permissions': JsonConverters.toJson(permissions,'List<String>',context!)
    });

    createResponse() => AdminUserResponse();
    getResponseTypeName() => "AdminUserResponse";
    getTypeName() => "AdminCreateUser";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminUpdateUser extends AdminUserBase implements IReturn<AdminUserResponse>, IPut, IConvertible
{
    // @DataMember(Order=10)
    String? id;

    // @DataMember(Order=11)
    bool? lockUser;

    // @DataMember(Order=12)
    bool? unlockUser;

    // @DataMember(Order=13)
    DateTime? lockUserUntil;

    // @DataMember(Order=14)
    List<String>? addRoles;

    // @DataMember(Order=15)
    List<String>? removeRoles;

    // @DataMember(Order=16)
    List<String>? addPermissions;

    // @DataMember(Order=17)
    List<String>? removePermissions;

    // @DataMember(Order=18)
    List<Property>? addClaims;

    // @DataMember(Order=19)
    List<Property>? removeClaims;

    AdminUpdateUser({this.id,this.lockUser,this.unlockUser,this.lockUserUntil,this.addRoles,this.removeRoles,this.addPermissions,this.removePermissions,this.addClaims,this.removeClaims});
    AdminUpdateUser.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        id = json['id'];
        lockUser = json['lockUser'];
        unlockUser = json['unlockUser'];
        lockUserUntil = JsonConverters.fromJson(json['lockUserUntil'],'DateTime',context!);
        addRoles = JsonConverters.fromJson(json['addRoles'],'List<String>',context!);
        removeRoles = JsonConverters.fromJson(json['removeRoles'],'List<String>',context!);
        addPermissions = JsonConverters.fromJson(json['addPermissions'],'List<String>',context!);
        removePermissions = JsonConverters.fromJson(json['removePermissions'],'List<String>',context!);
        addClaims = JsonConverters.fromJson(json['addClaims'],'List<Property>',context!);
        removeClaims = JsonConverters.fromJson(json['removeClaims'],'List<Property>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'id': id,
        'lockUser': lockUser,
        'unlockUser': unlockUser,
        'lockUserUntil': JsonConverters.toJson(lockUserUntil,'DateTime',context!),
        'addRoles': JsonConverters.toJson(addRoles,'List<String>',context!),
        'removeRoles': JsonConverters.toJson(removeRoles,'List<String>',context!),
        'addPermissions': JsonConverters.toJson(addPermissions,'List<String>',context!),
        'removePermissions': JsonConverters.toJson(removePermissions,'List<String>',context!),
        'addClaims': JsonConverters.toJson(addClaims,'List<Property>',context!),
        'removeClaims': JsonConverters.toJson(removeClaims,'List<Property>',context!)
    });

    createResponse() => AdminUserResponse();
    getResponseTypeName() => "AdminUserResponse";
    getTypeName() => "AdminUpdateUser";
    TypeContext? context = _ctx;
}

// @DataContract
class AdminDeleteUser implements IReturn<AdminDeleteUserResponse>, IDelete, IConvertible
{
    // @DataMember(Order=10)
    String? id;

    AdminDeleteUser({this.id});
    AdminDeleteUser.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id
    };

    createResponse() => AdminDeleteUserResponse();
    getResponseTypeName() => "AdminDeleteUserResponse";
    getTypeName() => "AdminDeleteUser";
    TypeContext? context = _ctx;
}

class AdminQueryRequestLogs extends QueryDb<RequestLog> implements IReturn<QueryResponse<RequestLog>>, IConvertible, IGet
{
    DateTime? month;

    AdminQueryRequestLogs({this.month});
    AdminQueryRequestLogs.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        month = JsonConverters.fromJson(json['month'],'DateTime',context!);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'month': JsonConverters.toJson(month,'DateTime',context!)
    });

    createResponse() => QueryResponse<RequestLog>();
    getResponseTypeName() => "QueryResponse<RequestLog>";
    getTypeName() => "AdminQueryRequestLogs";
    TypeContext? context = _ctx;
}

class AdminProfiling implements IReturn<AdminProfilingResponse>, IConvertible, IPost
{
    String? source;
    String? eventType;
    int? threadId;
    String? traceId;
    String? userAuthId;
    String? sessionId;
    String? tag;
    int? skip;
    int? take;
    String? orderBy;
    bool? withErrors;
    bool? pending;

    AdminProfiling({this.source,this.eventType,this.threadId,this.traceId,this.userAuthId,this.sessionId,this.tag,this.skip,this.take,this.orderBy,this.withErrors,this.pending});
    AdminProfiling.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        source = json['source'];
        eventType = json['eventType'];
        threadId = json['threadId'];
        traceId = json['traceId'];
        userAuthId = json['userAuthId'];
        sessionId = json['sessionId'];
        tag = json['tag'];
        skip = json['skip'];
        take = json['take'];
        orderBy = json['orderBy'];
        withErrors = json['withErrors'];
        pending = json['pending'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'source': source,
        'eventType': eventType,
        'threadId': threadId,
        'traceId': traceId,
        'userAuthId': userAuthId,
        'sessionId': sessionId,
        'tag': tag,
        'skip': skip,
        'take': take,
        'orderBy': orderBy,
        'withErrors': withErrors,
        'pending': pending
    };

    createResponse() => AdminProfilingResponse();
    getResponseTypeName() => "AdminProfilingResponse";
    getTypeName() => "AdminProfiling";
    TypeContext? context = _ctx;
}

class AdminRedis implements IReturn<AdminRedisResponse>, IPost, IConvertible
{
    int? db;
    String? query;
    RedisEndpointInfo? reconnect;
    int? take;
    int? position;
    List<String>? args;

    AdminRedis({this.db,this.query,this.reconnect,this.take,this.position,this.args});
    AdminRedis.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        db = json['db'];
        query = json['query'];
        reconnect = JsonConverters.fromJson(json['reconnect'],'RedisEndpointInfo',context!);
        take = json['take'];
        position = json['position'];
        args = JsonConverters.fromJson(json['args'],'List<String>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'db': db,
        'query': query,
        'reconnect': JsonConverters.toJson(reconnect,'RedisEndpointInfo',context!),
        'take': take,
        'position': position,
        'args': JsonConverters.toJson(args,'List<String>',context!)
    };

    createResponse() => AdminRedisResponse();
    getResponseTypeName() => "AdminRedisResponse";
    getTypeName() => "AdminRedis";
    TypeContext? context = _ctx;
}

class AdminDatabase implements IReturn<AdminDatabaseResponse>, IGet, IConvertible
{
    String? db;
    String? schema;
    String? table;
    List<String>? fields;
    int? take;
    int? skip;
    String? orderBy;
    String? include;

    AdminDatabase({this.db,this.schema,this.table,this.fields,this.take,this.skip,this.orderBy,this.include});
    AdminDatabase.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        db = json['db'];
        schema = json['schema'];
        table = json['table'];
        fields = JsonConverters.fromJson(json['fields'],'List<String>',context!);
        take = json['take'];
        skip = json['skip'];
        orderBy = json['orderBy'];
        include = json['include'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'db': db,
        'schema': schema,
        'table': table,
        'fields': JsonConverters.toJson(fields,'List<String>',context!),
        'take': take,
        'skip': skip,
        'orderBy': orderBy,
        'include': include
    };

    createResponse() => AdminDatabaseResponse();
    getResponseTypeName() => "AdminDatabaseResponse";
    getTypeName() => "AdminDatabase";
    TypeContext? context = _ctx;
}

class ViewCommands implements IReturn<ViewCommandsResponse>, IGet, IConvertible
{
    List<String>? include;
    int? skip;
    int? take;

    ViewCommands({this.include,this.skip,this.take});
    ViewCommands.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        include = JsonConverters.fromJson(json['include'],'List<String>',context!);
        skip = json['skip'];
        take = json['take'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'include': JsonConverters.toJson(include,'List<String>',context!),
        'skip': skip,
        'take': take
    };

    createResponse() => ViewCommandsResponse();
    getResponseTypeName() => "ViewCommandsResponse";
    getTypeName() => "ViewCommands";
    TypeContext? context = _ctx;
}

class ExecuteCommand implements IReturn<ExecuteCommandResponse>, IPost, IConvertible
{
    String? command;
    String? requestJson;

    ExecuteCommand({this.command,this.requestJson});
    ExecuteCommand.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        command = json['command'];
        requestJson = json['requestJson'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'command': command,
        'requestJson': requestJson
    };

    createResponse() => ExecuteCommandResponse();
    getResponseTypeName() => "ExecuteCommandResponse";
    getTypeName() => "ExecuteCommand";
    TypeContext? context = _ctx;
}

class AdminJobDashboard implements IReturn<AdminJobDashboardResponse>, IGet, IConvertible
{
    DateTime? from;
    DateTime? to;

    AdminJobDashboard({this.from,this.to});
    AdminJobDashboard.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        from = JsonConverters.fromJson(json['from'],'DateTime',context!);
        to = JsonConverters.fromJson(json['to'],'DateTime',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'from': JsonConverters.toJson(from,'DateTime',context!),
        'to': JsonConverters.toJson(to,'DateTime',context!)
    };

    createResponse() => AdminJobDashboardResponse();
    getResponseTypeName() => "AdminJobDashboardResponse";
    getTypeName() => "AdminJobDashboard";
    TypeContext? context = _ctx;
}

class AdminJobInfo implements IReturn<AdminJobInfoResponse>, IGet, IConvertible
{
    DateTime? month;

    AdminJobInfo({this.month});
    AdminJobInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        month = JsonConverters.fromJson(json['month'],'DateTime',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'month': JsonConverters.toJson(month,'DateTime',context!)
    };

    createResponse() => AdminJobInfoResponse();
    getResponseTypeName() => "AdminJobInfoResponse";
    getTypeName() => "AdminJobInfo";
    TypeContext? context = _ctx;
}

class AdminGetJob implements IReturn<AdminGetJobResponse>, IGet, IConvertible
{
    int? id;
    String? refId;

    AdminGetJob({this.id,this.refId});
    AdminGetJob.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        refId = json['refId'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'refId': refId
    };

    createResponse() => AdminGetJobResponse();
    getResponseTypeName() => "AdminGetJobResponse";
    getTypeName() => "AdminGetJob";
    TypeContext? context = _ctx;
}

class AdminGetJobProgress implements IReturn<AdminGetJobProgressResponse>, IGet, IConvertible
{
    // @Validate(Validator="GreaterThan(0)")
    int? id;

    int? logStart;

    AdminGetJobProgress({this.id,this.logStart});
    AdminGetJobProgress.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        id = json['id'];
        logStart = json['logStart'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'id': id,
        'logStart': logStart
    };

    createResponse() => AdminGetJobProgressResponse();
    getResponseTypeName() => "AdminGetJobProgressResponse";
    getTypeName() => "AdminGetJobProgress";
    TypeContext? context = _ctx;
}

class AdminQueryBackgroundJobs extends QueryDb<BackgroundJob> implements IReturn<QueryResponse<BackgroundJob>>, IConvertible, IGet
{
    int? id;
    String? refId;

    AdminQueryBackgroundJobs({this.id,this.refId});
    AdminQueryBackgroundJobs.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        id = json['id'];
        refId = json['refId'];
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'id': id,
        'refId': refId
    });

    createResponse() => QueryResponse<BackgroundJob>();
    getResponseTypeName() => "QueryResponse<BackgroundJob>";
    getTypeName() => "AdminQueryBackgroundJobs";
    TypeContext? context = _ctx;
}

class AdminQueryJobSummary extends QueryDb<JobSummary> implements IReturn<QueryResponse<JobSummary>>, IConvertible, IGet
{
    int? id;
    String? refId;

    AdminQueryJobSummary({this.id,this.refId});
    AdminQueryJobSummary.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        id = json['id'];
        refId = json['refId'];
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'id': id,
        'refId': refId
    });

    createResponse() => QueryResponse<JobSummary>();
    getResponseTypeName() => "QueryResponse<JobSummary>";
    getTypeName() => "AdminQueryJobSummary";
    TypeContext? context = _ctx;
}

class AdminQueryScheduledTasks extends QueryDb<ScheduledTask> implements IReturn<QueryResponse<ScheduledTask>>, IConvertible, IGet
{
    AdminQueryScheduledTasks();
    AdminQueryScheduledTasks.fromJson(Map<String, dynamic> json) : super.fromJson(json);
    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson();
    createResponse() => QueryResponse<ScheduledTask>();
    getResponseTypeName() => "QueryResponse<ScheduledTask>";
    getTypeName() => "AdminQueryScheduledTasks";
    TypeContext? context = _ctx;
}

class AdminQueryCompletedJobs extends QueryDb<CompletedJob> implements IReturn<QueryResponse<CompletedJob>>, IConvertible, IGet
{
    DateTime? month;

    AdminQueryCompletedJobs({this.month});
    AdminQueryCompletedJobs.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        month = JsonConverters.fromJson(json['month'],'DateTime',context!);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'month': JsonConverters.toJson(month,'DateTime',context!)
    });

    createResponse() => QueryResponse<CompletedJob>();
    getResponseTypeName() => "QueryResponse<CompletedJob>";
    getTypeName() => "AdminQueryCompletedJobs";
    TypeContext? context = _ctx;
}

class AdminQueryFailedJobs extends QueryDb<FailedJob> implements IReturn<QueryResponse<FailedJob>>, IConvertible, IGet
{
    DateTime? month;

    AdminQueryFailedJobs({this.month});
    AdminQueryFailedJobs.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        super.fromMap(json);
        month = JsonConverters.fromJson(json['month'],'DateTime',context!);
        return this;
    }

    Map<String, dynamic> toJson() => super.toJson()..addAll({
        'month': JsonConverters.toJson(month,'DateTime',context!)
    });

    createResponse() => QueryResponse<FailedJob>();
    getResponseTypeName() => "QueryResponse<FailedJob>";
    getTypeName() => "AdminQueryFailedJobs";
    TypeContext? context = _ctx;
}

class AdminRequeueFailedJobs implements IReturn<AdminRequeueFailedJobsJobsResponse>, IConvertible, IPost
{
    List<int>? ids;

    AdminRequeueFailedJobs({this.ids});
    AdminRequeueFailedJobs.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        ids = JsonConverters.fromJson(json['ids'],'List<int>',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'ids': JsonConverters.toJson(ids,'List<int>',context!)
    };

    createResponse() => AdminRequeueFailedJobsJobsResponse();
    getResponseTypeName() => "AdminRequeueFailedJobsJobsResponse";
    getTypeName() => "AdminRequeueFailedJobs";
    TypeContext? context = _ctx;
}

class AdminCancelJobs implements IReturn<AdminCancelJobsResponse>, IGet, IConvertible
{
    List<int>? ids;
    String? worker;
    BackgroundJobState? state;
    String? cancelWorker;

    AdminCancelJobs({this.ids,this.worker,this.state,this.cancelWorker});
    AdminCancelJobs.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        ids = JsonConverters.fromJson(json['ids'],'List<int>',context!);
        worker = json['worker'];
        state = JsonConverters.fromJson(json['state'],'BackgroundJobState',context!);
        cancelWorker = json['cancelWorker'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'ids': JsonConverters.toJson(ids,'List<int>',context!),
        'worker': worker,
        'state': JsonConverters.toJson(state,'BackgroundJobState',context!),
        'cancelWorker': cancelWorker
    };

    createResponse() => AdminCancelJobsResponse();
    getResponseTypeName() => "AdminCancelJobsResponse";
    getTypeName() => "AdminCancelJobs";
    TypeContext? context = _ctx;
}

// @Route("/requestlogs")
// @DataContract
class RequestLogs implements IReturn<RequestLogsResponse>, IGet, IConvertible
{
    // @DataMember(Order=1)
    int? beforeSecs;

    // @DataMember(Order=2)
    int? afterSecs;

    // @DataMember(Order=3)
    String? operationName;

    // @DataMember(Order=4)
    String? ipAddress;

    // @DataMember(Order=5)
    String? forwardedFor;

    // @DataMember(Order=6)
    String? userAuthId;

    // @DataMember(Order=7)
    String? sessionId;

    // @DataMember(Order=8)
    String? referer;

    // @DataMember(Order=9)
    String? pathInfo;

    // @DataMember(Order=10)
    String? bearerToken;

    // @DataMember(Order=11)
    List<int>? ids;

    // @DataMember(Order=12)
    int? beforeId;

    // @DataMember(Order=13)
    int? afterId;

    // @DataMember(Order=14)
    bool? hasResponse;

    // @DataMember(Order=15)
    bool? withErrors;

    // @DataMember(Order=16)
    bool? enableSessionTracking;

    // @DataMember(Order=17)
    bool? enableResponseTracking;

    // @DataMember(Order=18)
    bool? enableErrorTracking;

    // @DataMember(Order=19)
    Duration? durationLongerThan;

    // @DataMember(Order=20)
    Duration? durationLessThan;

    // @DataMember(Order=21)
    int? skip;

    // @DataMember(Order=22)
    int? take;

    // @DataMember(Order=23)
    String? orderBy;

    // @DataMember(Order=24)
    DateTime? month;

    RequestLogs({this.beforeSecs,this.afterSecs,this.operationName,this.ipAddress,this.forwardedFor,this.userAuthId,this.sessionId,this.referer,this.pathInfo,this.bearerToken,this.ids,this.beforeId,this.afterId,this.hasResponse,this.withErrors,this.enableSessionTracking,this.enableResponseTracking,this.enableErrorTracking,this.durationLongerThan,this.durationLessThan,this.skip,this.take,this.orderBy,this.month});
    RequestLogs.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        beforeSecs = json['beforeSecs'];
        afterSecs = json['afterSecs'];
        operationName = json['operationName'];
        ipAddress = json['ipAddress'];
        forwardedFor = json['forwardedFor'];
        userAuthId = json['userAuthId'];
        sessionId = json['sessionId'];
        referer = json['referer'];
        pathInfo = json['pathInfo'];
        bearerToken = json['bearerToken'];
        ids = JsonConverters.fromJson(json['ids'],'List<int>',context!);
        beforeId = json['beforeId'];
        afterId = json['afterId'];
        hasResponse = json['hasResponse'];
        withErrors = json['withErrors'];
        enableSessionTracking = json['enableSessionTracking'];
        enableResponseTracking = json['enableResponseTracking'];
        enableErrorTracking = json['enableErrorTracking'];
        durationLongerThan = JsonConverters.fromJson(json['durationLongerThan'],'Duration',context!);
        durationLessThan = JsonConverters.fromJson(json['durationLessThan'],'Duration',context!);
        skip = json['skip'];
        take = json['take'];
        orderBy = json['orderBy'];
        month = JsonConverters.fromJson(json['month'],'DateTime',context!);
        return this;
    }

    Map<String, dynamic> toJson() => {
        'beforeSecs': beforeSecs,
        'afterSecs': afterSecs,
        'operationName': operationName,
        'ipAddress': ipAddress,
        'forwardedFor': forwardedFor,
        'userAuthId': userAuthId,
        'sessionId': sessionId,
        'referer': referer,
        'pathInfo': pathInfo,
        'bearerToken': bearerToken,
        'ids': JsonConverters.toJson(ids,'List<int>',context!),
        'beforeId': beforeId,
        'afterId': afterId,
        'hasResponse': hasResponse,
        'withErrors': withErrors,
        'enableSessionTracking': enableSessionTracking,
        'enableResponseTracking': enableResponseTracking,
        'enableErrorTracking': enableErrorTracking,
        'durationLongerThan': JsonConverters.toJson(durationLongerThan,'Duration',context!),
        'durationLessThan': JsonConverters.toJson(durationLessThan,'Duration',context!),
        'skip': skip,
        'take': take,
        'orderBy': orderBy,
        'month': JsonConverters.toJson(month,'DateTime',context!)
    };

    createResponse() => RequestLogsResponse();
    getResponseTypeName() => "RequestLogsResponse";
    getTypeName() => "RequestLogs";
    TypeContext? context = _ctx;
}

// @DataContract
class GetAnalyticsInfo implements IReturn<GetAnalyticsInfoResponse>, IGet, IConvertible
{
    // @DataMember(Order=1)
    DateTime? month;

    // @DataMember(Order=2)
    String? type;

    // @DataMember(Order=3)
    String? op;

    // @DataMember(Order=4)
    String? apiKey;

    // @DataMember(Order=5)
    String? userId;

    // @DataMember(Order=6)
    String? ip;

    GetAnalyticsInfo({this.month,this.type,this.op,this.apiKey,this.userId,this.ip});
    GetAnalyticsInfo.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        month = JsonConverters.fromJson(json['month'],'DateTime',context!);
        type = json['type'];
        op = json['op'];
        apiKey = json['apiKey'];
        userId = json['userId'];
        ip = json['ip'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'month': JsonConverters.toJson(month,'DateTime',context!),
        'type': type,
        'op': op,
        'apiKey': apiKey,
        'userId': userId,
        'ip': ip
    };

    createResponse() => GetAnalyticsInfoResponse();
    getResponseTypeName() => "GetAnalyticsInfoResponse";
    getTypeName() => "GetAnalyticsInfo";
    TypeContext? context = _ctx;
}

// @DataContract
class GetAnalyticsReports implements IReturn<GetAnalyticsReportsResponse>, IGet, IConvertible
{
    // @DataMember(Order=1)
    DateTime? month;

    // @DataMember(Order=2)
    String? filter;

    // @DataMember(Order=3)
    String? value;

    // @DataMember(Order=4)
    bool? force;

    GetAnalyticsReports({this.month,this.filter,this.value,this.force});
    GetAnalyticsReports.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        month = JsonConverters.fromJson(json['month'],'DateTime',context!);
        filter = json['filter'];
        value = json['value'];
        force = json['force'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'month': JsonConverters.toJson(month,'DateTime',context!),
        'filter': filter,
        'value': value,
        'force': force
    };

    createResponse() => GetAnalyticsReportsResponse();
    getResponseTypeName() => "GetAnalyticsReportsResponse";
    getTypeName() => "GetAnalyticsReports";
    TypeContext? context = _ctx;
}

// @Route("/validation/rules/{Type}")
// @DataContract
class GetValidationRules implements IReturn<GetValidationRulesResponse>, IGet, IConvertible
{
    // @DataMember(Order=1)
    String? authSecret;

    // @DataMember(Order=2)
    String? type;

    GetValidationRules({this.authSecret,this.type});
    GetValidationRules.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        authSecret = json['authSecret'];
        type = json['type'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'authSecret': authSecret,
        'type': type
    };

    createResponse() => GetValidationRulesResponse();
    getResponseTypeName() => "GetValidationRulesResponse";
    getTypeName() => "GetValidationRules";
    TypeContext? context = _ctx;
}

// @Route("/validation/rules")
// @DataContract
class ModifyValidationRules implements IReturnVoid, IConvertible, IPost
{
    // @DataMember(Order=1)
    String? authSecret;

    // @DataMember(Order=2)
    List<ValidationRule>? saveRules;

    // @DataMember(Order=3)
    List<int>? deleteRuleIds;

    // @DataMember(Order=4)
    List<int>? suspendRuleIds;

    // @DataMember(Order=5)
    List<int>? unsuspendRuleIds;

    // @DataMember(Order=6)
    bool? clearCache;

    ModifyValidationRules({this.authSecret,this.saveRules,this.deleteRuleIds,this.suspendRuleIds,this.unsuspendRuleIds,this.clearCache});
    ModifyValidationRules.fromJson(Map<String, dynamic> json) { fromMap(json); }

    fromMap(Map<String, dynamic> json) {
        authSecret = json['authSecret'];
        saveRules = JsonConverters.fromJson(json['saveRules'],'List<ValidationRule>',context!);
        deleteRuleIds = JsonConverters.fromJson(json['deleteRuleIds'],'List<int>',context!);
        suspendRuleIds = JsonConverters.fromJson(json['suspendRuleIds'],'List<int>',context!);
        unsuspendRuleIds = JsonConverters.fromJson(json['unsuspendRuleIds'],'List<int>',context!);
        clearCache = json['clearCache'];
        return this;
    }

    Map<String, dynamic> toJson() => {
        'authSecret': authSecret,
        'saveRules': JsonConverters.toJson(saveRules,'List<ValidationRule>',context!),
        'deleteRuleIds': JsonConverters.toJson(deleteRuleIds,'List<int>',context!),
        'suspendRuleIds': JsonConverters.toJson(suspendRuleIds,'List<int>',context!),
        'unsuspendRuleIds': JsonConverters.toJson(unsuspendRuleIds,'List<int>',context!),
        'clearCache': clearCache
    };

    createResponse() {}
    getTypeName() => "ModifyValidationRules";
    TypeContext? context = _ctx;
}

TypeContext _ctx = TypeContext(library: 'localhost', types: <String, TypeInfo> {
    'Property': TypeInfo(TypeOf.Class, create:() => Property()),
    'AiContent': TypeInfo(TypeOf.AbstractClass),
    'ToolCall': TypeInfo(TypeOf.Class, create:() => ToolCall()),
    'AiMessage': TypeInfo(TypeOf.Class, create:() => AiMessage()),
    'List<AiContent>': TypeInfo(TypeOf.Class, create:() => <AiContent>[]),
    'List<ToolCall>': TypeInfo(TypeOf.Class, create:() => <ToolCall>[]),
    'AiChatAudio': TypeInfo(TypeOf.Class, create:() => AiChatAudio()),
    'ResponseFormat': TypeInfo(TypeOf.Enum, enumValues:ResponseFormat.values),
    'AiResponseFormat': TypeInfo(TypeOf.Class, create:() => AiResponseFormat()),
    'ToolType': TypeInfo(TypeOf.Enum, enumValues:ToolType.values),
    'Tool': TypeInfo(TypeOf.Class, create:() => Tool()),
    'ModelUsage': TypeInfo(TypeOf.Class, create:() => ModelUsage()),
    'ChatCompletionLog': TypeInfo(TypeOf.Class, create:() => ChatCompletionLog()),
    'AdminUserBase': TypeInfo(TypeOf.AbstractClass),
    'RequestLog': TypeInfo(TypeOf.Class, create:() => RequestLog()),
    'RedisEndpointInfo': TypeInfo(TypeOf.Class, create:() => RedisEndpointInfo()),
    'BackgroundJobState': TypeInfo(TypeOf.Enum, enumValues:BackgroundJobState.values),
    'BackgroundJobBase': TypeInfo(TypeOf.AbstractClass),
    'BackgroundJob': TypeInfo(TypeOf.Class, create:() => BackgroundJob()),
    'JobSummary': TypeInfo(TypeOf.Class, create:() => JobSummary()),
    'BackgroundJobOptions': TypeInfo(TypeOf.Class, create:() => BackgroundJobOptions()),
    'ScheduledTask': TypeInfo(TypeOf.Class, create:() => ScheduledTask()),
    'CompletedJob': TypeInfo(TypeOf.Class, create:() => CompletedJob()),
    'FailedJob': TypeInfo(TypeOf.Class, create:() => FailedJob()),
    'ValidateRule': TypeInfo(TypeOf.Class, create:() => ValidateRule()),
    'ValidationRule': TypeInfo(TypeOf.Class, create:() => ValidationRule()),
    'AppInfo': TypeInfo(TypeOf.Class, create:() => AppInfo()),
    'ImageInfo': TypeInfo(TypeOf.Class, create:() => ImageInfo()),
    'LinkInfo': TypeInfo(TypeOf.Class, create:() => LinkInfo()),
    'ThemeInfo': TypeInfo(TypeOf.Class, create:() => ThemeInfo()),
    'ApiCss': TypeInfo(TypeOf.Class, create:() => ApiCss()),
    'AppTags': TypeInfo(TypeOf.Class, create:() => AppTags()),
    'LocodeUi': TypeInfo(TypeOf.Class, create:() => LocodeUi()),
    'ExplorerUi': TypeInfo(TypeOf.Class, create:() => ExplorerUi()),
    'PageInfo': TypeInfo(TypeOf.Class, create:() => PageInfo()),
    'AdminUi': TypeInfo(TypeOf.Class, create:() => AdminUi()),
    'List<PageInfo>': TypeInfo(TypeOf.Class, create:() => <PageInfo>[]),
    'FormatInfo': TypeInfo(TypeOf.Class, create:() => FormatInfo()),
    'ApiFormat': TypeInfo(TypeOf.Class, create:() => ApiFormat()),
    'UiInfo': TypeInfo(TypeOf.Class, create:() => UiInfo()),
    'List<LinkInfo>': TypeInfo(TypeOf.Class, create:() => <LinkInfo>[]),
    'ConfigInfo': TypeInfo(TypeOf.Class, create:() => ConfigInfo()),
    'FieldCss': TypeInfo(TypeOf.Class, create:() => FieldCss()),
    'InputInfo': TypeInfo(TypeOf.Class, create:() => InputInfo()),
    'List<KeyValuePair><String,String>': TypeInfo(TypeOf.Class, create:() => <KeyValuePair><String,String>[]),
    'KeyValuePair': TypeInfo(TypeOf.Class, create:() => KeyValuePair()),
    'MetaAuthProvider': TypeInfo(TypeOf.Class, create:() => MetaAuthProvider()),
    'List<InputInfo>': TypeInfo(TypeOf.Class, create:() => <InputInfo>[]),
    'IdentityAuthInfo': TypeInfo(TypeOf.Class, create:() => IdentityAuthInfo()),
    'AuthInfo': TypeInfo(TypeOf.Class, create:() => AuthInfo()),
    'List<MetaAuthProvider>': TypeInfo(TypeOf.Class, create:() => <MetaAuthProvider>[]),
    'Map<String,List<LinkInfo>?>': TypeInfo(TypeOf.Class, create:() => Map<String,List<LinkInfo>?>()),
    'Map<String,List<String>?>': TypeInfo(TypeOf.Class, create:() => Map<String,List<String>?>()),
    'ApiKeyInfo': TypeInfo(TypeOf.Class, create:() => ApiKeyInfo()),
    'List<KeyValuePair<String,String>>': TypeInfo(TypeOf.Class, create:() => <KeyValuePair<String,String>>[]),
    'MetadataTypeName': TypeInfo(TypeOf.Class, create:() => MetadataTypeName()),
    'MetadataDataContract': TypeInfo(TypeOf.Class, create:() => MetadataDataContract()),
    'MetadataDataMember': TypeInfo(TypeOf.Class, create:() => MetadataDataMember()),
    'MetadataAttribute': TypeInfo(TypeOf.Class, create:() => MetadataAttribute()),
    'List<MetadataPropertyType>': TypeInfo(TypeOf.Class, create:() => <MetadataPropertyType>[]),
    'MetadataPropertyType': TypeInfo(TypeOf.Class, create:() => MetadataPropertyType()),
    'RefInfo': TypeInfo(TypeOf.Class, create:() => RefInfo()),
    'List<MetadataAttribute>': TypeInfo(TypeOf.Class, create:() => <MetadataAttribute>[]),
    'MetadataType': TypeInfo(TypeOf.Class, create:() => MetadataType()),
    'List<MetadataTypeName>': TypeInfo(TypeOf.Class, create:() => <MetadataTypeName>[]),
    'CommandInfo': TypeInfo(TypeOf.Class, create:() => CommandInfo()),
    'CommandsInfo': TypeInfo(TypeOf.Class, create:() => CommandsInfo()),
    'List<CommandInfo>': TypeInfo(TypeOf.Class, create:() => <CommandInfo>[]),
    'AutoQueryConvention': TypeInfo(TypeOf.Class, create:() => AutoQueryConvention()),
    'AutoQueryInfo': TypeInfo(TypeOf.Class, create:() => AutoQueryInfo()),
    'List<AutoQueryConvention>': TypeInfo(TypeOf.Class, create:() => <AutoQueryConvention>[]),
    'ScriptMethodType': TypeInfo(TypeOf.Class, create:() => ScriptMethodType()),
    'ValidationInfo': TypeInfo(TypeOf.Class, create:() => ValidationInfo()),
    'List<ScriptMethodType>': TypeInfo(TypeOf.Class, create:() => <ScriptMethodType>[]),
    'SharpPagesInfo': TypeInfo(TypeOf.Class, create:() => SharpPagesInfo()),
    'RequestLogsAnalytics': TypeInfo(TypeOf.Class, create:() => RequestLogsAnalytics()),
    'RequestLogsInfo': TypeInfo(TypeOf.Class, create:() => RequestLogsInfo()),
    'ProfilingInfo': TypeInfo(TypeOf.Class, create:() => ProfilingInfo()),
    'FilesUploadLocation': TypeInfo(TypeOf.Class, create:() => FilesUploadLocation()),
    'FilesUploadInfo': TypeInfo(TypeOf.Class, create:() => FilesUploadInfo()),
    'List<FilesUploadLocation>': TypeInfo(TypeOf.Class, create:() => <FilesUploadLocation>[]),
    'MediaRule': TypeInfo(TypeOf.Class, create:() => MediaRule()),
    'AdminUsersInfo': TypeInfo(TypeOf.Class, create:() => AdminUsersInfo()),
    'List<MediaRule>': TypeInfo(TypeOf.Class, create:() => <MediaRule>[]),
    'AdminIdentityUsersInfo': TypeInfo(TypeOf.Class, create:() => AdminIdentityUsersInfo()),
    'AdminRedisInfo': TypeInfo(TypeOf.Class, create:() => AdminRedisInfo()),
    'SchemaInfo': TypeInfo(TypeOf.Class, create:() => SchemaInfo()),
    'DatabaseInfo': TypeInfo(TypeOf.Class, create:() => DatabaseInfo()),
    'List<SchemaInfo>': TypeInfo(TypeOf.Class, create:() => <SchemaInfo>[]),
    'AdminDatabaseInfo': TypeInfo(TypeOf.Class, create:() => AdminDatabaseInfo()),
    'List<DatabaseInfo>': TypeInfo(TypeOf.Class, create:() => <DatabaseInfo>[]),
    'PluginInfo': TypeInfo(TypeOf.Class, create:() => PluginInfo()),
    'CustomPluginInfo': TypeInfo(TypeOf.Class, create:() => CustomPluginInfo()),
    'MetadataTypesConfig': TypeInfo(TypeOf.Class, create:() => MetadataTypesConfig()),
    'MetadataRoute': TypeInfo(TypeOf.Class, create:() => MetadataRoute()),
    'ApiUiInfo': TypeInfo(TypeOf.Class, create:() => ApiUiInfo()),
    'MetadataOperationType': TypeInfo(TypeOf.Class, create:() => MetadataOperationType()),
    'List<MetadataRoute>': TypeInfo(TypeOf.Class, create:() => <MetadataRoute>[]),
    'MetadataTypes': TypeInfo(TypeOf.Class, create:() => MetadataTypes()),
    'List<MetadataType>': TypeInfo(TypeOf.Class, create:() => <MetadataType>[]),
    'List<MetadataOperationType>': TypeInfo(TypeOf.Class, create:() => <MetadataOperationType>[]),
    'AdminRole': TypeInfo(TypeOf.Class, create:() => AdminRole()),
    'ServerStats': TypeInfo(TypeOf.Class, create:() => ServerStats()),
    'Map<String,int?>': TypeInfo(TypeOf.Class, create:() => Map<String,int?>()),
    'PartialApiKey': TypeInfo(TypeOf.Class, create:() => PartialApiKey()),
    'UrlCitation': TypeInfo(TypeOf.Class, create:() => UrlCitation()),
    'ChoiceAnnotation': TypeInfo(TypeOf.Class, create:() => ChoiceAnnotation()),
    'ChoiceAudio': TypeInfo(TypeOf.Class, create:() => ChoiceAudio()),
    'ChoiceMessage': TypeInfo(TypeOf.Class, create:() => ChoiceMessage()),
    'List<ChoiceAnnotation>': TypeInfo(TypeOf.Class, create:() => <ChoiceAnnotation>[]),
    'Choice': TypeInfo(TypeOf.Class, create:() => Choice()),
    'AiCompletionUsage': TypeInfo(TypeOf.Class, create:() => AiCompletionUsage()),
    'AiPromptUsage': TypeInfo(TypeOf.Class, create:() => AiPromptUsage()),
    'AiUsage': TypeInfo(TypeOf.Class, create:() => AiUsage()),
    'ChatCompletionStat': TypeInfo(TypeOf.Class, create:() => ChatCompletionStat()),
    'DiagnosticEntry': TypeInfo(TypeOf.Class, create:() => DiagnosticEntry()),
    'Map<String,dynamic?>': TypeInfo(TypeOf.Class, create:() => Map<String,dynamic?>()),
    'RedisSearchResult': TypeInfo(TypeOf.Class, create:() => RedisSearchResult()),
    'RedisText': TypeInfo(TypeOf.Class, create:() => RedisText()),
    'List<RedisText>': TypeInfo(TypeOf.Class, create:() => <RedisText>[]),
    'CommandSummary': TypeInfo(TypeOf.Class, create:() => CommandSummary()),
    'CommandResult': TypeInfo(TypeOf.Class, create:() => CommandResult()),
    'JobStatSummary': TypeInfo(TypeOf.Class, create:() => JobStatSummary()),
    'HourSummary': TypeInfo(TypeOf.Class, create:() => HourSummary()),
    'WorkerStats': TypeInfo(TypeOf.Class, create:() => WorkerStats()),
    'RequestLogEntry': TypeInfo(TypeOf.Class, create:() => RequestLogEntry()),
    'AnalyticsLogInfo': TypeInfo(TypeOf.Class, create:() => AnalyticsLogInfo()),
    'RequestSummary': TypeInfo(TypeOf.Class, create:() => RequestSummary()),
    'Map<int,int?>': TypeInfo(TypeOf.Class, create:() => Map<int,int?>()),
    'AnalyticsReports': TypeInfo(TypeOf.Class, create:() => AnalyticsReports()),
    'Map<String,RequestSummary?>': TypeInfo(TypeOf.Class, create:() => Map<String,RequestSummary?>()),
    'AiTextContent': TypeInfo(TypeOf.Class, create:() => AiTextContent()),
    'AiImageUrl': TypeInfo(TypeOf.Class, create:() => AiImageUrl()),
    'AiImageContent': TypeInfo(TypeOf.Class, create:() => AiImageContent()),
    'AiInputAudio': TypeInfo(TypeOf.Class, create:() => AiInputAudio()),
    'AiAudioContent': TypeInfo(TypeOf.Class, create:() => AiAudioContent()),
    'AiFile': TypeInfo(TypeOf.Class, create:() => AiFile()),
    'AiFileContent': TypeInfo(TypeOf.Class, create:() => AiFileContent()),
    'AdminGetRolesResponse': TypeInfo(TypeOf.Class, create:() => AdminGetRolesResponse()),
    'List<AdminRole>': TypeInfo(TypeOf.Class, create:() => <AdminRole>[]),
    'AdminGetRoleResponse': TypeInfo(TypeOf.Class, create:() => AdminGetRoleResponse()),
    'List<Property>': TypeInfo(TypeOf.Class, create:() => <Property>[]),
    'AdminDashboardResponse': TypeInfo(TypeOf.Class, create:() => AdminDashboardResponse()),
    'AdminApiKeysResponse': TypeInfo(TypeOf.Class, create:() => AdminApiKeysResponse()),
    'List<PartialApiKey>': TypeInfo(TypeOf.Class, create:() => <PartialApiKey>[]),
    'AdminApiKeyResponse': TypeInfo(TypeOf.Class, create:() => AdminApiKeyResponse()),
    'ChatResponse': TypeInfo(TypeOf.Class, create:() => ChatResponse()),
    'List<Choice>': TypeInfo(TypeOf.Class, create:() => <Choice>[]),
    'AdminMonthlyChatCompletionAnalyticsResponse': TypeInfo(TypeOf.Class, create:() => AdminMonthlyChatCompletionAnalyticsResponse()),
    'List<ChatCompletionStat>': TypeInfo(TypeOf.Class, create:() => <ChatCompletionStat>[]),
    'AdminDailyChatCompletionAnalyticsResponse': TypeInfo(TypeOf.Class, create:() => AdminDailyChatCompletionAnalyticsResponse()),
    'AdminUserResponse': TypeInfo(TypeOf.Class, create:() => AdminUserResponse()),
    'List<Map<String,dynamic>>': TypeInfo(TypeOf.Class, create:() => <Map<String,dynamic>>[]),
    'Map<String,dynamic>': TypeInfo(TypeOf.Class, create:() => Map<String,dynamic>()),
    'AdminUsersResponse': TypeInfo(TypeOf.Class, create:() => AdminUsersResponse()),
    'AdminDeleteUserResponse': TypeInfo(TypeOf.Class, create:() => AdminDeleteUserResponse()),
    'AdminProfilingResponse': TypeInfo(TypeOf.Class, create:() => AdminProfilingResponse()),
    'List<DiagnosticEntry>': TypeInfo(TypeOf.Class, create:() => <DiagnosticEntry>[]),
    'AdminRedisResponse': TypeInfo(TypeOf.Class, create:() => AdminRedisResponse()),
    'List<RedisSearchResult>': TypeInfo(TypeOf.Class, create:() => <RedisSearchResult>[]),
    'AdminDatabaseResponse': TypeInfo(TypeOf.Class, create:() => AdminDatabaseResponse()),
    'ViewCommandsResponse': TypeInfo(TypeOf.Class, create:() => ViewCommandsResponse()),
    'List<CommandSummary>': TypeInfo(TypeOf.Class, create:() => <CommandSummary>[]),
    'List<CommandResult>': TypeInfo(TypeOf.Class, create:() => <CommandResult>[]),
    'ExecuteCommandResponse': TypeInfo(TypeOf.Class, create:() => ExecuteCommandResponse()),
    'AdminJobDashboardResponse': TypeInfo(TypeOf.Class, create:() => AdminJobDashboardResponse()),
    'List<JobStatSummary>': TypeInfo(TypeOf.Class, create:() => <JobStatSummary>[]),
    'List<HourSummary>': TypeInfo(TypeOf.Class, create:() => <HourSummary>[]),
    'AdminJobInfoResponse': TypeInfo(TypeOf.Class, create:() => AdminJobInfoResponse()),
    'List<DateTime>': TypeInfo(TypeOf.Class, create:() => <DateTime>[]),
    'List<WorkerStats>': TypeInfo(TypeOf.Class, create:() => <WorkerStats>[]),
    'Map<BackgroundJobState,int?>': TypeInfo(TypeOf.Class, create:() => Map<BackgroundJobState,int?>()),
    'AdminGetJobResponse': TypeInfo(TypeOf.Class, create:() => AdminGetJobResponse()),
    'AdminGetJobProgressResponse': TypeInfo(TypeOf.Class, create:() => AdminGetJobProgressResponse()),
    'AdminRequeueFailedJobsJobsResponse': TypeInfo(TypeOf.Class, create:() => AdminRequeueFailedJobsJobsResponse()),
    'Map<int,String?>': TypeInfo(TypeOf.Class, create:() => Map<int,String?>()),
    'AdminCancelJobsResponse': TypeInfo(TypeOf.Class, create:() => AdminCancelJobsResponse()),
    'RequestLogsResponse': TypeInfo(TypeOf.Class, create:() => RequestLogsResponse()),
    'List<RequestLogEntry>': TypeInfo(TypeOf.Class, create:() => <RequestLogEntry>[]),
    'GetAnalyticsInfoResponse': TypeInfo(TypeOf.Class, create:() => GetAnalyticsInfoResponse()),
    'GetAnalyticsReportsResponse': TypeInfo(TypeOf.Class, create:() => GetAnalyticsReportsResponse()),
    'GetValidationRulesResponse': TypeInfo(TypeOf.Class, create:() => GetValidationRulesResponse()),
    'List<ValidationRule>': TypeInfo(TypeOf.Class, create:() => <ValidationRule>[]),
    'AdminCreateRole': TypeInfo(TypeOf.Class, create:() => AdminCreateRole()),
    'AdminGetRoles': TypeInfo(TypeOf.Class, create:() => AdminGetRoles()),
    'AdminGetRole': TypeInfo(TypeOf.Class, create:() => AdminGetRole()),
    'AdminUpdateRole': TypeInfo(TypeOf.Class, create:() => AdminUpdateRole()),
    'AdminDeleteRole': TypeInfo(TypeOf.Class, create:() => AdminDeleteRole()),
    'AdminDashboard': TypeInfo(TypeOf.Class, create:() => AdminDashboard()),
    'AdminQueryApiKeys': TypeInfo(TypeOf.Class, create:() => AdminQueryApiKeys()),
    'AdminCreateApiKey': TypeInfo(TypeOf.Class, create:() => AdminCreateApiKey()),
    'AdminUpdateApiKey': TypeInfo(TypeOf.Class, create:() => AdminUpdateApiKey()),
    'AdminDeleteApiKey': TypeInfo(TypeOf.Class, create:() => AdminDeleteApiKey()),
    'ChatCompletion': TypeInfo(TypeOf.Class, create:() => ChatCompletion()),
    'List<AiMessage>': TypeInfo(TypeOf.Class, create:() => <AiMessage>[]),
    'List<Tool>': TypeInfo(TypeOf.Class, create:() => <Tool>[]),
    'QueryResponse<ChatCompletionLog>': TypeInfo(TypeOf.Class, create:() => QueryResponse<ChatCompletionLog>()),
    'AdminQueryChatCompletionLogs': TypeInfo(TypeOf.Class, create:() => AdminQueryChatCompletionLogs()),
    'List<ChatCompletionLog>': TypeInfo(TypeOf.Class, create:() => <ChatCompletionLog>[]),
    'AdminMonthlyChatCompletionAnalytics': TypeInfo(TypeOf.Class, create:() => AdminMonthlyChatCompletionAnalytics()),
    'AdminDailyChatCompletionAnalytics': TypeInfo(TypeOf.Class, create:() => AdminDailyChatCompletionAnalytics()),
    'AdminGetUser': TypeInfo(TypeOf.Class, create:() => AdminGetUser()),
    'AdminQueryUsers': TypeInfo(TypeOf.Class, create:() => AdminQueryUsers()),
    'AdminCreateUser': TypeInfo(TypeOf.Class, create:() => AdminCreateUser()),
    'AdminUpdateUser': TypeInfo(TypeOf.Class, create:() => AdminUpdateUser()),
    'AdminDeleteUser': TypeInfo(TypeOf.Class, create:() => AdminDeleteUser()),
    'QueryResponse<RequestLog>': TypeInfo(TypeOf.Class, create:() => QueryResponse<RequestLog>()),
    'AdminQueryRequestLogs': TypeInfo(TypeOf.Class, create:() => AdminQueryRequestLogs()),
    'List<RequestLog>': TypeInfo(TypeOf.Class, create:() => <RequestLog>[]),
    'AdminProfiling': TypeInfo(TypeOf.Class, create:() => AdminProfiling()),
    'AdminRedis': TypeInfo(TypeOf.Class, create:() => AdminRedis()),
    'AdminDatabase': TypeInfo(TypeOf.Class, create:() => AdminDatabase()),
    'ViewCommands': TypeInfo(TypeOf.Class, create:() => ViewCommands()),
    'ExecuteCommand': TypeInfo(TypeOf.Class, create:() => ExecuteCommand()),
    'AdminJobDashboard': TypeInfo(TypeOf.Class, create:() => AdminJobDashboard()),
    'AdminJobInfo': TypeInfo(TypeOf.Class, create:() => AdminJobInfo()),
    'AdminGetJob': TypeInfo(TypeOf.Class, create:() => AdminGetJob()),
    'AdminGetJobProgress': TypeInfo(TypeOf.Class, create:() => AdminGetJobProgress()),
    'QueryResponse<BackgroundJob>': TypeInfo(TypeOf.Class, create:() => QueryResponse<BackgroundJob>()),
    'AdminQueryBackgroundJobs': TypeInfo(TypeOf.Class, create:() => AdminQueryBackgroundJobs()),
    'List<BackgroundJob>': TypeInfo(TypeOf.Class, create:() => <BackgroundJob>[]),
    'QueryResponse<JobSummary>': TypeInfo(TypeOf.Class, create:() => QueryResponse<JobSummary>()),
    'AdminQueryJobSummary': TypeInfo(TypeOf.Class, create:() => AdminQueryJobSummary()),
    'List<JobSummary>': TypeInfo(TypeOf.Class, create:() => <JobSummary>[]),
    'QueryResponse<ScheduledTask>': TypeInfo(TypeOf.Class, create:() => QueryResponse<ScheduledTask>()),
    'AdminQueryScheduledTasks': TypeInfo(TypeOf.Class, create:() => AdminQueryScheduledTasks()),
    'List<ScheduledTask>': TypeInfo(TypeOf.Class, create:() => <ScheduledTask>[]),
    'QueryResponse<CompletedJob>': TypeInfo(TypeOf.Class, create:() => QueryResponse<CompletedJob>()),
    'AdminQueryCompletedJobs': TypeInfo(TypeOf.Class, create:() => AdminQueryCompletedJobs()),
    'List<CompletedJob>': TypeInfo(TypeOf.Class, create:() => <CompletedJob>[]),
    'QueryResponse<FailedJob>': TypeInfo(TypeOf.Class, create:() => QueryResponse<FailedJob>()),
    'AdminQueryFailedJobs': TypeInfo(TypeOf.Class, create:() => AdminQueryFailedJobs()),
    'List<FailedJob>': TypeInfo(TypeOf.Class, create:() => <FailedJob>[]),
    'AdminRequeueFailedJobs': TypeInfo(TypeOf.Class, create:() => AdminRequeueFailedJobs()),
    'AdminCancelJobs': TypeInfo(TypeOf.Class, create:() => AdminCancelJobs()),
    'RequestLogs': TypeInfo(TypeOf.Class, create:() => RequestLogs()),
    'GetAnalyticsInfo': TypeInfo(TypeOf.Class, create:() => GetAnalyticsInfo()),
    'GetAnalyticsReports': TypeInfo(TypeOf.Class, create:() => GetAnalyticsReports()),
    'GetValidationRules': TypeInfo(TypeOf.Class, create:() => GetValidationRules()),
    'ModifyValidationRules': TypeInfo(TypeOf.Class, create:() => ModifyValidationRules()),
});

