<?php namespace dtos;
/* Options:
Date: 2025-10-14 12:42:12
Version: 8.81
Tip: To override a DTO option, remove "//" prefix before updating
BaseUrl: https://localhost:5001

//GlobalNamespace: dtos
//MakePropertiesOptional: False
//AddServiceStackTypes: True
//AddResponseStatus: False
//AddImplicitVersion: 
//AddDescriptionAsComments: True
IncludeTypes: ChatCompletion.*
//ExcludeTypes: 
//DefaultImports: 
*/


use DateTime;
use Exception;
use DateInterval;
use JsonSerializable;
use ServiceStack\{IReturn,IReturnVoid,IGet,IPost,IPut,IDelete,IPatch,IMeta,IHasSessionId,IHasBearerToken,IHasVersion};
use ServiceStack\{ICrud,ICreateDb,IUpdateDb,IPatchDb,IDeleteDb,ISaveDb,AuditBase,QueryDb,QueryDb2,QueryData,QueryData2,QueryResponse};
use ServiceStack\{ResponseStatus,ResponseError,EmptyResponse,IdResponse,ArrayList,KeyValuePair2,StringResponse,StringsResponse,Tuple2,Tuple3,ByteArray};
use ServiceStack\{JsonConverters,Returns,TypeContext};


// @DataContract
class AiContent implements JsonSerializable
{
    public function __construct(
        /** @description The type of the content part. */
        // @DataMember(Name="type")
        /** @var string */
        public string $type=''
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['type'])) $this->type = $o['type'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->type)) $o['type'] = $this->type;
        return empty($o) ? new class(){} : $o;
    }
}

/** @description The tool calls generated by the model, such as function calls. */
// @DataContract
class ToolCall implements JsonSerializable
{
    public function __construct(
        /** @description The ID of the tool call. */
        // @DataMember(Name="id")
        /** @var string */
        public string $id='',

        /** @description The type of the tool. Currently, only `function` is supported. */
        // @DataMember(Name="type")
        /** @var string */
        public string $type='',

        /** @description The function that the model called. */
        // @DataMember(Name="function")
        /** @var string */
        public string $function=''
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['id'])) $this->id = $o['id'];
        if (isset($o['type'])) $this->type = $o['type'];
        if (isset($o['function'])) $this->function = $o['function'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->id)) $o['id'] = $this->id;
        if (isset($this->type)) $o['type'] = $this->type;
        if (isset($this->function)) $o['function'] = $this->function;
        return empty($o) ? new class(){} : $o;
    }
}

/** @description A list of messages comprising the conversation so far. */
// @DataContract
class AiMessage implements JsonSerializable
{
    public function __construct(
        /** @description The contents of the message. */
        // @DataMember(Name="content")
        /** @var array<AiContent>|null */
        public ?array $content=null,

        /** @description The role of the author of this message. Valid values are `system`, `user`, `assistant` and `tool`. */
        // @DataMember(Name="role")
        /** @var string */
        public string $role='',

        /** @description An optional name for the participant. Provides the model information to differentiate between participants of the same role. */
        // @DataMember(Name="name")
        /** @var string|null */
        public ?string $name=null,

        /** @description The tool calls generated by the model, such as function calls. */
        // @DataMember(Name="tool_calls")
        /** @var array<ToolCall>|null */
        public ?array $tool_calls=null,

        /** @description Tool call that this message is responding to. */
        // @DataMember(Name="tool_call_id")
        /** @var string|null */
        public ?string $tool_call_id=null
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['content'])) $this->content = JsonConverters::fromArray('AiContent', $o['content']);
        if (isset($o['role'])) $this->role = $o['role'];
        if (isset($o['name'])) $this->name = $o['name'];
        if (isset($o['tool_calls'])) $this->tool_calls = JsonConverters::fromArray('ToolCall', $o['tool_calls']);
        if (isset($o['tool_call_id'])) $this->tool_call_id = $o['tool_call_id'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->content)) $o['content'] = JsonConverters::toArray('AiContent', $this->content);
        if (isset($this->role)) $o['role'] = $this->role;
        if (isset($this->name)) $o['name'] = $this->name;
        if (isset($this->tool_calls)) $o['tool_calls'] = JsonConverters::toArray('ToolCall', $this->tool_calls);
        if (isset($this->tool_call_id)) $o['tool_call_id'] = $this->tool_call_id;
        return empty($o) ? new class(){} : $o;
    }
}

/** @description Parameters for audio output. Required when audio output is requested with modalities: [audio] */
// @DataContract
class AiChatAudio implements JsonSerializable
{
    public function __construct(
        /** @description Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16. */
        // @DataMember(Name="format")
        /** @var string */
        public string $format='',

        /** @description The voice the model uses to respond. Supported voices are alloy, ash, ballad, coral, echo, fable, nova, onyx, sage, and shimmer. */
        // @DataMember(Name="voice")
        /** @var string */
        public string $voice=''
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['format'])) $this->format = $o['format'];
        if (isset($o['voice'])) $this->voice = $o['voice'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->format)) $o['format'] = $this->format;
        if (isset($this->voice)) $o['voice'] = $this->voice;
        return empty($o) ? new class(){} : $o;
    }
}

enum ResponseFormat : string
{
    case Text = 'text';
    case JsonObject = 'json_object';
}

// @DataContract
class AiResponseFormat implements JsonSerializable
{
    public function __construct(
        /** @description An object specifying the format that the model must output. Compatible with GPT-4 Turbo and all GPT-3.5 Turbo models newer than gpt-3.5-turbo-1106. */
        // @DataMember(Name="response_format")
        /** @var ResponseFormat|null */
        public ?ResponseFormat $response_format=null
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['response_format'])) $this->response_format = JsonConverters::from('ResponseFormat', $o['response_format']);
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->response_format)) $o['response_format'] = JsonConverters::to('ResponseFormat', $this->response_format);
        return empty($o) ? new class(){} : $o;
    }
}

enum ToolType : string
{
    case Function = 'function';
}

// @DataContract
class Tool implements JsonSerializable
{
    public function __construct(
        /** @description The type of the tool. Currently, only function is supported. */
        // @DataMember(Name="type")
        /** @var ToolType|null */
        public ?ToolType $type=null
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['type'])) $this->type = JsonConverters::from('ToolType', $o['type']);
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->type)) $o['type'] = JsonConverters::to('ToolType', $this->type);
        return empty($o) ? new class(){} : $o;
    }
}

/** @description Annotations for the message, when applicable, as when using the web search tool. */
// @DataContract
class UrlCitation implements JsonSerializable
{
    public function __construct(
        /** @description The index of the last character of the URL citation in the message. */
        // @DataMember(Name="end_index")
        /** @var int */
        public int $end_index=0,

        /** @description The index of the first character of the URL citation in the message. */
        // @DataMember(Name="start_index")
        /** @var int */
        public int $start_index=0,

        /** @description The title of the web resource. */
        // @DataMember(Name="title")
        /** @var string */
        public string $title='',

        /** @description The URL of the web resource. */
        // @DataMember(Name="url")
        /** @var string */
        public string $url=''
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['end_index'])) $this->end_index = $o['end_index'];
        if (isset($o['start_index'])) $this->start_index = $o['start_index'];
        if (isset($o['title'])) $this->title = $o['title'];
        if (isset($o['url'])) $this->url = $o['url'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->end_index)) $o['end_index'] = $this->end_index;
        if (isset($this->start_index)) $o['start_index'] = $this->start_index;
        if (isset($this->title)) $o['title'] = $this->title;
        if (isset($this->url)) $o['url'] = $this->url;
        return empty($o) ? new class(){} : $o;
    }
}

/** @description Annotations for the message, when applicable, as when using the web search tool. */
// @DataContract
class ChoiceAnnotation implements JsonSerializable
{
    public function __construct(
        /** @description The type of the URL citation. Always url_citation. */
        // @DataMember(Name="type")
        /** @var string */
        public string $type='',

        /** @description A URL citation when using web search. */
        // @DataMember(Name="url_citation")
        /** @var UrlCitation|null */
        public ?UrlCitation $url_citation=null
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['type'])) $this->type = $o['type'];
        if (isset($o['url_citation'])) $this->url_citation = JsonConverters::from('UrlCitation', $o['url_citation']);
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->type)) $o['type'] = $this->type;
        if (isset($this->url_citation)) $o['url_citation'] = JsonConverters::to('UrlCitation', $this->url_citation);
        return empty($o) ? new class(){} : $o;
    }
}

/** @description If the audio output modality is requested, this object contains data about the audio response from the model. */
// @DataContract
class ChoiceAudio implements JsonSerializable
{
    public function __construct(
        /** @description Base64 encoded audio bytes generated by the model, in the format specified in the request. */
        // @DataMember(Name="data")
        /** @var string */
        public string $data='',

        /** @description The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server for use in multi-turn conversations. */
        // @DataMember(Name="expires_at")
        /** @var int */
        public int $expires_at=0,

        /** @description Unique identifier for this audio response. */
        // @DataMember(Name="id")
        /** @var string */
        public string $id='',

        /** @description Transcript of the audio generated by the model. */
        // @DataMember(Name="transcript")
        /** @var string */
        public string $transcript=''
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['data'])) $this->data = $o['data'];
        if (isset($o['expires_at'])) $this->expires_at = $o['expires_at'];
        if (isset($o['id'])) $this->id = $o['id'];
        if (isset($o['transcript'])) $this->transcript = $o['transcript'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->data)) $o['data'] = $this->data;
        if (isset($this->expires_at)) $o['expires_at'] = $this->expires_at;
        if (isset($this->id)) $o['id'] = $this->id;
        if (isset($this->transcript)) $o['transcript'] = $this->transcript;
        return empty($o) ? new class(){} : $o;
    }
}

// @DataContract
class ChoiceMessage implements JsonSerializable
{
    public function __construct(
        /** @description The contents of the message. */
        // @DataMember(Name="content")
        /** @var string */
        public string $content='',

        /** @description The refusal message generated by the model. */
        // @DataMember(Name="refusal")
        /** @var string|null */
        public ?string $refusal=null,

        /** @description The reasoning process used by the model. */
        // @DataMember(Name="reasoning")
        /** @var string|null */
        public ?string $reasoning=null,

        /** @description The role of the author of this message. */
        // @DataMember(Name="role")
        /** @var string */
        public string $role='',

        /** @description Annotations for the message, when applicable, as when using the web search tool. */
        // @DataMember(Name="annotations")
        /** @var array<ChoiceAnnotation>|null */
        public ?array $annotations=null,

        /** @description If the audio output modality is requested, this object contains data about the audio response from the model. */
        // @DataMember(Name="audio")
        /** @var ChoiceAudio|null */
        public ?ChoiceAudio $audio=null,

        /** @description The tool calls generated by the model, such as function calls. */
        // @DataMember(Name="tool_calls")
        /** @var array<ToolCall>|null */
        public ?array $tool_calls=null
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['content'])) $this->content = $o['content'];
        if (isset($o['refusal'])) $this->refusal = $o['refusal'];
        if (isset($o['reasoning'])) $this->reasoning = $o['reasoning'];
        if (isset($o['role'])) $this->role = $o['role'];
        if (isset($o['annotations'])) $this->annotations = JsonConverters::fromArray('ChoiceAnnotation', $o['annotations']);
        if (isset($o['audio'])) $this->audio = JsonConverters::from('ChoiceAudio', $o['audio']);
        if (isset($o['tool_calls'])) $this->tool_calls = JsonConverters::fromArray('ToolCall', $o['tool_calls']);
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->content)) $o['content'] = $this->content;
        if (isset($this->refusal)) $o['refusal'] = $this->refusal;
        if (isset($this->reasoning)) $o['reasoning'] = $this->reasoning;
        if (isset($this->role)) $o['role'] = $this->role;
        if (isset($this->annotations)) $o['annotations'] = JsonConverters::toArray('ChoiceAnnotation', $this->annotations);
        if (isset($this->audio)) $o['audio'] = JsonConverters::to('ChoiceAudio', $this->audio);
        if (isset($this->tool_calls)) $o['tool_calls'] = JsonConverters::toArray('ToolCall', $this->tool_calls);
        return empty($o) ? new class(){} : $o;
    }
}

// @DataContract
class Choice implements JsonSerializable
{
    public function __construct(
        /** @description The reason the model stopped generating tokens. This will be stop if the model hit a natural stop point or a provided stop sequence, length if the maximum number of tokens specified in the request was reached, content_filter if content was omitted due to a flag from our content filters, tool_calls if the model called a tool */
        // @DataMember(Name="finish_reason")
        /** @var string */
        public string $finish_reason='',

        /** @description The index of the choice in the list of choices. */
        // @DataMember(Name="index")
        /** @var int */
        public int $index=0,

        /** @description A chat completion message generated by the model. */
        // @DataMember(Name="message")
        /** @var ChoiceMessage|null */
        public ?ChoiceMessage $message=null
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['finish_reason'])) $this->finish_reason = $o['finish_reason'];
        if (isset($o['index'])) $this->index = $o['index'];
        if (isset($o['message'])) $this->message = JsonConverters::from('ChoiceMessage', $o['message']);
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->finish_reason)) $o['finish_reason'] = $this->finish_reason;
        if (isset($this->index)) $o['index'] = $this->index;
        if (isset($this->message)) $o['message'] = JsonConverters::to('ChoiceMessage', $this->message);
        return empty($o) ? new class(){} : $o;
    }
}

/** @description Usage statistics for the completion request. */
// @DataContract
class AiCompletionUsage implements JsonSerializable
{
    public function __construct(
        /** @description When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion. */
        // @DataMember(Name="accepted_prediction_tokens")
        /** @var int */
        public int $accepted_prediction_tokens=0,

        /** @description Audio input tokens generated by the model. */
        // @DataMember(Name="audio_tokens")
        /** @var int */
        public int $audio_tokens=0,

        /** @description Tokens generated by the model for reasoning. */
        // @DataMember(Name="reasoning_tokens")
        /** @var int */
        public int $reasoning_tokens=0,

        /** @description When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion. */
        // @DataMember(Name="rejected_prediction_tokens")
        /** @var int */
        public int $rejected_prediction_tokens=0
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['accepted_prediction_tokens'])) $this->accepted_prediction_tokens = $o['accepted_prediction_tokens'];
        if (isset($o['audio_tokens'])) $this->audio_tokens = $o['audio_tokens'];
        if (isset($o['reasoning_tokens'])) $this->reasoning_tokens = $o['reasoning_tokens'];
        if (isset($o['rejected_prediction_tokens'])) $this->rejected_prediction_tokens = $o['rejected_prediction_tokens'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->accepted_prediction_tokens)) $o['accepted_prediction_tokens'] = $this->accepted_prediction_tokens;
        if (isset($this->audio_tokens)) $o['audio_tokens'] = $this->audio_tokens;
        if (isset($this->reasoning_tokens)) $o['reasoning_tokens'] = $this->reasoning_tokens;
        if (isset($this->rejected_prediction_tokens)) $o['rejected_prediction_tokens'] = $this->rejected_prediction_tokens;
        return empty($o) ? new class(){} : $o;
    }
}

/** @description Breakdown of tokens used in the prompt. */
// @DataContract
class AiPromptUsage implements JsonSerializable
{
    public function __construct(
        /** @description When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion. */
        // @DataMember(Name="accepted_prediction_tokens")
        /** @var int */
        public int $accepted_prediction_tokens=0,

        /** @description Audio input tokens present in the prompt. */
        // @DataMember(Name="audio_tokens")
        /** @var int */
        public int $audio_tokens=0,

        /** @description Cached tokens present in the prompt. */
        // @DataMember(Name="cached_tokens")
        /** @var int */
        public int $cached_tokens=0
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['accepted_prediction_tokens'])) $this->accepted_prediction_tokens = $o['accepted_prediction_tokens'];
        if (isset($o['audio_tokens'])) $this->audio_tokens = $o['audio_tokens'];
        if (isset($o['cached_tokens'])) $this->cached_tokens = $o['cached_tokens'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->accepted_prediction_tokens)) $o['accepted_prediction_tokens'] = $this->accepted_prediction_tokens;
        if (isset($this->audio_tokens)) $o['audio_tokens'] = $this->audio_tokens;
        if (isset($this->cached_tokens)) $o['cached_tokens'] = $this->cached_tokens;
        return empty($o) ? new class(){} : $o;
    }
}

/** @description Usage statistics for the completion request. */
// @DataContract
class AiUsage implements JsonSerializable
{
    public function __construct(
        /** @description Number of tokens in the generated completion. */
        // @DataMember(Name="completion_tokens")
        /** @var int */
        public int $completion_tokens=0,

        /** @description Number of tokens in the prompt. */
        // @DataMember(Name="prompt_tokens")
        /** @var int */
        public int $prompt_tokens=0,

        /** @description Total number of tokens used in the request (prompt + completion). */
        // @DataMember(Name="total_tokens")
        /** @var int */
        public int $total_tokens=0,

        /** @description Breakdown of tokens used in a completion. */
        // @DataMember(Name="completion_tokens_details")
        /** @var AiCompletionUsage|null */
        public ?AiCompletionUsage $completion_tokens_details=null,

        /** @description Breakdown of tokens used in the prompt. */
        // @DataMember(Name="prompt_tokens_details")
        /** @var AiPromptUsage|null */
        public ?AiPromptUsage $prompt_tokens_details=null
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['completion_tokens'])) $this->completion_tokens = $o['completion_tokens'];
        if (isset($o['prompt_tokens'])) $this->prompt_tokens = $o['prompt_tokens'];
        if (isset($o['total_tokens'])) $this->total_tokens = $o['total_tokens'];
        if (isset($o['completion_tokens_details'])) $this->completion_tokens_details = JsonConverters::from('AiCompletionUsage', $o['completion_tokens_details']);
        if (isset($o['prompt_tokens_details'])) $this->prompt_tokens_details = JsonConverters::from('AiPromptUsage', $o['prompt_tokens_details']);
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->completion_tokens)) $o['completion_tokens'] = $this->completion_tokens;
        if (isset($this->prompt_tokens)) $o['prompt_tokens'] = $this->prompt_tokens;
        if (isset($this->total_tokens)) $o['total_tokens'] = $this->total_tokens;
        if (isset($this->completion_tokens_details)) $o['completion_tokens_details'] = JsonConverters::to('AiCompletionUsage', $this->completion_tokens_details);
        if (isset($this->prompt_tokens_details)) $o['prompt_tokens_details'] = JsonConverters::to('AiPromptUsage', $this->prompt_tokens_details);
        return empty($o) ? new class(){} : $o;
    }
}

/** @description Text content part */
// @DataContract
class AiTextContent extends AiContent implements JsonSerializable
{
    /**
     * @param string $type
     */
    public function __construct(
        string $type='',
        /** @description The text content. */
        // @DataMember(Name="text")
        /** @var string */
        public string $text=''
    ) {
        parent::__construct($type);
    }

    /** @throws Exception */
    public function fromMap($o): void {
        parent::fromMap($o);
        if (isset($o['text'])) $this->text = $o['text'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = parent::jsonSerialize();
        if (isset($this->text)) $o['text'] = $this->text;
        return empty($o) ? new class(){} : $o;
    }
}

// @DataContract
class AiImageUrl implements JsonSerializable
{
    public function __construct(
        /** @description Either a URL of the image or the base64 encoded image data. */
        // @DataMember(Name="url")
        /** @var string */
        public string $url=''
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['url'])) $this->url = $o['url'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->url)) $o['url'] = $this->url;
        return empty($o) ? new class(){} : $o;
    }
}

/** @description Image content part */
// @DataContract
class AiImageContent extends AiContent implements JsonSerializable
{
    /**
     * @param string $type
     */
    public function __construct(
        string $type='',
        /** @description The image for this content. */
        // @DataMember(Name="image_url")
        /** @var AiImageUrl|null */
        public ?AiImageUrl $image_url=null
    ) {
        parent::__construct($type);
    }

    /** @throws Exception */
    public function fromMap($o): void {
        parent::fromMap($o);
        if (isset($o['image_url'])) $this->image_url = JsonConverters::from('AiImageUrl', $o['image_url']);
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = parent::jsonSerialize();
        if (isset($this->image_url)) $o['image_url'] = JsonConverters::to('AiImageUrl', $this->image_url);
        return empty($o) ? new class(){} : $o;
    }
}

/** @description Audio content part */
// @DataContract
class AiInputAudio implements JsonSerializable
{
    public function __construct(
        /** @description URL or Base64 encoded audio data. */
        // @DataMember(Name="data")
        /** @var string */
        public string $data='',

        /** @description The format of the encoded audio data. Currently supports 'wav' and 'mp3'. */
        // @DataMember(Name="format")
        /** @var string */
        public string $format=''
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['data'])) $this->data = $o['data'];
        if (isset($o['format'])) $this->format = $o['format'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->data)) $o['data'] = $this->data;
        if (isset($this->format)) $o['format'] = $this->format;
        return empty($o) ? new class(){} : $o;
    }
}

/** @description Audio content part */
// @DataContract
class AiAudioContent extends AiContent implements JsonSerializable
{
    /**
     * @param string $type
     */
    public function __construct(
        string $type='',
        /** @description The audio input for this content. */
        // @DataMember(Name="input_audio")
        /** @var AiInputAudio|null */
        public ?AiInputAudio $input_audio=null
    ) {
        parent::__construct($type);
    }

    /** @throws Exception */
    public function fromMap($o): void {
        parent::fromMap($o);
        if (isset($o['input_audio'])) $this->input_audio = JsonConverters::from('AiInputAudio', $o['input_audio']);
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = parent::jsonSerialize();
        if (isset($this->input_audio)) $o['input_audio'] = JsonConverters::to('AiInputAudio', $this->input_audio);
        return empty($o) ? new class(){} : $o;
    }
}

/** @description File content part */
// @DataContract
class AiFile implements JsonSerializable
{
    public function __construct(
        /** @description The URL or base64 encoded file data, used when passing the file to the model as a string. */
        // @DataMember(Name="file_data")
        /** @var string */
        public string $file_data='',

        /** @description The name of the file, used when passing the file to the model as a string. */
        // @DataMember(Name="filename")
        /** @var string */
        public string $filename='',

        /** @description The ID of an uploaded file to use as input. */
        // @DataMember(Name="file_id")
        /** @var string|null */
        public ?string $file_id=null
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['file_data'])) $this->file_data = $o['file_data'];
        if (isset($o['filename'])) $this->filename = $o['filename'];
        if (isset($o['file_id'])) $this->file_id = $o['file_id'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->file_data)) $o['file_data'] = $this->file_data;
        if (isset($this->filename)) $o['filename'] = $this->filename;
        if (isset($this->file_id)) $o['file_id'] = $this->file_id;
        return empty($o) ? new class(){} : $o;
    }
}

/** @description File content part */
// @DataContract
class AiFileContent extends AiContent implements JsonSerializable
{
    /**
     * @param string $type
     */
    public function __construct(
        string $type='',
        /** @description The file input for this content. */
        // @DataMember(Name="file")
        /** @var AiFile|null */
        public ?AiFile $file=null
    ) {
        parent::__construct($type);
    }

    /** @throws Exception */
    public function fromMap($o): void {
        parent::fromMap($o);
        if (isset($o['file'])) $this->file = JsonConverters::from('AiFile', $o['file']);
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = parent::jsonSerialize();
        if (isset($this->file)) $o['file'] = JsonConverters::to('AiFile', $this->file);
        return empty($o) ? new class(){} : $o;
    }
}

// @DataContract
class ChatResponse implements JsonSerializable
{
    public function __construct(
        /** @description A unique identifier for the chat completion. */
        // @DataMember(Name="id")
        /** @var string */
        public string $id='',

        /** @description A list of chat completion choices. Can be more than one if n is greater than 1. */
        // @DataMember(Name="choices")
        /** @var array<Choice>|null */
        public ?array $choices=null,

        /** @description The Unix timestamp (in seconds) of when the chat completion was created. */
        // @DataMember(Name="created")
        /** @var int */
        public int $created=0,

        /** @description The model used for the chat completion. */
        // @DataMember(Name="model")
        /** @var string */
        public string $model='',

        /** @description This fingerprint represents the backend configuration that the model runs with. */
        // @DataMember(Name="system_fingerprint")
        /** @var string|null */
        public ?string $system_fingerprint=null,

        /** @description The object type, which is always chat.completion. */
        // @DataMember(Name="object")
        /** @var string */
        public string $object='',

        /** @description Specifies the processing type used for serving the request. */
        // @DataMember(Name="service_tier")
        /** @var string|null */
        public ?string $service_tier=null,

        /** @description Usage statistics for the completion request. */
        // @DataMember(Name="usage")
        /** @var AiUsage|null */
        public ?AiUsage $usage=null,

        /** @description Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. */
        // @DataMember(Name="metadata")
        /** @var array<string,string>|null */
        public ?array $metadata=null,

        // @DataMember(Name="responseStatus")
        /** @var ResponseStatus|null */
        public ?ResponseStatus $responseStatus=null
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['id'])) $this->id = $o['id'];
        if (isset($o['choices'])) $this->choices = JsonConverters::fromArray('Choice', $o['choices']);
        if (isset($o['created'])) $this->created = $o['created'];
        if (isset($o['model'])) $this->model = $o['model'];
        if (isset($o['system_fingerprint'])) $this->system_fingerprint = $o['system_fingerprint'];
        if (isset($o['object'])) $this->object = $o['object'];
        if (isset($o['service_tier'])) $this->service_tier = $o['service_tier'];
        if (isset($o['usage'])) $this->usage = JsonConverters::from('AiUsage', $o['usage']);
        if (isset($o['metadata'])) $this->metadata = JsonConverters::from(JsonConverters::context('Dictionary',genericArgs:['string','string']), $o['metadata']);
        if (isset($o['responseStatus'])) $this->responseStatus = JsonConverters::from('ResponseStatus', $o['responseStatus']);
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->id)) $o['id'] = $this->id;
        if (isset($this->choices)) $o['choices'] = JsonConverters::toArray('Choice', $this->choices);
        if (isset($this->created)) $o['created'] = $this->created;
        if (isset($this->model)) $o['model'] = $this->model;
        if (isset($this->system_fingerprint)) $o['system_fingerprint'] = $this->system_fingerprint;
        if (isset($this->object)) $o['object'] = $this->object;
        if (isset($this->service_tier)) $o['service_tier'] = $this->service_tier;
        if (isset($this->usage)) $o['usage'] = JsonConverters::to('AiUsage', $this->usage);
        if (isset($this->metadata)) $o['metadata'] = JsonConverters::to(JsonConverters::context('Dictionary',genericArgs:['string','string']), $this->metadata);
        if (isset($this->responseStatus)) $o['responseStatus'] = JsonConverters::to('ResponseStatus', $this->responseStatus);
        return empty($o) ? new class(){} : $o;
    }
}

/** @description Chat Completions API (OpenAI-Compatible) */
// @Route("/v1/chat/completions", "POST")
// @DataContract
#[Returns('ChatResponse')]
class ChatCompletion implements IReturn, IPost, JsonSerializable
{
    public function __construct(
        /** @description The messages to generate chat completions for. */
        // @DataMember(Name="messages")
        /** @var array<AiMessage>|null */
        public ?array $messages=null,

        /** @description ID of the model to use. See the model endpoint compatibility table for details on which models work with the Chat API */
        // @DataMember(Name="model")
        /** @var string */
        public string $model='',

        /** @description Parameters for audio output. Required when audio output is requested with modalities: [audio] */
        // @DataMember(Name="audio")
        /** @var AiChatAudio|null */
        public ?AiChatAudio $audio=null,

        /** @description Modify the likelihood of specified tokens appearing in the completion. */
        // @DataMember(Name="logit_bias")
        /** @var array<string,int>|null */
        public ?array $logit_bias=null,

        /** @description Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. */
        // @DataMember(Name="metadata")
        /** @var array<string,string>|null */
        public ?array $metadata=null,

        /** @description Constrains effort on reasoning for reasoning models. Currently supported values are minimal, low, medium, and high (none, default). Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response. */
        // @DataMember(Name="reasoning_effort")
        /** @var string|null */
        public ?string $reasoning_effort=null,

        /** @description An object specifying the format that the model must output. Compatible with GPT-4 Turbo and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`. Setting Type to ResponseFormat.JsonObject enables JSON mode, which guarantees the message the model generates is valid JSON. */
        // @DataMember(Name="response_format")
        /** @var AiResponseFormat|null */
        public ?AiResponseFormat $response_format=null,

        /** @description Specifies the processing type used for serving the request. */
        // @DataMember(Name="service_tier")
        /** @var string|null */
        public ?string $service_tier=null,

        /** @description A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies. The IDs should be a string that uniquely identifies each user. */
        // @DataMember(Name="safety_identifier")
        /** @var string|null */
        public ?string $safety_identifier=null,

        /** @description Up to 4 sequences where the API will stop generating further tokens. */
        // @DataMember(Name="stop")
        /** @var array<string>|null */
        public ?array $stop=null,

        /** @description Output types that you would like the model to generate. Most models are capable of generating text, which is the default: */
        // @DataMember(Name="modalities")
        /** @var array<string>|null */
        public ?array $modalities=null,

        /** @description Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. */
        // @DataMember(Name="prompt_cache_key")
        /** @var string|null */
        public ?string $prompt_cache_key=null,

        /** @description A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported. */
        // @DataMember(Name="tools")
        /** @var array<Tool>|null */
        public ?array $tools=null,

        /** @description Constrains the verbosity of the model's response. Lower values will result in more concise responses, while higher values will result in more verbose responses. Currently supported values are low, medium, and high. */
        // @DataMember(Name="verbosity")
        /** @var string|null */
        public ?string $verbosity=null,

        /** @description What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. */
        // @DataMember(Name="temperature")
        /** @var float|null */
        public ?float $temperature=null,

        /** @description An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens. */
        // @DataMember(Name="max_completion_tokens")
        /** @var int|null */
        public ?int $max_completion_tokens=null,

        /** @description An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used. */
        // @DataMember(Name="top_logprobs")
        /** @var int|null */
        public ?int $top_logprobs=null,

        /** @description An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered. */
        // @DataMember(Name="top_p")
        /** @var float|null */
        public ?float $top_p=null,

        /** @description Number between `-2.0` and `2.0`. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. */
        // @DataMember(Name="frequency_penalty")
        /** @var float|null */
        public ?float $frequency_penalty=null,

        /** @description Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics. */
        // @DataMember(Name="presence_penalty")
        /** @var float|null */
        public ?float $presence_penalty=null,

        /** @description This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result. Determinism is not guaranteed, and you should refer to the system_fingerprint response parameter to monitor changes in the backend. */
        // @DataMember(Name="seed")
        /** @var int|null */
        public ?int $seed=null,

        /** @description How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs. */
        // @DataMember(Name="n")
        /** @var int|null */
        public ?int $n=null,

        /** @description Whether or not to store the output of this chat completion request for use in our model distillation or evals products. */
        // @DataMember(Name="store")
        /** @var bool|null */
        public ?bool $store=null,

        /** @description Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message. */
        // @DataMember(Name="logprobs")
        /** @var bool|null */
        public ?bool $logprobs=null,

        /** @description Whether to enable parallel function calling during tool use. */
        // @DataMember(Name="parallel_tool_calls")
        /** @var bool|null */
        public ?bool $parallel_tool_calls=null,

        /** @description Whether to enable thinking mode for some Qwen models and providers. */
        // @DataMember(Name="enable_thinking")
        /** @var bool|null */
        public ?bool $enable_thinking=null,

        /** @description If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a `data: [DONE]` message. */
        // @DataMember(Name="stream")
        /** @var bool|null */
        public ?bool $stream=null
    ) {
    }

    /** @throws Exception */
    public function fromMap($o): void {
        if (isset($o['messages'])) $this->messages = JsonConverters::fromArray('AiMessage', $o['messages']);
        if (isset($o['model'])) $this->model = $o['model'];
        if (isset($o['audio'])) $this->audio = JsonConverters::from('AiChatAudio', $o['audio']);
        if (isset($o['logit_bias'])) $this->logit_bias = JsonConverters::from(JsonConverters::context('Dictionary',genericArgs:['int','int']), $o['logit_bias']);
        if (isset($o['metadata'])) $this->metadata = JsonConverters::from(JsonConverters::context('Dictionary',genericArgs:['string','string']), $o['metadata']);
        if (isset($o['reasoning_effort'])) $this->reasoning_effort = $o['reasoning_effort'];
        if (isset($o['response_format'])) $this->response_format = JsonConverters::from('AiResponseFormat', $o['response_format']);
        if (isset($o['service_tier'])) $this->service_tier = $o['service_tier'];
        if (isset($o['safety_identifier'])) $this->safety_identifier = $o['safety_identifier'];
        if (isset($o['stop'])) $this->stop = JsonConverters::fromArray('string', $o['stop']);
        if (isset($o['modalities'])) $this->modalities = JsonConverters::fromArray('string', $o['modalities']);
        if (isset($o['prompt_cache_key'])) $this->prompt_cache_key = $o['prompt_cache_key'];
        if (isset($o['tools'])) $this->tools = JsonConverters::fromArray('Tool', $o['tools']);
        if (isset($o['verbosity'])) $this->verbosity = $o['verbosity'];
        if (isset($o['temperature'])) $this->temperature = $o['temperature'];
        if (isset($o['max_completion_tokens'])) $this->max_completion_tokens = $o['max_completion_tokens'];
        if (isset($o['top_logprobs'])) $this->top_logprobs = $o['top_logprobs'];
        if (isset($o['top_p'])) $this->top_p = $o['top_p'];
        if (isset($o['frequency_penalty'])) $this->frequency_penalty = $o['frequency_penalty'];
        if (isset($o['presence_penalty'])) $this->presence_penalty = $o['presence_penalty'];
        if (isset($o['seed'])) $this->seed = $o['seed'];
        if (isset($o['n'])) $this->n = $o['n'];
        if (isset($o['store'])) $this->store = $o['store'];
        if (isset($o['logprobs'])) $this->logprobs = $o['logprobs'];
        if (isset($o['parallel_tool_calls'])) $this->parallel_tool_calls = $o['parallel_tool_calls'];
        if (isset($o['enable_thinking'])) $this->enable_thinking = $o['enable_thinking'];
        if (isset($o['stream'])) $this->stream = $o['stream'];
    }
    
    /** @throws Exception */
    public function jsonSerialize(): mixed
    {
        $o = [];
        if (isset($this->messages)) $o['messages'] = JsonConverters::toArray('AiMessage', $this->messages);
        if (isset($this->model)) $o['model'] = $this->model;
        if (isset($this->audio)) $o['audio'] = JsonConverters::to('AiChatAudio', $this->audio);
        if (isset($this->logit_bias)) $o['logit_bias'] = JsonConverters::to(JsonConverters::context('Dictionary',genericArgs:['int','int']), $this->logit_bias);
        if (isset($this->metadata)) $o['metadata'] = JsonConverters::to(JsonConverters::context('Dictionary',genericArgs:['string','string']), $this->metadata);
        if (isset($this->reasoning_effort)) $o['reasoning_effort'] = $this->reasoning_effort;
        if (isset($this->response_format)) $o['response_format'] = JsonConverters::to('AiResponseFormat', $this->response_format);
        if (isset($this->service_tier)) $o['service_tier'] = $this->service_tier;
        if (isset($this->safety_identifier)) $o['safety_identifier'] = $this->safety_identifier;
        if (isset($this->stop)) $o['stop'] = JsonConverters::toArray('string', $this->stop);
        if (isset($this->modalities)) $o['modalities'] = JsonConverters::toArray('string', $this->modalities);
        if (isset($this->prompt_cache_key)) $o['prompt_cache_key'] = $this->prompt_cache_key;
        if (isset($this->tools)) $o['tools'] = JsonConverters::toArray('Tool', $this->tools);
        if (isset($this->verbosity)) $o['verbosity'] = $this->verbosity;
        if (isset($this->temperature)) $o['temperature'] = $this->temperature;
        if (isset($this->max_completion_tokens)) $o['max_completion_tokens'] = $this->max_completion_tokens;
        if (isset($this->top_logprobs)) $o['top_logprobs'] = $this->top_logprobs;
        if (isset($this->top_p)) $o['top_p'] = $this->top_p;
        if (isset($this->frequency_penalty)) $o['frequency_penalty'] = $this->frequency_penalty;
        if (isset($this->presence_penalty)) $o['presence_penalty'] = $this->presence_penalty;
        if (isset($this->seed)) $o['seed'] = $this->seed;
        if (isset($this->n)) $o['n'] = $this->n;
        if (isset($this->store)) $o['store'] = $this->store;
        if (isset($this->logprobs)) $o['logprobs'] = $this->logprobs;
        if (isset($this->parallel_tool_calls)) $o['parallel_tool_calls'] = $this->parallel_tool_calls;
        if (isset($this->enable_thinking)) $o['enable_thinking'] = $this->enable_thinking;
        if (isset($this->stream)) $o['stream'] = $this->stream;
        return empty($o) ? new class(){} : $o;
    }
    public function getTypeName(): string { return 'ChatCompletion'; }
    public function getMethod(): string { return 'POST'; }
    public function createResponse(): mixed { return new ChatResponse(); }
}

