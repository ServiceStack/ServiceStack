<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MsgPack</name>
    </assembly>
    <members>
        <member name="T:MsgPack.Serialization.SerializerBuilder`1">
            <summary>
            	Build serializer for <typeparamref name="TObject"/>.
            </summary>
            <typeparam name="TObject">Object to be serialized/deserialized.</typeparam>
        </member>
        <member name="M:MsgPack.Serialization.SerializerBuilder`1.#ctor(MsgPack.Serialization.SerializationContext)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.SerializerBuilder`1"/> class.
            </summary>
            <param name="context">The <see cref="T:MsgPack.Serialization.SerializationContext"/>.</param>
        </member>
        <member name="M:MsgPack.Serialization.SerializerBuilder`1.CreateSerializer">
            <summary>
            	Creates serializer for <typeparamref name="TObject"/>.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>. This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializerBuilder`1.CreateSerializer(MsgPack.Serialization.SerializingMember[])">
            <summary>
            	Creates serializer for <typeparamref name="TObject"/>.
            </summary>
            <param name="entries">Serialization target members. This will not be <c>null</c> nor empty.</param>
            <returns>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>. This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializerBuilder`1.CreateArraySerializer">
            <summary>
            	Creates serializer as <typeparamref name="TObject"/> is array type.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>. 
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializerBuilder`1.CreateMapSerializer">
            <summary>
            	Creates serializer as <typeparamref name="TObject"/> is map type.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>. 
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializerBuilder`1.CreateTupleSerializer">
            <summary>
            	Creates serializer as <typeparamref name="TObject"/> is tuple type.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>. 
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="P:MsgPack.Serialization.SerializerBuilder`1.Context">
            <summary>
            	Gets the <see cref="T:MsgPack.Serialization.SerializationContext"/>.
            </summary>
            <value>
            	The <see cref="T:MsgPack.Serialization.SerializationContext"/>.
            </value>
        </member>
        <member name="T:MsgPack.Serialization.SerializationExceptions">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Defines common exception factory methods.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewValueTypeCannotBeNull(System.String,System.Type,System.Type)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that value type cannot be <c>null</c> on deserialization.
            </summary>
            <param name="name">The name of the member.</param>
            <param name="memberType">The type of the member.</param>
            <param name="declaringType">The type that declares the member.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewValueTypeCannotBeNull(System.Type)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that value type cannot be <c>null</c> on deserialization.
            </summary>
            <param name="type">The target type.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="F:MsgPack.Serialization.SerializationExceptions.NewTypeCannotSerializeMethod">
            <summary>
            	<see cref="T:System.Reflection.MethodInfo"/> of <see cref="M:MsgPack.Serialization.SerializationExceptions.NewTypeCannotSerialize(System.Type)"/> method.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewTypeCannotSerialize(System.Type)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that value type cannot serialize.
            </summary>
            <param name="type">The target type.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="F:MsgPack.Serialization.SerializationExceptions.NewTypeCannotDeserializeMethod">
            <summary>
            	<see cref="T:System.Reflection.MethodInfo"/> of <see cref="M:MsgPack.Serialization.SerializationExceptions.NewTypeCannotDeserialize(System.Type)"/> method.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewTypeCannotDeserialize(System.Type)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that value type cannot deserialize.
            </summary>
            <param name="type">The target type.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="F:MsgPack.Serialization.SerializationExceptions.NewMissingItemMethod">
            <summary>
            	<see cref="T:System.Reflection.MethodInfo"/> of <see cref="M:MsgPack.Serialization.SerializationExceptions.NewMissingItem(System.Int32)"/> method.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewMissingItem(System.Int32)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that item is not found on the unpacking stream.
            </summary>
            <param name="index">The index to be unpacking.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewTargetDoesNotHavePublicDefaultConstructor(System.Type)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that target type is not serializable because it does not have public default constructor.
            </summary>
            <param name="type">The target type.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewTargetDoesNotHavePublicDefaultConstructorNorInitialCapacity(System.Type)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that target type is not serializable because it does not have both of public default constructor and public constructor with an Int32 parameter.
            </summary>
            <param name="type">The target type.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewNoSerializableFieldsException(System.Type)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that there are no serializable fields and properties on the target type.
            </summary>
            <param name="type">The target type.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="F:MsgPack.Serialization.SerializationExceptions.NewMissingPropertyMethod">
            <summary>
            	<see cref="T:System.Reflection.MethodInfo"/> of <see cref="M:MsgPack.Serialization.SerializationExceptions.NewMissingProperty(System.String)"/> method.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewMissingProperty(System.String)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that required field is not found on the unpacking stream.
            </summary>
            <param name="name">The name of the property.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="F:MsgPack.Serialization.SerializationExceptions.NewUnexpectedEndOfStreamMethod">
            <summary>
            	<see cref="T:System.Reflection.MethodInfo"/> of <see cref="M:MsgPack.Serialization.SerializationExceptions.NewUnexpectedEndOfStream"/> method.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewUnexpectedEndOfStream">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that unpacking stream ends on unexpectedly position.
            </summary>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewMissingAddMethod(System.Type)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that target collection type does not declare appropriate Add(T) method.
            </summary>
            <param name="type">The target type.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewIsNotArrayHeader">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that unpacker is not in the array header, that is the state is invalid.
            </summary>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewIsNotMapHeader">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that unpacker is not in the array header, that is the state is invalid.
            </summary>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewNotSupportedBecauseCannotInstanciateAbstractType(System.Type)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that operation is not supported because <paramref name="type"/> cannot be instanciated.
            </summary>
            <param name="type">Type.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewTupleCardinarityIsNotMatch(System.Int32,System.Int32)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that the array length does not match to expected tuple cardinality.
            </summary>
            <param name="expectedTupleCardinality">The expected cardinality of the tuple.</param>
            <param name="actualArrayLength">The actual serialized array length.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewIsIncorrectStream(System.Exception)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that the underlying stream is not correct semantically because failed to unpack items count of array/map.
            </summary>
            <param name="innerException">The inner exception for the debug. The value is implementation specific.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewIsTooLargeCollection">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that the unpacking collection is too large to represents in the current runtime environment.
            </summary>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewEmptyOrUnstartedUnpacker">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that the the unpacker does not contain any data because the underlying stream is empty or unpacker has not been started.
            </summary>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewNullIsProhibited(System.String)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that the member cannot be <c>null</c> or the unpacking value cannot be nil because nil value is explicitly prohibitted.
            </summary>
            <param name="memberName">The name of the member.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewReadOnlyMemberItemsMustNotBeNull(System.String)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that the unpacking value cannot be nil because the target member is read only and its type is collection.
            </summary>
            <param name="memberName">The name of the member.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewStreamDoesNotContainCollectionForMember(System.String)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that the unpacking collection value is not a collection.
            </summary>
            <param name="memberName">The name of the member.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializationExceptions.NewUnexpectedArrayLength(System.Int32,System.Int32)">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Returns new exception to notify that the unpacking array size is not expected length.
            </summary>
            <param name="expectedLength">Expected, required for deserialization array length.</param>
            <param name="actualLength">Actual array length.</param>
            <returns><see cref="T:System.Exception"/> instance. It will not be <c>null</c>.</returns>
        </member>
        <member name="T:MsgPack.Serialization.SerializingMember">
            <summary>
            	Represents serializing member information.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.Emittion.EmitFor(MsgPack.Serialization.Reflection.TracingILGenerator,System.Reflection.Emit.LocalBuilder,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator,System.Reflection.Emit.LocalBuilder})">
            <summary>
            	Emits 'for' statement on current IL stream.
            </summary>
            <param name="il">IL generator to be emitted to.</param>
            <param name="count">'count' local variable which is <see cref="T:System.Int32"/> type and holds maximum loop count.</param>
            <param name="bodyEmitter">Delegate to emit for statement body.</param>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.Emittion.EmitForEach(MsgPack.Serialization.Reflection.TracingILGenerator,MsgPack.Serialization.CollectionTraits,System.Reflection.Emit.LocalBuilder,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator,System.Action})">
            <summary>
            	Emits 'foreach' statement on the IL stream.
            </summary>
            <param name="il">IL generator to be emitted to.</param>
            <param name="traits"><see cref="T:MsgPack.Serialization.CollectionTraits"/> which contains traits of the iterating collection.</param>
            <param name="collection">'collection' argument index.</param>
            <param name="bodyEmitter">Delegate to emit body statement.</param>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.Emittion.EmitLoadValue(MsgPack.Serialization.Reflection.TracingILGenerator,System.Reflection.MemberInfo)">
            <summary>
            	Emits appropriate loading member instructions.
            </summary>
            <param name="il">IL generator to be emitted to.</param>
            <param name="member"><see cref="T:System.Reflection.MemberInfo"/> to be loaded.</param>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.Emittion.EmitStoreValue(MsgPack.Serialization.Reflection.TracingILGenerator,System.Reflection.MemberInfo)">
            <summary>
            	Emits appropriate storing member instructions.
            </summary>
            <param name="il">IL generator to be emitted to.</param>
            <param name="member"><see cref="T:System.Reflection.MemberInfo"/> to be stored.</param>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.Emittion.EmitGetUnpackerItemsCountAsInt32(MsgPack.Serialization.Reflection.TracingILGenerator,System.Int32)">
            <summary>
            Emits gets <see cref="P:MsgPack.Unpacker.ItemsCount"/> with exception handling.
            Note that final state is the value is pushed top of the evaluation stack.
            </summary>
            <param name="il">IL generator.</param>
            <param name="unpackerArgumentIndex">Argument index of the unpacker.</param>
        </member>
        <member name="T:MsgPack.Serialization.DataMemberContract">
            <summary>
            	Represents member's data contract.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.DataMemberContract.#ctor(System.Reflection.MemberInfo)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.DataMemberContract"/> struct.
            </summary>
            <param name="member">The target member.</param>
        </member>
        <member name="M:MsgPack.Serialization.DataMemberContract.#ctor(System.Reflection.MemberInfo,System.Runtime.Serialization.DataMemberAttribute)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.DataMemberContract"/> struct from <see cref="T:System.Runtime.Serialization.DataMemberAttribute"/>.
            </summary>
            <param name="member">The target member.</param>
            <param name="attribute">The data contract member attribute. This value can be <c>null</c>.</param>
        </member>
        <member name="M:MsgPack.Serialization.DataMemberContract.#ctor(System.Reflection.MemberInfo,MsgPack.Serialization.MessagePackMemberAttribute)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.DataMemberContract"/> struct from <see cref="T:MsgPack.Serialization.MessagePackMemberAttribute"/>.
            </summary>
            <param name="member">The target member.</param>
            <param name="attribute">The MessagePack member attribute. This value can be <c>null</c>.</param>
        </member>
        <member name="P:MsgPack.Serialization.DataMemberContract.Name">
            <summary>
            	Gets the name of the member.
            </summary>
            <value>
            	The name of the member.
            </value>
            <seealso cref="T:System.Runtime.Serialization.DataMemberAttribute"/>
        </member>
        <member name="P:MsgPack.Serialization.DataMemberContract.Id">
            <summary>
            	Gets the ID of the member.
            </summary>
            <value>
            	The ID of the member. Default is <c>-1</c>.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.DataMemberContract.NilImplication">
            <summary>
            	Gets the nil implication.
            </summary>
            <value>
            	The nil implication.
            </value>
        </member>
        <member name="T:MsgPack.UnpackException">
            <summary>
            	Represents generic unpacking error.
            </summary>
        </member>
        <member name="M:MsgPack.UnpackException.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.UnpackException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:MsgPack.UnpackException.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.UnpackException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:MsgPack.UnpackException.#ctor(System.String,System.Exception)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.UnpackException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="inner">
            	The exception that is the cause of the current exception, or a <c>null</c> if no inner exception is specified.
            </param>
        </member>
        <member name="M:MsgPack.UnpackException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.UnpackException"/> class with serialized data.
            </summary>
            <param name="info">
            	The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.
            </param>
            <param name="context">
            	The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            	The <paramref name="info"/> parameter is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	The class name is <c>null</c> or <see cref="P:HResult"/> is zero (0).
            </exception>
        </member>
        <member name="T:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilderLogics">
            <summary>
            	Defines non-generic functions of <see cref="T:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilder`1"/>.
            </summary>
        </member>
        <member name="T:MsgPack.Serialization.MessagePackSerializer`1">
            <summary>
            	Defines base contract for object serialization.
            </summary>
            <typeparam name="T">Target type.</typeparam>
            <remarks>
            	<para>
            		This class implements strongly typed serialization and deserialization.
            	</para>
            	<para>
            		When the underlying stream does not contain strongly typed or contains dynamically typed objects,
            		you should use <see cref="T:MsgPack.Unpacker"/> directly and take advantage of <see cref="T:MsgPack.MessagePackObject"/>.
            	</para>
            </remarks>
            <seealso cref="T:MsgPack.Unpacker"/>
            <seealso cref="T:MsgPack.Unpacking"/>
        </member>
        <member name="T:MsgPack.Serialization.IMessagePackSerializer">
            <summary>
            	Defines non-generic message pack serializer interface.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.IMessagePackSerializer.PackTo(MsgPack.Packer,System.Object)">
            <summary>
            	Serialize specified object with specified <see cref="T:MsgPack.Packer"/>.
            </summary>
            <param name="packer"><see cref="T:MsgPack.Packer"/> which packs values in <paramref name="objectTree"/>.</param>
            <param name="objectTree">Object to be serialized.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="packer"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="objectTree"/> is not compatible for this serializer.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	The type of <paramref name="objectTree"/> is not serializable etc.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.IMessagePackSerializer.UnpackFrom(MsgPack.Unpacker)">
            <summary>
            	Deserialize object with specified <see cref="T:MsgPack.Unpacker"/>.
            </summary>
            <param name="unpacker"><see cref="T:MsgPack.Unpacker"/> which unpacks values of resulting object tree.</param>
            <returns>Deserialized object.</returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="unpacker"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Failed to deserialize object due to invalid unpacker state, stream content, or so.
            </exception>
            <exception cref="T:System.NotSupportedException">
            	Deserializing type is abstract type.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.IMessagePackSerializer.UnpackTo(MsgPack.Unpacker,System.Object)">
            <summary>
            	Deserialize collection items with specified <see cref="T:MsgPack.Unpacker"/> and stores them to <paramref name="collection"/>.
            </summary>
            <param name="unpacker"><see cref="T:MsgPack.Unpacker"/> which unpacks values of resulting object tree.</param>
            <param name="collection">Collection that the items to be stored.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="unpacker"/> is <c>null</c>.
            	Or <paramref name="collection"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="collection"/> is not compatible for this serializer.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Failed to deserialize object due to invalid unpacker state, stream content, or so.
            </exception>
            <exception cref="T:System.NotSupportedException">
            	The type of <paramref name="collection"/> is not serializable etc.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer`1.Pack(System.IO.Stream,`0)">
            <summary>
            	Serialize specified object to the <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">Destination <see cref="T:System.IO.Stream"/>.</param>
            <param name="objectTree">Object to be serialized.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="stream"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	<typeparamref name="T"/> is not serializable etc.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer`1.Unpack(System.IO.Stream)">
            <summary>
            	Deserialize object from the <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">Source <see cref="T:System.IO.Stream"/>.</param>
            <returns>Deserialized object.</returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="stream"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	<typeparamref name="T"/> is not serializable etc.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer`1.PackTo(MsgPack.Packer,`0)">
            <summary>
            	Serialize specified object with specified <see cref="T:MsgPack.Packer"/>.
            </summary>
            <param name="packer"><see cref="T:MsgPack.Packer"/> which packs values in <paramref name="objectTree"/>.</param>
            <param name="objectTree">Object to be serialized.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="packer"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	<typeparamref name="T"/> is not serializable etc.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer`1.PackToCore(MsgPack.Packer,`0)">
            <summary>
            	Serialize specified object with specified <see cref="T:MsgPack.Packer"/>.
            </summary>
            <param name="packer"><see cref="T:MsgPack.Packer"/> which packs values in <paramref name="objectTree"/>. This value will not be <c>null</c>.</param>
            <param name="objectTree">Object to be serialized.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	<typeparamref name="T"/> is not serializable etc.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer`1.UnpackFrom(MsgPack.Unpacker)">
            <summary>
            	Deserialize object with specified <see cref="T:MsgPack.Unpacker"/>.
            </summary>
            <param name="unpacker"><see cref="T:MsgPack.Unpacker"/> which unpacks values of resulting object tree.</param>
            <returns>Deserialized object.</returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="unpacker"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Failed to deserialize object due to invalid unpacker state, stream content, or so.
            </exception>
            <exception cref="T:System.NotSupportedException">
            	<typeparamref name="T"/> is abstract type.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer`1.UnpackFromCore(MsgPack.Unpacker)">
            <summary>
            	Deserialize object with specified <see cref="T:MsgPack.Unpacker"/>.
            </summary>
            <param name="unpacker"><see cref="T:MsgPack.Unpacker"/> which unpacks values of resulting object tree. This value will not be <c>null</c>.</param>
            <returns>Deserialized object.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Failed to deserialize object due to invalid unpacker state, stream content, or so.
            </exception>
            <exception cref="T:System.NotSupportedException">
            	<typeparamref name="T"/> is abstract type.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer`1.UnpackTo(MsgPack.Unpacker,`0)">
            <summary>
            	Deserialize collection items with specified <see cref="T:MsgPack.Unpacker"/> and stores them to <paramref name="collection"/>.
            </summary>
            <param name="unpacker"><see cref="T:MsgPack.Unpacker"/> which unpacks values of resulting object tree.</param>
            <param name="collection">Collection that the items to be stored.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="unpacker"/> is <c>null</c>.
            	Or <paramref name="collection"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Failed to deserialize object due to invalid unpacker state, stream content, or so.
            </exception>
            <exception cref="T:System.NotSupportedException">
            	<typeparamref name="T"/> is not collection.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer`1.UnpackToCore(MsgPack.Unpacker,`0)">
            <summary>
            	Deserialize collection items with specified <see cref="T:MsgPack.Unpacker"/> and stores them to <paramref name="collection"/>.
            </summary>
            <param name="unpacker"><see cref="T:MsgPack.Unpacker"/> which unpacks values of resulting object tree. This value will not be <c>null</c>.</param>
            <param name="collection">Collection that the items to be stored. This value will not be <c>null</c>.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Failed to deserialize object due to invalid unpacker state, stream content, or so.
            </exception>
            <exception cref="T:System.NotSupportedException">
            	<typeparamref name="T"/> is not collection.
            </exception>
        </member>
        <member name="T:MsgPack.Serialization.AutoMessagePackSerializer`1">
            <summary>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> based on reflection, opt-out based.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MsgPack.Serialization.AutoMessagePackSerializer`1.#ctor(MsgPack.Serialization.SerializationContext,System.Func{MsgPack.Serialization.SerializationContext,MsgPack.Serialization.SerializerBuilder{`0}})">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.AutoMessagePackSerializer`1"/> class.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.AutoMessagePackSerializer`1.PackToCore(MsgPack.Packer,`0)">
            <summary>
            	Serialize specified object with specified <see cref="T:MsgPack.Packer"/>.
            </summary>
            <param name="packer"><see cref="T:MsgPack.Packer"/> which packs values in <paramref name="objectTree"/>. This value will not be <c>null</c>.</param>
            <param name="objectTree">Object to be serialized.</param>
        </member>
        <member name="M:MsgPack.Serialization.AutoMessagePackSerializer`1.UnpackFromCore(MsgPack.Unpacker)">
            <summary>
            	Deserialize object with specified <see cref="T:MsgPack.Unpacker"/>.
            </summary>
            <param name="unpacker"><see cref="T:MsgPack.Unpacker"/> which unpacks values of resulting object tree. This value will not be <c>null</c>.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="M:MsgPack.Serialization.AutoMessagePackSerializer`1.UnpackToCore(MsgPack.Unpacker,`0)">
            <summary>
            	Deserialize collection items with specified <see cref="T:MsgPack.Unpacker"/> and stores them to <paramref name="collection"/>.
            </summary>
            <param name="unpacker"><see cref="T:MsgPack.Unpacker"/> which unpacks values of resulting object tree. This value will not be <c>null</c>.</param>
            <param name="collection">Collection that the items to be stored. This value will not be <c>null</c>.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Failed to deserialize object due to invalid unpacker state, stream content, or so.
            </exception>
            <exception cref="T:System.NotSupportedException">
            	<typeparamref name="T"/> is not collection.
            </exception>
        </member>
        <member name="T:MsgPack.Serialization.ExpressionSerializers.SequenceExpressionMessagePackSerializer`1">
            <summary>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> for a sequential collection using expression tree.
            </summary>
            <typeparam name="T">The type of element.</typeparam>
        </member>
        <member name="T:MsgPack.Serialization.ExpressionSerializers.ArrayFormatObjectExpressionMessagePackSerializer`1">
            <summary>
            	<see cref="T:MsgPack.Serialization.ExpressionSerializers.ObjectExpressionMessagePackSerializer`1"/> for array format stream.
            </summary>
            <typeparam name="T">The type of target type.</typeparam>
        </member>
        <member name="T:MsgPack.Serialization.ExpressionSerializers.ObjectExpressionMessagePackSerializer`1">
            <summary>
            	Implements expression tree based serializer for general object.
            </summary>
            <typeparam name="T">The type of target object.</typeparam>
        </member>
        <member name="T:MsgPack.PackerUnpackerExtensions">
            <summary>
            	Defines extension method to pack or unpack various objects.
            </summary>
        </member>
        <member name="M:MsgPack.PackerUnpackerExtensions.Pack``1(MsgPack.Packer,``0)">
            <summary>
            	Packs specified value with the default context.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="source">The <see cref="T:MsgPack.Packer"/>.</param>
            <param name="value">The value to be serialized.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Cannot serialize <paramref name="value"/>.
            </exception>
        </member>
        <member name="M:MsgPack.PackerUnpackerExtensions.Pack``1(MsgPack.Packer,``0,MsgPack.Serialization.SerializationContext)">
            <summary>
            	Packs specified value with the specified context.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="source">The <see cref="T:MsgPack.Packer"/>.</param>
            <param name="value">The value to be serialized.</param>
            <param name="context">The <see cref="T:MsgPack.Serialization.SerializationContext"/> holds shared serializers.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            	Or <paramref name="context"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Cannot serialize <paramref name="value"/>.
            </exception>
        </member>
        <member name="M:MsgPack.PackerUnpackerExtensions.PackObject(MsgPack.Packer,System.Object)">
            <summary>
            	Packs specified value with the default context.
            </summary>
            <param name="source">The <see cref="T:MsgPack.Packer"/>.</param>
            <param name="value">The value to be serialized.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Cannot serialize <paramref name="value"/>.
            </exception>
        </member>
        <member name="M:MsgPack.PackerUnpackerExtensions.PackObject(MsgPack.Packer,System.Object,MsgPack.Serialization.SerializationContext)">
            <summary>
            	Packs specified value with the specified context.
            </summary>
            <param name="source">The <see cref="T:MsgPack.Packer"/>.</param>
            <param name="value">The value to be serialized.</param>
            <param name="context">The <see cref="T:MsgPack.Serialization.SerializationContext"/> holds shared serializers.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            	Or <paramref name="context"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Cannot serialize <paramref name="value"/>.
            </exception>
        </member>
        <member name="M:MsgPack.PackerUnpackerExtensions.Unpack``1(MsgPack.Unpacker)">
            <summary>
            	Unpacks specified type value with the default context.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="source">The <see cref="T:MsgPack.Unpacker"/>.</param>
            <returns>The deserialized value.</returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Cannot deserialize <typeparamref name="T"/> value.
            </exception>
        </member>
        <member name="M:MsgPack.PackerUnpackerExtensions.Unpack``1(MsgPack.Unpacker,MsgPack.Serialization.SerializationContext)">
            <summary>
            	Unpacks specified type value with the specified context.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="source">The <see cref="T:MsgPack.Unpacker"/>.</param>
            <param name="context">The <see cref="T:MsgPack.Serialization.SerializationContext"/> holds shared serializers.</param>
            <returns>The deserialized value.</returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            	Or <paramref name="context"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	Cannot deserialize <typeparamref name="T"/> value.
            </exception>
        </member>
        <member name="T:MsgPack.MessagePackConvert">
            <summary>
            	Define common convert rountines specific to MessagePack.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackConvert.EncodeString(System.String)">
            <summary>
            	Encode specified string by default encoding.
            </summary>
            <param name="value">String value.</param>
            <returns>Encoded <paramref name="value"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="value"/> is null.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackConvert.DecodeStringStrict(System.Byte[])">
            <summary>
            	Decode specified byte[] by default encoding.
            </summary>
            <param name="value">Byte[] value.</param>
            <returns>Decoded <paramref name="value"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="value"/> is null.
            </exception>
            <exception cref="T:System.Text.DecoderFallbackException">
            	<paramref name="value"/> contains non-UTF-8 bits.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackConvert.ToDateTimeOffset(System.Int64)">
            <summary>
            	Convert specified <see cref="T:System.Int64"/> to <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="value">
            	<see cref="T:System.Int64"/> value which is unpacked from packed message and may represent date-time value.
            </param>
            <returns>
            	<see cref="T:System.DateTimeOffset"/>. Offset of this value always 0.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackConvert.ToDateTime(System.Int64)">
            <summary>
            	Convert specified <see cref="T:System.Int64"/> to <see cref="T:System.DateTime"/>.
            </summary>
            <param name="value">
            	<see cref="T:System.Int64"/> value which is unpacked from packed message and may represent date-time value.
            </param>
            <returns>
            	<see cref="T:System.DateTime"/>. This value is always UTC.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackConvert.FromDateTimeOffset(System.DateTimeOffset)">
            <summary>
            	Convert specified <see cref="T:System.DateTimeOffset"/> to <see cref="T:System.Int64"/> as MessagePack defacto-standard.
            </summary>
            <param name="value"><see cref="T:System.DateTimeOffset"/>.</param>
            <returns>
            	UTC epoc time from 1970/1/1 0:00:00, in milliseconds.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackConvert.FromDateTime(System.DateTime)">
            <summary>
            	Convert specified <see cref="T:System.DateTime"/> to <see cref="T:System.Int64"/> as MessagePack defacto-standard.
            </summary>
            <param name="value"><see cref="T:System.DateTime"/>.</param>
            <returns>
            	UTC epoc time from 1970/1/1 0:00:00, in milliseconds.
            </returns>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary">
            <summary>
            	Implements <see cref="T:System.Collections.Generic.IDictionary`2"/> for <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <remarks>
            	This dictionary handles <see cref="T:MsgPack.MessagePackObject"/> type semantics for the key.
            	Additionally, this dictionary implements 'freezing' feature. 
            	For details, see <see cref="P:MsgPack.MessagePackObjectDictionary.IsFrozen"/>, <see cref="M:MsgPack.MessagePackObjectDictionary.Freeze"/>, and <see cref="M:MsgPack.MessagePackObjectDictionary.AsFrozen"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.#ctor">
            <summary>
            Initializes an empty new instance of the <see cref="T:MsgPack.MessagePackObjectDictionary"/> class with default capacity.
            </summary>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.#ctor(System.Int32)">
            <summary>
            Initializes an empty new instance of the <see cref="T:MsgPack.MessagePackObjectDictionary"/> class with specified initial capacity.
            </summary>
            <param name="initialCapacity">The initial capacity.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="initialCapacity"/> is negative.
            </exception>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.#ctor(System.Collections.Generic.IDictionary{MsgPack.MessagePackObject,MsgPack.MessagePackObject})">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObjectDictionary"/> class.
            </summary>
            <param name="dictionary">The dictionary to be copied from.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="dictionary"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	Failed to copy from <paramref name="dictionary"/>.
            </exception>
            <remarks>
            	This constructor takes <em>O(N)</em> time, <em>N</em> is <see cref="P:ICollection{T}.Count"/> of <paramref name="dictionary"/>.
            	Initial capacity will be <see cref="P:ICollection{T}.Count"/> of <paramref name="dictionary"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ContainsKey(MsgPack.MessagePackObject)">
            <summary>
            	Determines whether the <see cref="T:MsgPack.MessagePackObjectDictionary"/> contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is <see cref="F:MsgPack.MessagePackObject.Nil"/>.
            </exception>
            <returns>
            	<c>true</c> if the <see cref="T:MsgPack.MessagePackObjectDictionary"/> contains an element with the key; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	This method approaches an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ContainsValue(MsgPack.MessagePackObject)">
            <summary>
            	Determines whether the <see cref="T:MsgPack.MessagePackObjectDictionary"/> contains an element with the specified value.
            </summary>
            <param name="value">The value to locate in the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.</param>
            <returns>
            	<c>true</c> if the <see cref="T:MsgPack.MessagePackObjectDictionary"/> contains an element with the value; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	This method approaches an O(<em>N</em>) operation where <em>N</em> is <see cref="P:MsgPack.MessagePackObjectDictionary.Count"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.TryGetValue(MsgPack.MessagePackObject,MsgPack.MessagePackObject@)">
            <summary>
            	Gets the value associated with the specified key.
            </summary>
            <param name="key">
            	The key whose value to get.
            </param>
            <param name="value">
            	When this method returns, the value associated with the specified key, if the key is found; 
            	otherwise, the default value for the type of the <paramref name="value"/> parameter. 
            	This parameter is passed uninitialized.
            </param>
            <returns>
            	<c>true</c> if this dictionary contains an element with the specified key; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is <see cref="F:MsgPack.MessagePackObject.Nil"/>.
            </exception>
            <remarks>
            	<para>
            		Note that tiny integers are considered equal regardless of its CLI <see cref="T:System.Type"/>,
            		and UTF-8 encoded bytes are considered equals to <see cref="T:System.String"/>.
            	</para>
            	<para>
            		This method approaches an O(1) operation.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Add(MsgPack.MessagePackObject,MsgPack.MessagePackObject)">
            <summary>
            	Adds the specified key and value to the dictionary.
            </summary>
            <param name="key">
            	The key of the element to add.
            </param>
            <param name="value">
            	The value of the element to add. The value can be <c>null</c> for reference types.
            </param>
            <returns>
            	An element with the same key already does not exist in the dictionary and sucess to add then newly added node;
            	otherwise <c>null</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            	<paramref name="key"/> already exists in this dictionary.
            	Note that tiny integers are considered equal regardless of its CLI <see cref="T:System.Type"/>,
            	and UTF-8 encoded bytes are considered equals to <see cref="T:System.String"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is <see cref="F:MsgPack.MessagePackObject.Nil"/>.
            </exception>
            <remarks>
            	If <see cref="P:MsgPack.MessagePackObjectDictionary.Count"/> is less than the capacity, this method approaches an O(1) operation.
            	If the capacity must be increased to accommodate the new element, 
            	this method becomes an O(<em>N</em>) operation, where <em>N</em> is <see cref="P:MsgPack.MessagePackObjectDictionary.Count"/>. 
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Remove(MsgPack.MessagePackObject)">
            <summary>
            Removes the element with the specified key from the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            	<c>true</c> if the element is successfully removed; otherwise, <c>false</c>. 
            	This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is <see cref="F:MsgPack.MessagePackObject.Nil"/>.
            </exception>
            <remarks>
            	This method approaches an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Clear">
            <summary>
            	Removes all items from the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <remarks>
            	This method approaches an O(<em>N</em>) operation, where <em>N</em> is <see cref="P:MsgPack.MessagePackObjectDictionary.Count"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.GetEnumerator">
            <summary>
            	Returns an enumerator that iterates through the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <returns>
            	Returns an enumerator that iterates through the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </returns>
            <remarks>
            	This method is an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Freeze">
            <summary>
            	Freezes this instance.
            </summary>
            <returns>
            	This instance itself.
            	This value will not be <c>null</c> and its <see cref="P:MsgPack.MessagePackObjectDictionary.IsFrozen"/> is <c>true</c>.
            </returns>
            <remarks>
            	This method freezes this instance itself.
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.AsFrozen">
            <summary>
            	Gets a copy of this instance as frozen instance.
            </summary>
            <returns>
            	New <see cref="T:MsgPack.MessagePackObjectDictionary"/> instance which contains same items as this instance.
            	This value will not be <c>null</c> and its <see cref="P:MsgPack.MessagePackObjectDictionary.IsFrozen"/> is <c>true</c>.
            </returns>
            <remarks>
            	This method does not freeze this instance itself.
            	This operation is an O(<em>N</em>) operation where <em>O(N)</em> <see cref="P:MsgPack.MessagePackObjectDictionary.Count"/> of items.
            </remarks>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.IsFrozen">
            <summary>
            	Gets a value indicating whether this instance is frozen.
            </summary>
            <value>
            	<c>true</c> if this instance is frozen; otherwise, <c>false</c>.
            </value>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Count">
            <summary>
            	Gets the number of elements contained in the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <returns>
            	The number of elements contained in the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </returns>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Item(MsgPack.MessagePackObject)">
            <summary>
            	Gets or sets the element with the specified key.
            </summary>
            <value>
            	The element with the specified key.
            </value>
            <param name="key">Key for geting or seting value.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="key"/> is <see cref="F:MsgPack.MessagePackObject.Nil"/>.
            </exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            	The property is retrieved and <paramref name="key"/> is not found.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            	The property is set and this instance is frozen.
            </exception>
            <remarks>
            	<para>
            		Note that tiny integers are considered equal regardless of its CLI <see cref="T:System.Type"/>,
            		and UTF-8 encoded bytes are considered equals to <see cref="T:System.String"/>.
            	</para>
            	<para>
            		This method approaches an O(1) operation.
            	</para>
            </remarks>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Keys">
            <summary>
            	Gets an <see cref="T:MsgPack.MessagePackObjectDictionary.KeySet"/> containing the keys of the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <returns>
            	An <see cref="T:MsgPack.MessagePackObjectDictionary.KeySet"/> containing the keys of the object.
            	This value will not be <c>null</c>.
            </returns>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Values">
            <summary>
            	Gets an <see cref="T:MsgPack.MessagePackObjectDictionary.ValueCollection"/> containing the values of the <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <returns>
            	An <see cref="T:MsgPack.MessagePackObjectDictionary.ValueCollection"/> containing the values of the object.
            	This value will not be <c>null</c>.
            </returns>
            <remarks>
            	This operation is an O(1) operation.
            </remarks>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.KeySet">
            <summary>
            	Represents the set of <see cref="T:MsgPack.MessagePackObjectDictionary"/> keys.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.CopyTo(MsgPack.MessagePackObject[])">
            <summary>
            	Copies the entire collection to a compatible one-dimensional array, starting at the beginning of the target array. 
            </summary>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.CopyTo(MsgPack.MessagePackObject[],System.Int32)">
            <summary>
            	Copies the entire collection to a compatible one-dimensional array, 
            	starting at the specified index of the target array. 
            </summary>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            	The zero-based index in <paramref name="array"/> at which copying begins. 
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.CopyTo(System.Int32,MsgPack.MessagePackObject[],System.Int32,System.Int32)">
            <summary>
            	Copies a range of elements from this collection to a compatible one-dimensional array, 
            	starting at the specified index of the target array. 
            </summary>
            <param name="index">
            	The zero-based index in the source dictionary at which copying begins. 
            </param>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            	The zero-based index in <paramref name="array"/> at which copying begins. 
            </param>
            <param name="count">
            	The number of elements to copy.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.System#Collections#Generic#ICollection{MsgPack#MessagePackObject}#Contains(MsgPack.MessagePackObject)">
            <summary>
            	Determines whether this collection contains a specific value.
            </summary>
            <param name="item">
            	The object to locate in this collection.</param>
            <returns>
            	<c>true</c> if <paramref name="item"/> is found in this collection; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.IsProperSubsetOf(System.Collections.Generic.IEnumerable{MsgPack.MessagePackObject})">
            <summary>
            	Determines whether this set is proper subset of the specified collection.
            </summary>
            <param name="other">
            	The collection to compare to the current set.
            </param>
            <returns>
              <c>true</c> if this set is proper subset of the specified collection; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="other"/> is Nothing.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.IsProperSupersetOf(System.Collections.Generic.IEnumerable{MsgPack.MessagePackObject})">
            <summary>
            	Determines whether this set is proper superset of the specified collection.
            </summary>
            <param name="other">
            	The collection to compare to the current set.
            </param>
            <returns>
              <c>true</c> if this set is proper superset of the specified collection; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="other"/> is Nothing.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.IsSubsetOf(System.Collections.Generic.IEnumerable{MsgPack.MessagePackObject})">
            <summary>
            	Determines whether this set is subset of the specified collection.
            </summary>
            <param name="other">
            	The collection to compare to the current set.
            </param>
            <returns>
              <c>true</c> if this set is subset of the specified collection; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="other"/> is Nothing.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.IsSupersetOf(System.Collections.Generic.IEnumerable{MsgPack.MessagePackObject})">
            <summary>
            	Determines whether this set is superset of the specified collection.
            </summary>
            <param name="other">
            	The collection to compare to the current set.
            </param>
            <returns>
              <c>true</c> if this set is superset of the specified collection; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="other"/> is Nothing.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.Overlaps(System.Collections.Generic.IEnumerable{MsgPack.MessagePackObject})">
            <summary>
            	Determines whether the current set and a specified collection share common elements. 
            </summary>
            <param name="other">
            	The collection to compare to the current set.
            </param>
            <returns>
              <c>true</c> if this set and <paramref name="other"/> share at least one common element; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="other"/> is Nothing.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.SetEquals(System.Collections.Generic.IEnumerable{MsgPack.MessagePackObject})">
            <summary>
            	Determines whether this set and the specified collection contain the same elements. 
            </summary>
            <param name="other">
            	The collection to compare to the current set.
            </param>
            <returns>
              <c>true</c> if this set is equal to  <paramref name="other"/>; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="other"/> is Nothing.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.GetEnumerator">
            <summary>
            	Returns an enumerator that iterates through this collction.
            </summary>
            <returns>
            	Returns an enumerator that iterates through this collction.
            </returns>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.KeySet.Count">
            <summary>
            	Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            	The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
              </returns>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.KeySet.Enumerator">
            <summary>
            	Enumerates the elements of a <see cref="T:MsgPack.MessagePackObjectDictionary.KeySet"/>.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.Enumerator.Dispose">
            <summary>
            	Releases all resources used by the this instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.Enumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element of the underlying collection.
            </summary>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.KeySet.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            	Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.KeySet.Enumerator.Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the underlying collection at the current position of the enumerator.
            </value>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.KeySet.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the collection at the current position of the enumerator, as an <see cref="T:System.Object"/>.
            </value>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.ValueCollection">
            <summary>
            	Represents the collection of values in a <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.CopyTo(MsgPack.MessagePackObject[])">
            <summary>
            	Copies the entire collection to a compatible one-dimensional array, starting at the beginning of the target array. 
            </summary>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.CopyTo(MsgPack.MessagePackObject[],System.Int32)">
            <summary>
            	Copies the entire collection to a compatible one-dimensional array, 
            	starting at the specified index of the target array. 
            </summary>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            	The zero-based index in <paramref name="array"/> at which copying begins. 
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.CopyTo(System.Int32,MsgPack.MessagePackObject[],System.Int32,System.Int32)">
            <summary>
            	Copies a range of elements from this collection to a compatible one-dimensional array, 
            	starting at the specified index of the target array. 
            </summary>
            <param name="index">
            	The zero-based index in the source dictionary at which copying begins. 
            </param>
            <param name="array">
            	The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from this dictionary.
            	The <see cref="T:System.Array"/> must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            	The zero-based index in <paramref name="array"/> at which copying begins. 
            </param>
            <param name="count">
            	The number of elements to copy.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.System#Collections#Generic#ICollection{MsgPack#MessagePackObject}#Contains(MsgPack.MessagePackObject)">
            <summary>
            	Determines whether this collection contains a specific value.
            </summary>
            <param name="item">
            	The object to locate in this collection.</param>
            <returns>
            	<c>true</c> if <paramref name="item"/> is found in this collection; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.GetEnumerator">
            <summary>
            	Returns an enumerator that iterates through this collction.
            </summary>
            <returns>
            	Returns an enumerator that iterates through this collction.
            </returns>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.ValueCollection.Count">
            <summary>
            	Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            	The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
              </returns>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator">
            <summary>
            	Enumerates the elements of a <see cref="T:MsgPack.MessagePackObjectDictionary.ValueCollection"/>.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator.Dispose">
            <summary>
            	Releases all resources used by the this instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element of the underlying collection.
            </summary>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            	Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator.Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the underlying collection at the current position of the enumerator.
            </value>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.ValueCollection.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the collection at the current position of the enumerator, as an <see cref="T:System.Object"/>.
            </value>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.Enumerator">
            <summary>
            	Enumerates the elements of a <see cref="T:MsgPack.MessagePackObjectDictionary"/> in order.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Enumerator.Dispose">
            <summary>
            	Releases all resources used by the this instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Enumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element of the underlying collection.
            </summary>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            	Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Enumerator.Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the underlying collection at the current position of the enumerator.
            </value>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the collection at the current position of the enumerator, as an <see cref="T:System.Object"/>.
            </value>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="T:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator">
            <summary>
            	Enumerates the elements of a <see cref="T:MsgPack.MessagePackObjectDictionary"/> in order.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.MoveNext">
            <summary>
            	Advances the enumerator to the next element of the underlying collection.
            </summary>
            <returns>
            	<c>true</c> if the enumerator was successfully advanced to the next element; 
            	<c>false</c> if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.System#Collections#IEnumerator#Reset">
            <summary>
            	Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            	The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.Current">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <value>
            	The element in the collection at the current position of the enumerator, as an <see cref="T:System.Object"/>.
            </value>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.Entry">
            <summary>
            	Gets the element at the current position of the enumerator.
            </summary>
            <returns>
            	The element in the dictionary at the current position of the enumerator, as a <see cref="T:System.Collections.DictionaryEntry"/>B
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.Key">
            <summary>
            	Gets the key of the element at the current position of the enumerator.
            </summary>
            <returns>
            	The key of the element in the dictionary at the current position of the enumerator.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="P:MsgPack.MessagePackObjectDictionary.DictionaryEnumerator.Value">
            <summary>
            	Gets the value of the element at the current position of the enumerator.
            </summary>
            <returns>
            	The value of the element in the dictionary at the current position of the enumerator.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	The enumerator is positioned before the first element of the collection or after the last element. 
            </exception>
        </member>
        <member name="T:MsgPack.Unpacker">
            <summary>
            	Implements deserializing feature of MsgPack.
            </summary>
            <remarks name="MsgPack.Unpacker">
    <see cref="T:MsgPack.Unpacker"/> implements three mode, that is 'Streaming', 'Enumerating', 'Skipping', and 'Subtree'.
    <list type="bullet">
      <item>
        <para>
          <strong>Streaming</strong>
        </para>
        <para>
          When the <see cref="M:MsgPack.Unpacker.Read"/> is called, unpacker go into 'Streaming' mode.
          In this mode, unpacker unpacks individual entries as <see cref="T:MsgPack.MessagePackObject"/> via <see cref="P:MsgPack.Unpacker.Data"/> property.
          If the underlying stream is ended unexpectedly, then <see cref="M:MsgPack.Unpacker.Read"/> returns <c>false</c>, and <see cref="P:MsgPack.Unpacker.Data"/> will be <c>null</c>.
          Note that if the underlying stream is feeded, that is the <see cref="P:Stream.Length"/> is expanded and its <see cref="P:Stream.Position"/> is not forwarded,
          subsequent <see cref="M:MsgPack.Unpacker.Read"/> invocation will success, and <see cref="P:MsgPack.Unpacker.Data"/> is set as complete entry which reflects feeded binary.
        </para>
        <para>
          If the reading of the entry is completed, that is the <see cref="P:MsgPack.Unpacker.Data"/> is not <c>null</c>, unpacker can transit other mode.
        </para>
      </item>
      <item>
        <para>
          <strong>Enumerating</strong>
        </para>
        <para>
          When the <see cref="M:MsgPack.Unpacker.GetEnumerator"/> is called and the enumeration is started, unpacker go into 'Enumerating' mode.
          In this mode, unpacker unpacks individual entries as <see cref="T:MsgPack.MessagePackObject"/> via <see cref="P:IEnumerator{T}.Current"/> property.
          If the underlying stream is ended unexpectedly, enumeration is interrupted.
          The interrupted unpacker cannot be resume.
        </para>
        <para>
          Once the enumeration is completed gracefully, unpacker can transit other mode.
        </para>
      </item>
      <item>
        <para>
          <strong>Skipping</strong>
        </para>
        <para>
          When the <see cref="M:MsgPack.Unpacker.Skip"/> is called, unpacker go into 'Skipping' mode.
          In this mode, unpacker scans the subtree where the root is current item, then returns skipped byte length.
          If the underlying stream is ended unexpectedly, it returns <c>null</c>.
          Note that if the underlying stream is feeded, that is the <see cref="P:Stream.Length"/> is expanded and its <see cref="P:Stream.Position"/> is not forwarded,
          subsequent <see cref="M:MsgPack.Unpacker.Skip"/> invocation will success, and returns length as complete entry which reflects feeded binary.
          <note>
            If the underlying <see cref="T:System.IO.Stream"/> is cannot be seeked (that is, <see cref="P:Stream.CanSeek"/> is <c>false</c>),
            DO NOT use this method.
            You can buffering the content via <see cref="T:System.IO.MemoryStream"/> instead, for example.
          </note>
        </para>
        <para>
          If the skipping of the subtree is completed, that is the return value is not <c>null</c>, unpacker can transit other mode.
        </para>
      </item>
      <item>
        <para>
          <strong>Subtree</strong>
        </para>
        <para>
          When the <see cref="M:MsgPack.Unpacker.ReadSubtree"/> is called, unpacker go into 'Subtree' mode.
          In this mode, any operation for this unpacker instance is invalid.
          Instead of use this instance itself, you can use subtree unpacker returned from <see cref="M:MsgPack.Unpacker.ReadSubtree"/>.
          The subtree unpacker is the instance which scope is limited to the subtree where the root is the current entry when <see cref="M:MsgPack.Unpacker.ReadSubtree"/> is called.
          The subtree unpacker also have its own mode and state.
          <note>
            <see cref="M:MsgPack.Unpacker.Dispose"/> of the subtree unpacker must be called to indicate subtree unpacking is gracefully completed.
            When the extra entries are remained in the subtree, these will be skipped on the disposal process.
          </note>
        </para>
        <para>
          Once the subtree unpacking is completed gracefully, that is, <see cref="M:MsgPack.Unpacker.Dispose"/> on the subtree unpacker called, the parant unpacker can transit other mode.
        </para>
      </item>
    </list>
  </remarks>
            <seealso cref="T:MsgPack.Unpacking"/>
        </member>
        <member name="M:MsgPack.Unpacker.VerifyMode(MsgPack.Unpacker.UnpackerMode)">
            <summary>
            	Verifies the mode.
            </summary>
            <param name="mode">The mode to be.</param>
            <exception cref="T:System.ObjectDisposedException">
            	Already disposed.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            	Is in incompatible mode.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.VerifyIsNotDisposed">
            <summary>
            	Verifies this instance is not disposed.
            </summary>
        </member>
        <member name="M:MsgPack.Unpacker.NewInvalidModeException">
            <summary>
            	Returns new exception instance to notify invalid mode transition.
            </summary>
            <returns>New exception instance to notify invalid mode transition.</returns>
        </member>
        <member name="M:MsgPack.Unpacker.Create">
            <summary>
            	 Creates the new <see cref="T:MsgPack.Unpacker"/> with internal buffer which has default size.
            </summary>
            <returns><see cref="T:MsgPack.Unpacker"/> instance.</returns>
        </member>
        <member name="M:MsgPack.Unpacker.Create(System.IO.Stream)">
            <summary>
            	 Creates the new <see cref="T:MsgPack.Unpacker"/> from specified stream.
            </summary>
            <param name="stream">The stream to be unpacked. This stream will be closed when <see cref="M:MsgPack.Packer.Dispose(System.Boolean)"/> is called.</param>
            <returns><see cref="T:MsgPack.Unpacker"/> instance.</returns>
        </member>
        <member name="M:MsgPack.Unpacker.Create(System.IO.Stream,System.Boolean)">
            <summary>
            	 Creates the new <see cref="T:MsgPack.Unpacker"/> from specified stream.
            </summary>
            <param name="stream">The stream to be unpacked.</param>
            <param name="ownsStream">
            	<c>true</c> to close <paramref name="stream"/> when this instance is disposed;
            	<c>false</c>, otherwise.
            </param>
            <returns><see cref="T:MsgPack.Unpacker"/> instance.</returns>
        </member>
        <member name="M:MsgPack.Unpacker.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Unpacker"/> class.
            </summary>
        </member>
        <member name="M:MsgPack.Unpacker.Dispose">
            <summary>
            	Releases all managed resources.
            </summary>
        </member>
        <member name="M:MsgPack.Unpacker.Dispose(System.Boolean)">
            <summary>
            	Releases unmanaged and optionally managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:MsgPack.Unpacker.ReadSubtree">
            <summary>
            	Starts unpacking of current subtree.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Unpacker"/> to unpack current subtree.
            	This will not be <c>null</c>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	This unpacker is not positioned on the header of array nor map.
            </exception>
            <remarks>
            	While subtree unpacker is used, this instance will be 'locked' (called 'subtree' mode) and be unavailable.
            	When you finish to unpack subtree, you must invoke <see cref="M:MsgPack.Unpacker.Dispose"/>, 
            	or you faces <see cref="T:System.InvalidOperationException"/> when you use the parent instance.
            	Subtree unpacker can only unpack subtree, so you can handle collection deserialization easily.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacker.ReadSubtreeCore">
            <summary>
            	Starts unpacking of current subtree.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Unpacker"/> to unpack current subtree.
            	This will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.EndReadSubtree">
            <summary>
            	Ends the read subtree.
            </summary>
            <remarks>
            	This method only be called from subtree unpacker.
            	Custom subtree unpacker implementation must call this method from its <see cref="M:MsgPack.Unpacker.Dispose(System.Boolean)"/> method.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacker.Read">
            <summary>
            	Reads next Message Pack entry.
            </summary>
            <returns>
            	<c>true</c>, if position is sucessfully move to next entry;
            	<c>false</c>, if position reaches the tail of the Message Pack stream.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            	This instance is in 'subtree' mode.
            </exception>
        </member>
        <member name="M:MsgPack.Unpacker.ReadCore">
            <summary>
            	Reads next Message Pack entry.
            </summary>
            <returns>
            	<c>true</c>, if position is sucessfully move to next entry;
            	<c>false</c>, if position reaches the tail of the Message Pack stream.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.GetEnumerator">
            <summary>
            	Gets <see cref="T:System.Collections.Generic.IEnumerator`1"/> to enumerate <see cref="T:MsgPack.MessagePackObject"/> from source stream.
            </summary>
            <returns><see cref="T:System.Collections.Generic.IEnumerator`1"/> to enumerate <see cref="T:MsgPack.MessagePackObject"/> from source stream.</returns>
        </member>
        <member name="M:MsgPack.Unpacker.Skip">
            <summary>
            	Skips the subtree where the root is the current entry, and returns skipped byte length.
            </summary>
            <returns>
            	Skipped byte length.
            	If the subtree is not completed, then <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.SkipCore">
            <summary>
            	Skips the subtree where the root is the current entry, and returns skipped byte length.
            </summary>
            <returns>
            	Skipped byte length.
            	If the subtree is not completed, then <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.ReadItem">
            <summary>
            	Gets current item or collection as single <see cref="T:MsgPack.MessagePackObject"/> from the stream.
            </summary>
            <returns>
            	A read item or collection from the stream.
            	Or <c>null</c> when stream is ended.
            </returns>
        </member>
        <member name="M:MsgPack.Unpacker.UnpackSubtree">
            <summary>
            	Unpacks current subtree and returns subtree root as array or map.
            </summary>
            <returns>
            	An unpacked array or map when current position is array or map header.
            	<c>null</c> when current position is not array nor map header.
            </returns>
        </member>
        <member name="P:MsgPack.Unpacker.Data">
            <summary>
            	Get last unpacked data.
            </summary>
            <value>Last unpacked data or null.</value>
            <remarks>
            	If you use any of directory APIs (methods which return non-<see cref="T:MsgPack.MessagePackObject"/>), 
            	then this property to be invalidated.
            </remarks>
        </member>
        <member name="P:MsgPack.Unpacker.IsArrayHeader">
            <summary>
            	Gets a value indicating whether this instance is positioned to array header.
            </summary>
            <value>
            	<c>true</c> if this instance is positioned to array header; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MsgPack.Unpacker.IsMapHeader">
            <summary>
            	Gets a value indicating whether this instance is positioned to map header.
            </summary>
            <value>
            	<c>true</c> if this instance is positioned to map header; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MsgPack.Unpacker.ItemsCount">
            <summary>
            	Gets the items count for current array or map.
            </summary>
            <value>
            	The items count for current array or map.
            </value>
            <exception cref="T:System.InvalidOperationException">
            	Both of the <see cref="P:MsgPack.Unpacker.IsArrayHeader"/> and <see cref="P:MsgPack.Unpacker.IsMapHeader"/> are <c>false</c>.
            </exception>
        </member>
        <member name="P:MsgPack.Unpacker.UnderlyingStream">
            <summary>
            	Gets the underlying stream to handle direct API.
            </summary>
            <exception cref="T:System.NotSupportedException">
            	This instance does not supoort direct API.
            </exception>
        </member>
        <member name="T:MsgPack.SubtreeUnpacker">
            <summary>
            	Defines subtree unpacking unpacker.
            </summary>
        </member>
        <member name="T:MsgPack.SetOperation">
            <summary>
            	Implements basic (maybe naive) implementation for common <see cref="T:System.Collections.Generic.ISet`1"/> operation.
            </summary>
        </member>
        <member name="T:MsgPack.Serialization.SerializationMethod">
            <summary>
            	Represents serialization method for complex types.
            </summary>
        </member>
        <member name="F:MsgPack.Serialization.SerializationMethod.Array">
            <summary>
            	The object will be serialized as array which is ordered by member ID.
            	This is default and more interoperable option.
            </summary>
        </member>
        <member name="F:MsgPack.Serialization.SerializationMethod.Map">
            <summary>
            	The object will be serialized as map which is ordered by member ID.
            	This is a bit slower than array, but more stable for forward/backward compatibility.
            </summary>
        </member>
        <member name="T:MsgPack.Serialization.Reflection.TracingILGenerator">
            <summary>
            	<see cref="T:System.Reflection.Emit.ILGenerator"/> like IL stream builder with tracing.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitAnyCall(System.Reflection.MethodInfo)">
            <summary>
            	Emit 'call' or 'callvirt' appropriately.
            </summary>
            <param name="target"><see cref="T:System.Reflection.MethodInfo"/> to be called.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitGetProperty(System.Reflection.PropertyInfo)">
            <summary>
            	Emit property getter invocation.
            	Pre condition is there is target instance on the top of evaluation stack when <paramref name="property"/> is instance property.
            	Post condition are that target instance will be removed from the stack for instance property, and property value will be placed on there.
            </summary>
            <param name="property"><see cref="T:System.Reflection.PropertyInfo"/> for target property.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCurrentCulture">
            <summary>
            	Emit <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/> invocation.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitInvariantCulture">
            <summary>
            	Emit <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> invocation.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitGetType">
            <summary>
            	Emit <see cref="M:System.Object.GetType"/> invocation.
            	Pre condition is that target instance is placed on the top of evaluation stack.
            	Post condition is that target instance will be replaced with <see cref="T:System.Type"/> of it.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStringFormat(System.Int32,System.String,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator}[])">
            <summary>
            	Emit <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> invocation with <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="temporaryLocalArrayIndex">
            	Index of temporary local variable index to store param array for <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>.
            	Note that the type of local variable must be Object[].
            </param>
            <param name="formatLiteral">Forat string literal.</param>
            <param name="argumentLoadingEmitters">
            	List of delegates to emittion of loading formatting parameter loading instruction. 
            	Index of this array corresponds to index of formatting parameter.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of evaluation stack.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStringFormat(System.Int32,System.Type,System.String,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator}[])">
            <summary>
            	Emit <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> invocation with <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.
            </summary>
            <param name="temporaryLocalArrayIndex">
            	Index of temporary local variable index to store param array for <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>.
            	Note that the type of local variable must be Object[].
            </param>
            <param name="resource">
            	Type of resource accessor.
            </param>
            <param name="resourceKey">
            	Key of rethis. Note that this method assumes that key equals to accessor property name.
            </param>
            <param name="argumentLoadingEmitters">
            	List of delegates to emittion of loading formatting parameter loading instruction. 
            	Index of this array corresponds to index of formatting parameter.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of evaluation stack.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStringFormatInvariant(System.Int32,System.String,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator}[])">
            <summary>
            	Emit <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> invocation with <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="temporaryLocalArrayIndex">
            	Index of temporary local variable index to store param array for <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>.
            	Note that the type of local variable must be Object[].
            </param>
            <param name="formatLiteral">Forat string literal.</param>
            <param name="argumentLoadingEmitters">
            	List of delegates to emittion of loading formatting parameter loading instruction. 
            	Index of this array corresponds to index of formatting parameter.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of evaluation stack.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStringFormatInvariant(System.Int32,System.Type,System.String,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator}[])">
            <summary>
            	Emit <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> invocation with <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="temporaryLocalArrayIndex">
            	Index of temporary local variable index to store param array for <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>.
            	Note that the type of local variable must be Object[].
            </param>
            <param name="resource">
            	Type of resource accessor.
            </param>
            <param name="resourceKey">
            	Key of rethis. Note that this method assumes that key equals to accessor property name.
            </param>
            <param name="argumentLoadingEmitters">
            	List of delegates to emittion of loading formatting parameter loading instruction. 
            	Index of this array corresponds to index of formatting parameter.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of evaluation stack.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdargThis">
            <summary>
            	Emit load 'this' pointer instruction (namely 'ldarg.0').
            	Post condition is that the loaded value will be added on the evaluation stack.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitAnyLdarg(System.Int32)">
            <summary>
            	Emit apprpriate 'ldarg.*' instruction.
            	Post condition is that the loaded value will be added on the evaluation stack.
            </summary>
            <param name="argumentIndex">
            	Index of argument to be fetched.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitAnyLdloc(System.Int32)">
            <summary>
            	Emit apprpriate 'ldloc.*' instruction.
            	Post condition is that the loaded value will be added on the evaluation stack.
            </summary>
            <param name="localIndex">
            	Index of local variable to be fetched.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitAnyStloc(System.Int32)">
            <summary>
            	Emit array initialization code with initializer.
            	Pre condition is that the storing value is placed on the top of evaluation stack and its type is valid.
            	Post condition is that the stored value will be removed from the evaluation stack.
            </summary>
            <param name="localIndex">
            	Index of local variable which stores the array.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitNewarr(System.Type,System.Int64)">
            <summary>
            	Emit array initialization code without initializer.
            	Post condition is evaluation stack will no be modified as previous state. 
            	Note that initialized array is not placed on the top of evaluation stack.
            </summary>
            <param name="elementType"><see cref="T:System.Type"/> of array element. This can be generaic parameter.</param>
            <param name="length">Size of array.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitNewarr(System.Int32,System.Type,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator}[])">
            <summary>
            	Emit array initialization code with initializer.
            	Post condition is evaluation stack will no be modified as previous state. 
            	Note that initialized array is not placed on the top of evaluation stack.
            </summary>
            <param name="arrayLocalIndex">
            	Index of local variable which stores the array.
            </param>
            <param name="elementType"><see cref="T:System.Type"/> of array element. This can be generaic parameter.</param>
            <param name="elementLoadingEmitters">
            	List of delegates to emittion of storing element loading instruction. 
            	Index of this array corresponds to index of initializing array.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of stack and its type is <paramref name="elementType"/> compatible.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitNewarr(System.Action{MsgPack.Serialization.Reflection.TracingILGenerator},System.Action{MsgPack.Serialization.Reflection.TracingILGenerator},System.Type,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator}[])">
            <summary>
            	Emit array initialization code with initializer.
            	Post condition is evaluation stack will no be modified as previous state. 
            	Note that initialized array is not placed on the top of evaluation stack.
            </summary>
            <param name="arrayLoadingEmitter">
            	Delegate to emittion of array loading instruction. 
            	1st argument is this instance.
            	Post condition is that exactly one target array will be added on the top of stack and element type is <paramref name="elementType"/>.
            </param>
            <param name="arrayStoringEmitter">
            	Delegate to emittion of array storing instruction. 
            	1st argument is this instance.
            	Pre condition is that the top of evaluation stack is array type and its element type is <paramref name="elementType"/>.
            	Post condition is that exactly one target array will be removed from the top of stack.
            </param>
            <param name="elementType"><see cref="T:System.Type"/> of array element. This can be generaic parameter.</param>
            <param name="elementLoadingEmitters">
            	List of delegates to emittion of storing element loading instruction. 
            	Index of this array corresponds to index of initializing array.
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of stack and its type is <paramref name="elementType"/> compatible.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitAnyLdelem(System.Type,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator},System.Int64)">
            <summary>
            	Emit array element loading instructions. 
            	Post condition is that exactly one loaded element will be placed on the top of stack and its element type is <paramref name="elementType"/>.
            </summary>
            <param name="elementType"><see cref="T:System.Type"/> of array element. This can be generaic parameter.</param>
            <param name="arrayLoadingEmitter">
            	Delegate to emittion of array loading instruction. 
            	1st argument is this instance.
            	Post condition is that exactly one target array will be added on the top of stack and its element type is <paramref name="elementType"/>.
            </param>
            <param name="index">Index of array element.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitAnyStelem(System.Type,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator},System.Int64,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator})">
            <summary>
            	Emit array element storing instructions.
            	Post condition is evaluation stack will no be modified as previous state.
            </summary>
            <param name="elementType"><see cref="T:System.Type"/> of array element. This can be generaic parameter.</param>
            <param name="arrayLoadingEmitter">
            	Delegate to emittion of array loading instruction. 
            	1st argument is this instance.
            	Post condition is that exactly one target array will be added on the top of stack and its element type is <paramref name="elementType"/>.
            </param>
            <param name="index">Index of array element.</param>
            <param name="elementLoadingEmitter">
            	Delegate to emittion of storing element loading instruction. 
            	1st argument is this instance.
            	Post condition is that exactly one storing element will be added on the top of stack and its type is <paramref name="elementType"/> compatible.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLiteralInteger(System.Int64)">
            <summary>
            	Emit efficient integer constant loading.
            	Post condition is that exactly one integer will be added on the top of stack.
            </summary>
            <param name="value">Integer value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitTypeOf(System.Type)">
            <summary>
            	Emit 'typeof' expression.
            	Post condition is <see cref="T:System.Type"/> instance for <paramref name="type"/> will be placed on the top of evaluation stack.
            </summary>
            <param name="type">Target <see cref="T:System.Type"/>.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitThrowNewArgumentExceptionWithInnerException">
            <summary>
            	Emit 'throw new ArgumentException(String,String,Exception)' statement.
            	Pre condition is that there are exactly three entries in the evaluation stack,
            	which are string, string, and Exception instance.
            	Post condition is that the evaluation statck will be empty.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitThrowNewExceptionWithInnerException(System.Type)">
            <summary>
            	Emit 'throw new TException(String,String,Exception)' statement.
            	Pre condition is that there are exactly two entries in the evaluation stack,
            	which are string and Exception instance.
            	Post condition is that the evaluation statck will be empty.
            </summary>
            <param name="exceptionType"><see cref="T:System.Type"/> of initializing and throwing <see cref="T:System.Exception"/>.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitNop">
            <summary>
            	Emit 'nop' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBreak">
            <summary>
            	Emit 'break' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdarg_0">
            <summary>
            	Emit 'ldarg.0' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdarg_1">
            <summary>
            	Emit 'ldarg.1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdarg_2">
            <summary>
            	Emit 'ldarg.2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdarg_3">
            <summary>
            	Emit 'ldarg.3' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdloc_0">
            <summary>
            	Emit 'ldloc.0' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdloc_1">
            <summary>
            	Emit 'ldloc.1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdloc_2">
            <summary>
            	Emit 'ldloc.2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdloc_3">
            <summary>
            	Emit 'ldloc.3' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStloc_0">
            <summary>
            	Emit 'stloc.0' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStloc_1">
            <summary>
            	Emit 'stloc.1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStloc_2">
            <summary>
            	Emit 'stloc.2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStloc_3">
            <summary>
            	Emit 'stloc.3' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdarg_S(System.Byte)">
            <summary>
            	Emit 'ldarg.s' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdarga_S(System.Byte)">
            <summary>
            	Emit 'ldarga.s' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStarg_S(System.Byte)">
            <summary>
            	Emit 'starg.s' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdloc_S(System.Byte)">
            <summary>
            	Emit 'ldloc.s' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdloca_S(System.Byte)">
            <summary>
            	Emit 'ldloca.s' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStloc_S(System.Byte)">
            <summary>
            	Emit 'stloc.s' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdnull">
            <summary>
            	Emit 'ldnull' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4_M1">
            <summary>
            	Emit 'ldc.i4.m1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4_0">
            <summary>
            	Emit 'ldc.i4.0' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4_1">
            <summary>
            	Emit 'ldc.i4.1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4_2">
            <summary>
            	Emit 'ldc.i4.2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4_3">
            <summary>
            	Emit 'ldc.i4.3' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4_4">
            <summary>
            	Emit 'ldc.i4.4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4_5">
            <summary>
            	Emit 'ldc.i4.5' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4_6">
            <summary>
            	Emit 'ldc.i4.6' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4_7">
            <summary>
            	Emit 'ldc.i4.7' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4_8">
            <summary>
            	Emit 'ldc.i4.8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4_S(System.Byte)">
            <summary>
            	Emit 'ldc.i4.s' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I4(System.Int32)">
            <summary>
            	Emit 'ldc.i4' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.Int32"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_I8(System.Int64)">
            <summary>
            	Emit 'ldc.i8' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.Int64"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_R4(System.Byte)">
            <summary>
            	Emit 'ldc.r4' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdc_R8(System.Double)">
            <summary>
            	Emit 'ldc.r8' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.Double"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitDup">
            <summary>
            	Emit 'dup' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitPop">
            <summary>
            	Emit 'pop' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitJmp(System.Reflection.MethodInfo)">
            <summary>
            	Emit 'jmp' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.MethodInfo"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCall(System.Reflection.MethodInfo)">
            <summary>
            	Emit 'call' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.MethodInfo"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBr_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'br.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBrfalse_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'brfalse.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBrtrue_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'brtrue.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBeq_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'beq.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBge_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'bge.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBgt_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'bgt.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBle_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'ble.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBlt_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'blt.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBne_Un_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'bne.un.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBge_Un_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'bge.un.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBgt_Un_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'bgt.un.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBle_Un_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'ble.un.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBlt_Un_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'blt.un.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBr(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'br' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBrfalse(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'brfalse' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBrtrue(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'brtrue' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBeq(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'beq' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBge(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'bge' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBgt(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'bgt' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBle(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'ble' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBlt(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'blt' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBne_Un(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'bne.un' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBge_Un(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'bge.un' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBgt_Un(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'bgt.un' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBle_Un(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'ble.un' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBlt_Un(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'blt.un' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitSwitch(System.Reflection.Emit.Label[])">
            <summary>
            	Emit 'switch' instruction with specified arguments.
            </summary>
            <param name="targets"><see cref="T:System.Reflection.Emit.Label"/>[] as targets.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdind_I1">
            <summary>
            	Emit 'ldind.i1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdind_U1">
            <summary>
            	Emit 'ldind.u1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdind_I2">
            <summary>
            	Emit 'ldind.i2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdind_U2">
            <summary>
            	Emit 'ldind.u2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdind_I4">
            <summary>
            	Emit 'ldind.i4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdind_U4">
            <summary>
            	Emit 'ldind.u4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdind_I8">
            <summary>
            	Emit 'ldind.i8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdind_I">
            <summary>
            	Emit 'ldind.i' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdind_R4">
            <summary>
            	Emit 'ldind.r4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdind_R8">
            <summary>
            	Emit 'ldind.r8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdind_Ref">
            <summary>
            	Emit 'ldind.ref' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStind_Ref">
            <summary>
            	Emit 'stind.ref' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStind_I1">
            <summary>
            	Emit 'stind.i1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStind_I2">
            <summary>
            	Emit 'stind.i2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStind_I4">
            <summary>
            	Emit 'stind.i4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStind_I8">
            <summary>
            	Emit 'stind.i8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStind_R4">
            <summary>
            	Emit 'stind.r4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStind_R8">
            <summary>
            	Emit 'stind.r8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitAdd">
            <summary>
            	Emit 'add' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitSub">
            <summary>
            	Emit 'sub' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitMul">
            <summary>
            	Emit 'mul' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitDiv">
            <summary>
            	Emit 'div' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitDiv_Un">
            <summary>
            	Emit 'div.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitRem">
            <summary>
            	Emit 'rem' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitRem_Un">
            <summary>
            	Emit 'rem.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitAnd">
            <summary>
            	Emit 'and' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitOr">
            <summary>
            	Emit 'or' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitXor">
            <summary>
            	Emit 'xor' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitShl">
            <summary>
            	Emit 'shl' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitShr">
            <summary>
            	Emit 'shr' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitShr_Un">
            <summary>
            	Emit 'shr.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitNeg">
            <summary>
            	Emit 'neg' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitNot">
            <summary>
            	Emit 'not' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_I1">
            <summary>
            	Emit 'conv.i1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_I2">
            <summary>
            	Emit 'conv.i2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_I4">
            <summary>
            	Emit 'conv.i4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_I8">
            <summary>
            	Emit 'conv.i8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_R4">
            <summary>
            	Emit 'conv.r4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_R8">
            <summary>
            	Emit 'conv.r8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_U4">
            <summary>
            	Emit 'conv.u4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_U8">
            <summary>
            	Emit 'conv.u8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCallvirt(System.Reflection.MethodInfo)">
            <summary>
            	Emit 'callvirt' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.MethodInfo"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCpobj(System.Type)">
            <summary>
            	Emit 'cpobj' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdobj(System.Type)">
            <summary>
            	Emit 'ldobj' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdstr(System.String)">
            <summary>
            	Emit 'ldstr' instruction with specified arguments.
            </summary>
            <param name="value"><see cref="T:System.String"/> as value.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitNewobj(System.Reflection.ConstructorInfo)">
            <summary>
            	Emit 'newobj' instruction with specified arguments.
            </summary>
            <param name="constructor"><see cref="T:System.Reflection.ConstructorInfo"/> as constructor.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCastclass(System.Type)">
            <summary>
            	Emit 'castclass' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitIsinst(System.Type)">
            <summary>
            	Emit 'isinst' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_R_Un">
            <summary>
            	Emit 'conv.r.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitUnbox(System.Type)">
            <summary>
            	Emit 'unbox' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitThrow">
            <summary>
            	Emit 'throw' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdfld(System.Reflection.FieldInfo)">
            <summary>
            	Emit 'ldfld' instruction with specified arguments.
            </summary>
            <param name="field"><see cref="T:System.Reflection.FieldInfo"/> as field.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdflda(System.Reflection.FieldInfo)">
            <summary>
            	Emit 'ldflda' instruction with specified arguments.
            </summary>
            <param name="field"><see cref="T:System.Reflection.FieldInfo"/> as field.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStfld(System.Reflection.FieldInfo)">
            <summary>
            	Emit 'stfld' instruction with specified arguments.
            </summary>
            <param name="field"><see cref="T:System.Reflection.FieldInfo"/> as field.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdsfld(System.Reflection.FieldInfo)">
            <summary>
            	Emit 'ldsfld' instruction with specified arguments.
            </summary>
            <param name="field"><see cref="T:System.Reflection.FieldInfo"/> as field.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdsflda(System.Reflection.FieldInfo)">
            <summary>
            	Emit 'ldsflda' instruction with specified arguments.
            </summary>
            <param name="field"><see cref="T:System.Reflection.FieldInfo"/> as field.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStsfld(System.Reflection.FieldInfo)">
            <summary>
            	Emit 'stsfld' instruction with specified arguments.
            </summary>
            <param name="field"><see cref="T:System.Reflection.FieldInfo"/> as field.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStobj(System.Type)">
            <summary>
            	Emit 'stobj' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_I1_Un">
            <summary>
            	Emit 'conv.ovf.i1.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_I2_Un">
            <summary>
            	Emit 'conv.ovf.i2.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_I4_Un">
            <summary>
            	Emit 'conv.ovf.i4.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_I8_Un">
            <summary>
            	Emit 'conv.ovf.i8.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_U1_Un">
            <summary>
            	Emit 'conv.ovf.u1.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_U2_Un">
            <summary>
            	Emit 'conv.ovf.u2.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_U4_Un">
            <summary>
            	Emit 'conv.ovf.u4.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_U8_Un">
            <summary>
            	Emit 'conv.ovf.u8.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_I_Un">
            <summary>
            	Emit 'conv.ovf.i.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_U_Un">
            <summary>
            	Emit 'conv.ovf.u.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitBox(System.Type)">
            <summary>
            	Emit 'box' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitNewarr(System.Type)">
            <summary>
            	Emit 'newarr' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdlen">
            <summary>
            	Emit 'ldlen' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelema(System.Type)">
            <summary>
            	Emit 'ldelema' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem_I1">
            <summary>
            	Emit 'ldelem.i1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem_U1">
            <summary>
            	Emit 'ldelem.u1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem_I2">
            <summary>
            	Emit 'ldelem.i2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem_U2">
            <summary>
            	Emit 'ldelem.u2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem_I4">
            <summary>
            	Emit 'ldelem.i4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem_U4">
            <summary>
            	Emit 'ldelem.u4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem_I8">
            <summary>
            	Emit 'ldelem.i8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem_I">
            <summary>
            	Emit 'ldelem.i' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem_R4">
            <summary>
            	Emit 'ldelem.r4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem_R8">
            <summary>
            	Emit 'ldelem.r8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem_Ref">
            <summary>
            	Emit 'ldelem.ref' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStelem_I">
            <summary>
            	Emit 'stelem.i' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStelem_I1">
            <summary>
            	Emit 'stelem.i1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStelem_I2">
            <summary>
            	Emit 'stelem.i2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStelem_I4">
            <summary>
            	Emit 'stelem.i4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStelem_I8">
            <summary>
            	Emit 'stelem.i8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStelem_R4">
            <summary>
            	Emit 'stelem.r4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStelem_R8">
            <summary>
            	Emit 'stelem.r8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStelem_Ref">
            <summary>
            	Emit 'stelem.ref' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdelem(System.Type)">
            <summary>
            	Emit 'ldelem' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStelem(System.Type)">
            <summary>
            	Emit 'stelem' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitUnbox_Any(System.Type)">
            <summary>
            	Emit 'unbox.any' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_I1">
            <summary>
            	Emit 'conv.ovf.i1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_U1">
            <summary>
            	Emit 'conv.ovf.u1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_I2">
            <summary>
            	Emit 'conv.ovf.i2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_U2">
            <summary>
            	Emit 'conv.ovf.u2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_I4">
            <summary>
            	Emit 'conv.ovf.i4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_U4">
            <summary>
            	Emit 'conv.ovf.u4' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_I8">
            <summary>
            	Emit 'conv.ovf.i8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_U8">
            <summary>
            	Emit 'conv.ovf.u8' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitRefanyval(System.Type)">
            <summary>
            	Emit 'refanyval' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCkfinite">
            <summary>
            	Emit 'ckfinite' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitMkrefany(System.Type)">
            <summary>
            	Emit 'mkrefany' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdtoken(System.Type)">
            <summary>
            	Emit 'ldtoken' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Type"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdtoken(System.Reflection.MethodInfo)">
            <summary>
            	Emit 'ldtoken' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.MethodInfo"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdtoken(System.Reflection.FieldInfo)">
            <summary>
            	Emit 'ldtoken' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.FieldInfo"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_U2">
            <summary>
            	Emit 'conv.u2' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_U1">
            <summary>
            	Emit 'conv.u1' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_I">
            <summary>
            	Emit 'conv.i' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_I">
            <summary>
            	Emit 'conv.ovf.i' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_Ovf_U">
            <summary>
            	Emit 'conv.ovf.u' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitAdd_Ovf">
            <summary>
            	Emit 'add.ovf' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitAdd_Ovf_Un">
            <summary>
            	Emit 'add.ovf.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitMul_Ovf">
            <summary>
            	Emit 'mul.ovf' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitMul_Ovf_Un">
            <summary>
            	Emit 'mul.ovf.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitSub_Ovf">
            <summary>
            	Emit 'sub.ovf' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitSub_Ovf_Un">
            <summary>
            	Emit 'sub.ovf.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitEndfinally">
            <summary>
            	Emit 'endfinally' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLeave(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'leave' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLeave_S(System.Reflection.Emit.Label)">
            <summary>
            	Emit 'leave.s' instruction with specified arguments.
            </summary>
            <param name="target"><see cref="T:System.Reflection.Emit.Label"/> as target.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStind_I">
            <summary>
            	Emit 'stind.i' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConv_U">
            <summary>
            	Emit 'conv.u' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitArglist">
            <summary>
            	Emit 'arglist' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCeq">
            <summary>
            	Emit 'ceq' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCgt">
            <summary>
            	Emit 'cgt' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCgt_Un">
            <summary>
            	Emit 'cgt.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitClt">
            <summary>
            	Emit 'clt' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitClt_Un">
            <summary>
            	Emit 'clt.un' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdftn(System.Reflection.MethodInfo)">
            <summary>
            	Emit 'ldftn' instruction with specified arguments.
            </summary>
            <param name="method"><see cref="T:System.Reflection.MethodInfo"/> as method.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdvirtftn(System.Reflection.MethodInfo)">
            <summary>
            	Emit 'ldvirtftn' instruction with specified arguments.
            </summary>
            <param name="method"><see cref="T:System.Reflection.MethodInfo"/> as method.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdarg(System.Int32)">
            <summary>
            	Emit 'ldarg' instruction with specified arguments.
            </summary>
            <param name="index"><see cref="T:System.Int32"/> as index.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdarga(System.Int32)">
            <summary>
            	Emit 'ldarga' instruction with specified arguments.
            </summary>
            <param name="index"><see cref="T:System.Int32"/> as index.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStarg(System.Int32)">
            <summary>
            	Emit 'starg' instruction with specified arguments.
            </summary>
            <param name="index"><see cref="T:System.Int32"/> as index.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdloc(System.Int32)">
            <summary>
            	Emit 'ldloc' instruction with specified arguments.
            </summary>
            <param name="index"><see cref="T:System.Int32"/> as index.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLdloca(System.Int32)">
            <summary>
            	Emit 'ldloca' instruction with specified arguments.
            </summary>
            <param name="index"><see cref="T:System.Int32"/> as index.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitStloc(System.Int32)">
            <summary>
            	Emit 'stloc' instruction with specified arguments.
            </summary>
            <param name="index"><see cref="T:System.Int32"/> as index.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitLocalloc">
            <summary>
            	Emit 'localloc' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitEndfilter">
            <summary>
            	Emit 'endfilter' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitInitobj(System.Type)">
            <summary>
            	Emit 'initobj' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCpblk">
            <summary>
            	Emit 'cpblk' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitInitblk">
            <summary>
            	Emit 'initblk' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitRethrow">
            <summary>
            	Emit 'rethrow' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitSizeof(System.Type)">
            <summary>
            	Emit 'sizeof' instruction with specified arguments.
            </summary>
            <param name="type"><see cref="T:System.Type"/> as type.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitRefanytype">
            <summary>
            	Emit 'refanytype' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.#ctor(System.Reflection.Emit.MethodBuilder,System.IO.TextWriter)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/> class.
            </summary>
            <param name="methodBuilder">The method builder.</param>
            <param name="traceWriter">The trace writer.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.#ctor(System.Reflection.Emit.DynamicMethod,System.IO.TextWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/> class.
            </summary>
            <param name="dynamicMethod">The dynamic method.</param>
            <param name="traceWriter">The trace writer.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.#ctor(System.Reflection.Emit.MethodBuilder,System.IO.TextWriter,System.Boolean)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/> class.
            </summary>
            <param name="methodBuilder">The method builder.</param>
            <param name="traceWriter">The trace writer.</param>
            <param name="isDebuggable"><c>true</c> if the underlying builders are debuggable; othersie <c>false</c>.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.Dispose">
            <summary>
            	Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitRet">
            <summary>
            	Emit 'ret' instruction with specified arguments.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.DeclareLocal(System.Type)">
            <summary>
            	Declare local without pinning and name for debugging.
            </summary>
            <param name="localType"><see cref="T:System.Type"/> of local variable.</param>
            <returns><see cref="T:System.Reflection.Emit.LocalBuilder"/> to refer declared local variable.</returns>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.DeclareLocal(System.Type,System.Boolean)">
            <summary>
            	Declare local without name for debugging.
            </summary>
            <param name="localType"><see cref="T:System.Type"/> of local variable.</param>
            <param name="pinned">If <c>true</c>, the local variable will be pinned.</param>
            <returns><see cref="T:System.Reflection.Emit.LocalBuilder"/> to refer declared local variable.</returns>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.DeclareLocal(System.Type,System.String)">
            <summary>
            	Declare local with name for debugging and without pinning.
            	Note that this method is not enabled for dynamic method.
            </summary>
            <param name="localType"><see cref="T:System.Type"/> of local variable.</param>
            <param name="name">Name of the local variable.</param>
            <returns><see cref="T:System.Reflection.Emit.LocalBuilder"/> to refer declared local variable.</returns>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.DeclareLocal(System.Type,System.String,System.Boolean)">
            <summary>
            	Declare local with name for debugging.
            	Note that this method is not enabled for dynamic method.
            </summary>
            <param name="localType"><see cref="T:System.Type"/> of local variable.</param>
            <param name="name">Name of the local variable.</param>
            <param name="pinned">If <c>true</c>, the local variable will be pinned.</param>
            <returns><see cref="T:System.Reflection.Emit.LocalBuilder"/> to refer declared local variable.</returns>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitExceptionBlock(System.Action{MsgPack.Serialization.Reflection.TracingILGenerator,System.Reflection.Emit.Label},System.Tuple{System.Type,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator,System.Reflection.Emit.Label,System.Type}},System.Tuple{System.Type,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator,System.Reflection.Emit.Label,System.Type}}[])">
            <summary>
            	Emit exception block with catch blocks.
            </summary>
            <param name="tryBlockEmitter">
            	<see cref="T:System.Action`2"/> which emits exception block (try in C#) body.
            	A 1st argument is this <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/>,
            	and a 2nd argument is <see cref="T:System.Reflection.Emit.Label"/> will to be end of emitting exception block.
            	The delegate do not have to emit leave or leave.s instrauction at tail of the body.
            </param>
            <param name="firstCatchBlock">
            	<see cref="T:System.Tuple`2"/> for catch block body emittion.
            	A 1st item of the tuple is <see cref="T:System.Type"/> which indicates catching exception type.
            	A 2nd item of the tuple is <see cref="T:System.Action`2"/> which emits catch block body.
            	A 1st argument of the delegate is this <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/>,
            	a 2nd argument of the delegate is <see cref="T:System.Reflection.Emit.Label"/> will to be end of emitting exception block,
            	and 3rd argument of the delegate is the 1st item of the tuple.
            	The delegate do not have to emit leave or leave.s instrauction at tail of the body.
            </param>
            <param name="remainingCatchBlockEmitters">
            	<see cref="T:System.Tuple`2"/> for catch block body emittion.
            	A 1st item of the tuple is <see cref="T:System.Type"/> which indicates catching exception type.
            	A 2nd item of the tuple is <see cref="T:System.Action`2"/> which emits catch block body.
            	A 1st argument of the delegate is this <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/>,
            	a 2nd argument of the delegate is <see cref="T:System.Reflection.Emit.Label"/> will to be end of emitting exception block,
            	and 3rd argument of the delegate is the 1st item of the tuple.
            	The delegate do not have to emit leave or leave.s instrauction at tail of the body.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitExceptionBlock(System.Action{MsgPack.Serialization.Reflection.TracingILGenerator,System.Reflection.Emit.Label},System.Action{MsgPack.Serialization.Reflection.TracingILGenerator,System.Reflection.Emit.Label},System.Tuple{System.Type,System.Action{MsgPack.Serialization.Reflection.TracingILGenerator,System.Reflection.Emit.Label,System.Type}}[])">
            <summary>
            	Emit exception block with catch blocks and a finally block.
            </summary>
            <param name="tryBlockEmitter">
            	<see cref="T:System.Action`2"/> which emits exception block (try in C#) body.
            	A 1st argument is this <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/>,
            	and a 2nd argument is <see cref="T:System.Reflection.Emit.Label"/> will to be end of emitting exception block.
            	The delegate do not have to emit leave or leave.s instrauction at tail of the body.
            </param>
            <param name="finallyBlockEmitter">
            	<see cref="T:System.Action`2"/> which emits finally block  body.
            	A 1st argument is this <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/>,
            	and a 2nd argument is <see cref="T:System.Reflection.Emit.Label"/> will to be end of emitting exception block.
            	The delegate do not have to emit endfinally instrauction at tail of the body.
            </param>
            <param name="catchBlockEmitters">
            	<see cref="T:System.Tuple`2"/> for catch block body emittion.
            	A 1st item of the tuple is <see cref="T:System.Type"/> which indicates catching exception type.
            	A 2nd item of the tuple is <see cref="T:System.Action`2"/> which emits catch block body.
            	A 1st argument of the delegate is this <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/>,
            	a 2nd argument of the delegate is <see cref="T:System.Reflection.Emit.Label"/> will to be end of emitting exception block,
            	and 3rd argument of the delegate is the 1st item of the tuple.
            	The delegate do not have to emit leave or leave.s instrauction at tail of the body.
            </param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.BeginExceptionBlock">
            <summary>
            	Begin exception block (try in C#) here.
            	Note that you do not have to emit leave or laeve.s instrauction at tail of the body.
            </summary>
            <returns><see cref="T:System.Reflection.Emit.Label"/> will to be end of begun exception block.</returns>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.BeginCatchBlock(System.Type)">
            <summary>
            	Begin catch block with specified exception.
            	Note that you do not have to emit leave or laeve.s instrauction at tail of the body.
            </summary>
            <param name="exceptionType"><see cref="T:System.Type"/> for catch.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.BeginExceptFilterBlock">
            <summary>
            	Begin filter block.
            	Note that you do not have to emit leave or laeve.s instrauction at tail of the body.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.BeginFaultBlock">
            <summary>
            	Begin fault block.
            	Note that you do not have to emit endfinally instrauction at tail of the body.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.BeginFinallyBlock">
            <summary>
            	Begin finally block.
            	Note that you do not have to emit endfinally instrauction at tail of the body.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EndExceptionBlock">
            <summary>
            	End current exception block and its last clause.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.DefineLabel">
            <summary>
            	Define new <see cref="T:System.Reflection.Emit.Label"/> without name for tracing.
            </summary>
            <returns><see cref="T:System.Reflection.Emit.Label"/> which will be target of branch instructions.</returns>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.DefineLabel(System.String)">
            <summary>
            	Define new <see cref="T:System.Reflection.Emit.Label"/> with name for tracing.
            </summary>
            <param name="name">Name of label. Note that debugging information will not have this name.</param>
            <returns><see cref="T:System.Reflection.Emit.Label"/> which will be target of branch instructions.</returns>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.MarkLabel(System.Reflection.Emit.Label)">
            <summary>
            	Mark current position using specifieid <see cref="T:System.Reflection.Emit.Label"/>.
            </summary>
            <param name="label"><see cref="T:System.Reflection.Emit.Label"/>.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCalli(System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <summary>
            	Emit 'calli' instruction for indirect unmanaged function call.
            </summary>
            <param name="unmanagedCallingConvention"><see cref="T:System.Runtime.InteropServices.CallingConvention"/> of unmanaged function.</param>
            <param name="returnType">Return <see cref="T:System.Type"/> of the function.</param>
            <param name="parameterTypes">Parameter <see cref="T:System.Type"/>s of the function.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitCalli(System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>
            	Emit 'calli' instruction for indirect managed method call.
            </summary>
            <param name="managedCallingConventions"><see cref="T:System.Reflection.CallingConventions"/> of managed method.</param>
            <param name="returnType">Return <see cref="T:System.Type"/> of the method.</param>
            <param name="requiredParameterTypes">Required parameter <see cref="T:System.Type"/>s of the method.</param>
            <param name="optionalParameterTypes">Optional varargs parameter <see cref="T:System.Type"/>s of the method.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitConstrainedCallvirt(System.Type,System.Reflection.MethodInfo)">
            <summary>
            	Emit constrained 'callvirt' instruction.
            </summary>
            <param name="constrainedTo"><see cref="T:System.Type"/> to be constrained to.</param>
            <param name="target">Target <see cref="T:System.Reflection.MethodInfo"/> which must be virtual method.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitReadOnlyLdelema(System.Type)">
            <summary>
            	Emit readonly 'ldelema' instruction.
            </summary>
            <param name="elementType"><see cref="T:System.Type"/> of array element.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitTailCall(System.Reflection.MethodInfo)">
            <summary>
            	Emit 'call' instruction with specified arguments as tail call.
            </summary>
            <param name="target"><see cref="T:System.Reflection.MethodInfo"/> as target.</param>
            <remarks>
            	Subsequent 'ret' instruction will be emitted together.
            </remarks>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitTailCallVirt(System.Reflection.MethodInfo)">
            <summary>
            	Emit 'callvirt' instruction with specified arguments as tail call.
            </summary>
            <param name="target"><see cref="T:System.Reflection.MethodInfo"/> as target.</param>
            <remarks>
            	Subsequent 'ret' instruction will be emitted together.
            </remarks>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitTailCalli(System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <summary>
            	Emit 'calli' instruction for indirect unmanaged function call as tail call.
            </summary>
            <param name="unmanagedCallingConvention"><see cref="T:System.Runtime.InteropServices.CallingConvention"/> of unmanaged function.</param>
            <param name="returnType">Return <see cref="T:System.Type"/> of the function.</param>
            <param name="parameterTypes">Parameter <see cref="T:System.Type"/>s of the function.</param>
            <remarks>
            	Subsequent 'ret' instruction will be emitted together.
            </remarks>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitTailCalli(System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>
            	Emit 'calli' instruction for indirect managed method call as tail call.
            </summary>
            <param name="managedCallingConventions"><see cref="T:System.Reflection.CallingConventions"/> of managed method.</param>
            <param name="returnType">Return <see cref="T:System.Type"/> of the method.</param>
            <param name="requiredParameterTypes">Required parameter <see cref="T:System.Type"/>s of the method.</param>
            <param name="optionalParameterTypes">Optional varargs parameter <see cref="T:System.Type"/>s of the method.</param>
            <remarks>
            	Subsequent 'ret' instruction will be emitted together.
            </remarks>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.EmitUnaligned(System.Byte)">
            <summary>
            	Emit 'unaligned.' prefix.
            </summary>
            <param name="alignment">Alignment.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.TraceWrite(System.String)">
            <summary>
            	Write trace message.
            </summary>
            <param name="value">The string.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.TraceWrite(System.String,System.Object)">
            <summary>
            	Write trace message.
            </summary>
            <param name="format">The format string.</param>
            <param name="arg0">Format argument.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.TraceWrite(System.String,System.Object[])">
            <summary>
            	Write trace message.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">Format arguments.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.TraceWriteLine">
            <summary>
            	Write trace line break.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.TraceWriteLine(System.String)">
            <summary>
            	Write trace message followed by line break.
            </summary>
            <param name="value">The string.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.TraceWriteLine(System.String,System.Object)">
            <summary>
            	Write trace message followed by line break.
            </summary>
            <param name="format">The format string.</param>
            <param name="arg0">Format argument.</param>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.TracingILGenerator.TraceWriteLine(System.String,System.Object[])">
            <summary>
            	Write trace message followed by line break.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">Format arguments.</param>
        </member>
        <member name="P:MsgPack.Serialization.Reflection.TracingILGenerator.EndOfMethod">
            <summary>
            	Get <see cref="T:System.Reflection.Emit.Label"/> for end of method.
            </summary>
            <value>
            	<see cref="T:System.Reflection.Emit.Label"/> for end of method.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.Reflection.TracingILGenerator.EndOfCurrentExceptionBlock">
            <summary>
            	Get <see cref="T:System.Reflection.Emit.Label"/> for end of current exception blocks.
            </summary>
            <value>
            	<see cref="T:System.Reflection.Emit.Label"/> for end of current exception blocks.
            	When there are no exception blocks, then null.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.Reflection.TracingILGenerator.IsInExceptionBlock">
            <summary>
            	Get whether there are any exception blocks in current positon.
            </summary>
            <value>
            	If there are any exception blocks in current positon then <c>true</c>; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.Reflection.TracingILGenerator.IsInDynamicMethod">
            <summary>
            	Get the value whether this instance used for dynamic method.
            </summary>
            <value>If  this instance used for dynamic method then <c>true</c>; otherwise <c>false</c>.</value>
            <remarks>
            	Dynamic method does not support debugging information like local variable name.
            </remarks>
        </member>
        <member name="P:MsgPack.Serialization.Reflection.TracingILGenerator.IndentLevel">
            <summary>
            	Get level of indentation.
            </summary>
        </member>
        <member name="P:MsgPack.Serialization.Reflection.TracingILGenerator.IndentCharacters">
            <summary>
            	Get or set indent characters.
            </summary>
            <value>
            	<see cref="T:System.String"/> to be used to indent.
            	To reset default, specify null.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.Reflection.TracingILGenerator.LineNumber">
            <summary>
            	Get current line number.
            </summary>
            <value>Current line number.</value>
        </member>
        <member name="P:MsgPack.Serialization.Reflection.TracingILGenerator.IsEnded">
            <summary>
            	Get whether this IL stream is ended with 'ret'.
            </summary>
            <returns>
            	When this IL stream is ended with 'ret' then <c>true</c>; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:MsgPack.Serialization.Reflection.GenericTypeExtensions">
            <summary>
            	Define utility extension method for generic type.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.GenericTypeExtensions.Implements(System.Type,System.Type)">
            <summary>
            	Determine whether the source type implements specified generic type or its built type.
            </summary>
            <param name="source">Target type.</param>
            <param name="genericType">Generic interface type.</param>
            <returns>
            	<c>true</c> if <paramref name="source"/> implements <paramref name="genericType"/>,
            	or built closed generic interface type;
            	otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.GenericTypeExtensions.GetName(System.Type)">
            <summary>
            	Get name of type without namespace and assembly name of itself and its generic arguments.
            </summary>
            <param name="source">Target type.</param>
            <returns>Simple name of type.</returns>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.GenericTypeExtensions.GetFullName(System.Type)">
            <summary>
            	Get full name of type including namespace and excluding assembly name of itself and its generic arguments.
            </summary>
            <param name="source">Target type.</param>
            <returns>Full name of type.</returns>
        </member>
        <member name="T:MsgPack.Serialization.LazyDelegatingMessagePackSerializer`1">
            <summary>
            	Lazy initialized serializer which delegates actual work for the other serializer implementation.
            </summary>
            <typeparam name="T">
            	The type of target type.
            </typeparam>
            <remarks>
            	This serializer is intended to support self-composit structure like directories or XML nodes.
            </remarks>
        </member>
        <member name="M:MsgPack.Serialization.LazyDelegatingMessagePackSerializer`1.#ctor(MsgPack.Serialization.SerializationContext)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.LazyDelegatingMessagePackSerializer`1"/> class.
            </summary>
            <param name="context">
            	The serialization context to support lazy retrieval.
            </param>
        </member>
        <member name="T:MsgPack.Serialization.EmittingSerializers.ContextBasedSerializerEmitter">
            <summary>
            	<see cref="T:MsgPack.Serialization.EmittingSerializers.SerializerEmitter"/> using <see cref="T:MsgPack.Serialization.SerializationContext"/> to hold serializers for target members.
            </summary>
        </member>
        <member name="T:MsgPack.Serialization.EmittingSerializers.SerializerEmitter">
            <summary>
            	Genereates serialization methods which can be save to file.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializerEmitter.FlushTrace">
            <summary>
            	Flushes the trace.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializerEmitter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializerEmitter"/> class.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializerEmitter.Dispose">
            <summary>
            	Releases all managed resources.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializerEmitter.Dispose(System.Boolean)">
            <summary>
            	Releases unmanaged and optionally managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializerEmitter.GetPackToMethodILGenerator">
            <summary>
            	Gets the IL generator to implement <see cref="M:MessagePackSerializer{T}.PackToCore"/> overrides.
            </summary>
            <returns>
            	The IL generator to implement <see cref="M:MessagePackSerializer{T}.PackToCore"/> overrides.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializerEmitter.GetUnpackFromMethodILGenerator">
            <summary>
            	Gets the IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackFromCore"/> overrides.
            </summary>
            <returns>
            	The IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackFromCore"/> overrides.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializerEmitter.GetUnpackToMethodILGenerator">
            <summary>
            	Gets the IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackToCore"/> overrides.
            </summary>
            <returns>
            	The IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackToCore"/> overrides.
            </returns>
            <remarks>
            	When this method is called, <see cref="M:MessagePackSerializer{T}.UnpackToCore"/> will be overridden.
            	This value will not be <c>null</c>.
            </remarks>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializerEmitter.CreateInstance``1(MsgPack.Serialization.SerializationContext)">
            <summary>
            	Creates the serializer type built now and returns its new instance.
            </summary>
            <typeparam name="T">Target type to be serialized/deserialized.</typeparam>
            <param name="context">The <see cref="T:MsgPack.Serialization.SerializationContext"/> to holds serializers.</param>
            <returns>
            	Newly built <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> instance.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializerEmitter.RegisterSerializer(System.Type)">
            <summary>
            	Regisgter using <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> target type to the current emitting session.
            </summary>
            <param name="targetType">Type to be serialized/deserialized.</param>
            <returns>
            	<see cref="T:System.Action`2"/> to emit serializer retrieval instructions.
            	The 1st argument should be <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/> to emit instructions.
            	The 2nd argument should be argument index of the serializer holder.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="P:MsgPack.Serialization.EmittingSerializers.SerializerEmitter.IsTraceEnabled">
            <summary>
            	 Gets a value indicating whether this instance is trace enabled.
            </summary>
            <value>
            	<c>true</c> if the trace enabled; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.EmittingSerializers.SerializerEmitter.Trace">
            <summary>
            	Gets the <see cref="T:System.IO.TextWriter"/> for tracing.
            </summary>
            <value>
            	The <see cref="T:System.IO.TextWriter"/> for tracing.
            	This value will not be <c>null</c>.
            </value>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.ContextBasedSerializerEmitter.#ctor(System.Type)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.EmittingSerializers.ContextBasedSerializerEmitter"/> class.
            </summary>
            <param name="targetType">Type of the target.</param>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.ContextBasedSerializerEmitter.GetPackToMethodILGenerator">
            <summary>
            	Gets the IL generator to implement <see cref="M:MessagePackSerializer{T}.PackToCore"/> overrides.
            </summary>
            <returns>
            	The IL generator to implement <see cref="M:MessagePackSerializer{T}.PackToCore"/> overrides.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.ContextBasedSerializerEmitter.GetUnpackFromMethodILGenerator">
            <summary>
            	Gets the IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackFromCore"/> overrides.
            </summary>
            <returns>
            	The IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackFromCore"/> overrides.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.ContextBasedSerializerEmitter.GetUnpackToMethodILGenerator">
            <summary>
            	Gets the IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackToCore"/> overrides.
            </summary>
            <returns>
            	The IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackToCore"/> overrides.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.ContextBasedSerializerEmitter.CreateInstance``1(MsgPack.Serialization.SerializationContext)">
            <summary>
            	Creates the serializer type built now and returns its new instance.
            </summary>
            <typeparam name="T">Target type to be serialized/deserialized.</typeparam>
            <param name="context">The <see cref="T:MsgPack.Serialization.SerializationContext"/> to holds serializers.</param>
            <returns>
            	Newly built <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> instance.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.ContextBasedSerializerEmitter.RegisterSerializer(System.Type)">
            <summary>
            	Regisgter using <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> target type to the current emitting session.
            </summary>
            <param name="targetType">Type to be serialized/deserialized.</param>
            <returns>
              <see cref="T:System.Action`2"/> to emit serializer retrieval instructions.
            	The 1st argument should be <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/> to emit instructions.
            	The 2nd argument should be argument index of the serializer holder.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="T:MsgPack.Serialization.CallbackMessagePackSerializer`1">
            <summary>
            	Callback based <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> to implement context-based serialization.
            </summary>
            <typeparam name="T">The type of target type.</typeparam>
        </member>
        <member name="T:MsgPack.Float32Bits">
            <summary>
            	Provides bit access for <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="F:MsgPack.Float32Bits.Value">
            <summary>
            	Value as <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="F:MsgPack.Float32Bits.Byte0">
            <summary>
            	Most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float32Bits.Byte1">
            <summary>
            	2nd bit from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float32Bits.Byte2">
            <summary>
            	3rd byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float32Bits.Byte3">
            <summary>
            	Least byte of current endian.
            </summary>
        </member>
        <member name="M:MsgPack.Float32Bits.#ctor(System.Single)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Float32Bits"/> type from specified <see cref="T:System.Single"/>.
            </summary>
            <param name="value">Value of <see cref="T:System.Single"/>.</param>
        </member>
        <member name="M:MsgPack.Float32Bits.#ctor(System.Byte[],System.Int32)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Float32Bits"/> type from specified <see cref="T:System.Byte"/>[] which is big endian.
            </summary>
            <param name="bigEndianBytes">Array of <see cref="T:System.Byte"/> which contains bytes in big endian.</param>
            <param name="offset">Offset to read.</param>
        </member>
        <member name="T:MsgPack.UnpackingStreamReader">
            <summary>
            	Implements <see cref="T:System.IO.TextReader"/> which reads raw binary <see cref="T:System.IO.Stream"/> with specific <see cref="T:System.Text.Encoding"/>.
            </summary>
        </member>
        <member name="P:MsgPack.UnpackingStreamReader.ByteLength">
            <summary>
            	Gets the length of the underlying raw binary length.
            </summary>
            <value>
            	The length of the underlying raw binary length.
            	This value will not be negative.
            </value>
        </member>
        <member name="T:MsgPack.Serialization.IdentifierUtility">
            <summary>
            	Utilities related to member/type ID.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.IdentifierUtility.BuildMethodName(System.String,System.Type,System.String)">
            <summary>
            	Builds the name of the generating method.
            </summary>
            <param name="operation">The operation.</param>
            <param name="targetType">Type of the target.</param>
            <param name="targetMemberName">Name of the target member.</param>
            <returns>Name of the method.</returns>
        </member>
        <member name="T:MsgPack.Serialization.ExpressionSerializers.MapExpressionMessagePackSerializer`1">
            <summary>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> for a map collection using expression tree.
            </summary>
            <typeparam name="T">The type of element.</typeparam>
        </member>
        <member name="T:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilder`1">
            <summary>
            	Implements common features code generation based serializer builders.
            </summary>
            <typeparam name="TObject">The type of the serialization target.</typeparam>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilder`1.#ctor(MsgPack.Serialization.SerializationContext)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilder`1"/> class.
            </summary>
            <param name="context">The <see cref="T:MsgPack.Serialization.SerializationContext"/>.</param>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilder`1.CreateSerializer(MsgPack.Serialization.SerializingMember[])">
            <summary>
            	Creates serializer for <typeparamref name="TObject"/>.
            </summary>
            <param name="entries">Serialization target members. This will not be <c>null</c> nor empty.</param>
            <returns>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>. This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilder`1.EmitPackMembers(MsgPack.Serialization.EmittingSerializers.SerializerEmitter,MsgPack.Serialization.Reflection.TracingILGenerator,MsgPack.Serialization.SerializingMember[])">
            <summary>
            	Emits the ILs to pack the members of the current type.
            </summary>
            <param name="emitter"><see cref="T:MsgPack.Serialization.EmittingSerializers.SerializerEmitter"/> holding emittion context information.</param>
            <param name="packerIL"><see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/> to emit IL.</param>
            <param name="entries">The array of <see cref="T:MsgPack.Serialization.SerializingMember"/>s where each represents the member to be (de)serialized.</param>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilder`1.CreateArraySerializer">
            <summary>
            	Creates serializer as <typeparamref name="TObject"/> is array type.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>. 
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilder`1.CreateMapSerializer">
            <summary>
            	Creates serializer as <typeparamref name="TObject"/> is map type.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>. 
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilder`1.CreateTupleSerializer">
            <summary>
            	Creates serializer as <typeparamref name="TObject"/> is tuple type.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>. 
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="T:MsgPack.Float64Bits">
            <summary>
            	Provides bit access for <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Value">
            <summary>
            	Value as <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte0">
            <summary>
            	Most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte1">
            <summary>
            	2nd bit from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte2">
            <summary>
            	3rd byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte3">
            <summary>
            	4th byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte4">
            <summary>
            	5th byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte5">
            <summary>
            	6th byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte6">
            <summary>
            	7th byte from most significant byte of current endian.
            </summary>
        </member>
        <member name="F:MsgPack.Float64Bits.Byte7">
            <summary>
            	Least significant byte of current endian.
            </summary>
        </member>
        <member name="M:MsgPack.Float64Bits.#ctor(System.Double)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Float64Bits"/> type from specified <see cref="T:System.Double"/>.
            </summary>
            <param name="value">Value of <see cref="T:System.Double"/>.</param>
        </member>
        <member name="M:MsgPack.Float64Bits.#ctor(System.Byte[],System.Int32)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Float64Bits"/> type from specified <see cref="T:System.Byte"/>[] which is big endian.
            </summary>
            <param name="bigEndianBytes">Array of <see cref="T:System.Byte"/> which contains bytes in big endian.</param>
            <param name="offset">Offset to read.</param>
        </member>
        <member name="T:MsgPack.DictionaryDebuggerProxy`2">
            <summary>
            	Debugger type proxy for <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The key type of the dictionary.</typeparam>
            <typeparam name="TValue">The value type of the dictionary.</typeparam>
        </member>
        <member name="T:MsgPack.Unpacking">
            <summary>
            	Defines direct conversion value from/to Message Pack binary stream without intermediate <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <remarks>
            	This class provides convinient way to unpack objects from wellknown seekable stream.
            	This class does not support stream feeding.
            </remarks>
            <seealso cref="T:MsgPack.Unpacker"/>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackByte(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Byte"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Byte"/> which contains unpacked <see cref="T:System.Byte"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackByte(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackByte(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Byte"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Byte"/> which contains unpacked <see cref="T:System.Byte"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackByte(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Byte"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Byte"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSByte(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.SByte"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.SByte"/> which contains unpacked <see cref="T:System.SByte"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.SByte"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackSByte(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSByte(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.SByte"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.SByte"/> which contains unpacked <see cref="T:System.SByte"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.SByte"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSByte(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.SByte"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.SByte"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.SByte"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt16(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Int16"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int16"/> which contains unpacked <see cref="T:System.Int16"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int16"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackInt16(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt16(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Int16"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int16"/> which contains unpacked <see cref="T:System.Int16"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int16"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt16(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Int16"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Int16"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int16"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt16(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.UInt16"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt16"/> which contains unpacked <see cref="T:System.UInt16"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt16"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackUInt16(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt16(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.UInt16"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt16"/> which contains unpacked <see cref="T:System.UInt16"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt16"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt16(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.UInt16"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.UInt16"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt16"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt32(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Int32"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int32"/> which contains unpacked <see cref="T:System.Int32"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int32"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackInt32(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt32(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Int32"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int32"/> which contains unpacked <see cref="T:System.Int32"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int32"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt32(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Int32"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Int32"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int32"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt32(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.UInt32"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt32"/> which contains unpacked <see cref="T:System.UInt32"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt32"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackUInt32(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt32(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.UInt32"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt32"/> which contains unpacked <see cref="T:System.UInt32"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt32"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt32(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.UInt32"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.UInt32"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt32"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt64(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Int64"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int64"/> which contains unpacked <see cref="T:System.Int64"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackInt64(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt64(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Int64"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Int64"/> which contains unpacked <see cref="T:System.Int64"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackInt64(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Int64"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Int64"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Int64"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt64(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.UInt64"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt64"/> which contains unpacked <see cref="T:System.UInt64"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt64"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackUInt64(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt64(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.UInt64"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.UInt64"/> which contains unpacked <see cref="T:System.UInt64"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt64"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackUInt64(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.UInt64"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.UInt64"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.UInt64"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSingle(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Single"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Single"/> which contains unpacked <see cref="T:System.Single"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Single"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackSingle(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSingle(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Single"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Single"/> which contains unpacked <see cref="T:System.Single"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Single"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackSingle(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Single"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Single"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Single"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDouble(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.Double"/> value from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Double"/> which contains unpacked <see cref="T:System.Double"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Double"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackDouble(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDouble(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.Double"/> value from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Double"/> which contains unpacked <see cref="T:System.Double"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Double"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDouble(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.Double"/> value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.Double"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Double"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.Byte[])">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from the head of specified byte array with UTF-8 encoding.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.String"/> which contains unpacked <see cref="T:System.String"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.String"/>.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as UTF-8 encoded byte stream.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Text.Encoding)">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from the head of specified byte array with specified encoding.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> to decode binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.String"/> which contains unpacked <see cref="T:System.String"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            	Or, <paramref name="encoding"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.String"/>.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as UTF-8 encoded byte stream.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32)">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from specified offsetted byte array with UTF-8 encoding.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.String"/> which contains unpacked <see cref="T:System.String"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not greater than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.String"/>.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as specified encoding byte stream.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32,System.Text.Encoding)">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from specified offsetted byte array with specified encoding.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> to decode binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.String"/> which contains unpacked <see cref="T:System.String"/> value and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            	Or, <paramref name="encoding"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not greater than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.String"/>.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as specified encoding byte stream.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackString(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.IO.Stream)">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from the specified <see cref="T:System.IO.Stream"/> with UTF-8 encoding.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.String"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not raw binary.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as UTF-8 encoded byte stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackString(System.IO.Stream,System.Text.Encoding)">
            <summary>
            	Unpacks <see cref="T:System.String"/> value from the specified <see cref="T:System.IO.Stream"/> with specified encoding.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> to decode binary stream.</param>
            <returns>
            	The unpacked <see cref="T:System.String"/> value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            	Or <paramref name="encoding"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not raw binary.
            	Or, the unpacked result in the <paramref name="source"/> is invalid as specified encoding byte stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackByteStream(System.IO.Stream)">
            <summary>
            	Unpacks raw value from the specified <see cref="T:System.IO.Stream"/> as <see cref="T:MsgPack.UnpackingStream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingStream"/> which represents raw value stream.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not raw binary.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		<see cref="T:MsgPack.UnpackingStream"/> does not own <paramref name="source"/>, so <paramref name="source"/> still should be closed.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackCharStream(System.IO.Stream)">
            <summary>
            	Unpacks raw value from the specified <see cref="T:System.IO.Stream"/> as <see cref="T:MsgPack.UnpackingStreamReader"/> with UTF-8 encoding.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingStreamReader"/> which represents raw value stream as UTF-8 string.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not raw binary.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		if <paramref name="source"/> contains invalid sequence as UTF-8 encoding string,
            		the <see cref="T:System.Text.DecoderFallbackException"/> may occurs on read char.
            	</para>
            	<para>
            		<see cref="T:MsgPack.UnpackingStreamReader"/> does not own <paramref name="source"/>, so <paramref name="source"/> still should be closed.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackCharStream(System.IO.Stream,System.Text.Encoding)">
            <summary>
            	Unpacks raw value from the specified <see cref="T:System.IO.Stream"/> as <see cref="T:MsgPack.UnpackingStreamReader"/> with specified encoding.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> to decode binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingStreamReader"/> which represents raw value stream as UTF-8 string.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            	Or, <paramref name="encoding"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not raw binary.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		if <paramref name="source"/> contains invalid sequence as specified encoding string,
            		the <see cref="T:System.Text.DecoderFallbackException"/> may occurs on read char.
            	</para>
            	<para>
            		<see cref="T:MsgPack.UnpackingStreamReader"/> does not own <paramref name="source"/>, so <paramref name="source"/> still should be closed.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>		
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArray(System.Byte[])">
            <summary>
            	Unpacks the array from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Collections.Generic.IList`1"/> which contains unpacked the array and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackArray(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArray(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the array from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Collections.Generic.IList`1"/> which contains unpacked the array and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArray(System.IO.Stream)">
            <summary>
            	Unpacks the array value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the array value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Collections.Generic.IList`1"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArrayLength(System.Byte[])">
            <summary>
            	Unpacks length of the array from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of nullable <see cref="T:System.Int64"/> which contains unpacked length of the array and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackArrayLength(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArrayLength(System.Byte[],System.Int32)">
            <summary>
            	Unpacks length of the array from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of nullable <see cref="T:System.Int64"/> which contains unpacked length of the array and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackArrayLength(System.IO.Stream)">
            <summary>
            	Unpacks length of the array value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked length of the array value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionary(System.Byte[])">
            <summary>
            	Unpacks the dictionary from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:MsgPack.MessagePackObjectDictionary"/> which contains unpacked the dictionary and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackDictionary(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionary(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the dictionary from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:MsgPack.MessagePackObjectDictionary"/> which contains unpacked the dictionary and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionary(System.IO.Stream)">
            <summary>
            	Unpacks the dictionary value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the dictionary value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionaryCount(System.Byte[])">
            <summary>
            	Unpacks count of the dictionary entries from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of nullable <see cref="T:System.Int64"/> which contains unpacked count of the dictionary entries and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackDictionaryCount(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionaryCount(System.Byte[],System.Int32)">
            <summary>
            	Unpacks count of the dictionary entries from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of nullable <see cref="T:System.Int64"/> which contains unpacked count of the dictionary entries and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackDictionaryCount(System.IO.Stream)">
            <summary>
            	Unpacks count of the dictionary entries value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked count of the dictionary entries value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to nullable <see cref="T:System.Int64"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBinary(System.Byte[])">
            <summary>
            	Unpacks the raw binary from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Byte"/>[] which contains unpacked the raw binary and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>[].
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackBinary(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBinary(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the raw binary from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Byte"/>[] which contains unpacked the raw binary and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>[].
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBinary(System.IO.Stream)">
            <summary>
            	Unpacks the raw binary value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the raw binary value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Byte"/>[].
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageNotSupportedException">
            	The items count of the underlying collection body is over <see cref="F:System.Int32.MaxValue"/>.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBoolean(System.Byte[])">
            <summary>
            	Unpacks the boolean from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Boolean"/> which contains unpacked the boolean and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Boolean"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackBoolean(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBoolean(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the boolean from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Boolean"/> which contains unpacked the boolean and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Boolean"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackBoolean(System.IO.Stream)">
            <summary>
            	Unpacks the boolean value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the boolean value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Boolean"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackNull(System.Byte[])">
            <summary>
            	Unpacks the nil from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Object"/> which contains unpacked the nil and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Object"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackNull(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackNull(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the nil from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:System.Object"/> which contains unpacked the nil and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Object"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackNull(System.IO.Stream)">
            <summary>
            	Unpacks the nil value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the nil value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:System.Object"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackObject(System.Byte[])">
            <summary>
            	Unpacks the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. from the head of specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:MsgPack.MessagePackObject"/> which contains unpacked the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObject"/>.
            </exception>
            <remarks>
            	<para>
            		Invocation of this method is equivalant to call <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> with <c>offset</c> is <c>0</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[])"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)">
            <summary>
            	Unpacks the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. from the specified byte array.
            </summary>
            <param name="source">The byte array which contains Message Pack binary stream.</param>
            <param name="offset">The offset to be unpacking start with.</param>
            <returns>
            	The <see cref="T:MsgPack.UnpackingResult`1"/> of <see cref="T:MsgPack.MessagePackObject"/> which contains unpacked the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. and processed bytes count.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="source"/> is empty.
            	Or, the length of <paramref name="source"/> is not grator than <paramref name="offset"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> is negative value.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObject"/>.
            </exception>
            <remarks>
            	When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.Byte[],System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)">
            <summary>
            	Unpacks the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. value from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="source">The <see cref="T:System.IO.Stream"/> which contains Message Pack binary stream.</param>
            <returns>
            	The unpacked the <see cref="T:MsgPack.MessagePackObject"/> which represents the value which has MessagePack type semantics. value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="source"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The <see cref="P:Stream.CanRead"/> of <paramref name="source"/> is <c>false</c>.
            </exception>
            <exception cref="T:MsgPack.UnpackException">
            	<paramref name="source"/> is not valid MessagePack stream.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <exception cref="T:MsgPack.MessageTypeException">
            	The unpacked result in the <paramref name="source"/> is not compatible to <see cref="T:MsgPack.MessagePackObject"/>.
            	Note that the state of <paramref name="source"/> will be unpredictable espicially it is not seekable.
            </exception>
            <remarks>
            	<para>
            		The processed bytes count can be calculated via <see cref="P:Stream.Position"/> of <paramref name="source"/> when the <see cref="P:Stream.CanSeek"/> is <c>true</c>.
            	</para>
            	<para>
            		When the type of packed value is not known, use <see cref="M:MsgPack.Unpacking.UnpackObject(System.IO.Stream)"/> instead.
            	</para>
            </remarks>
        </member>
        <member name="T:MsgPack.UnpackingStream">
            <summary>
            	Represents raw binary as read only <see cref="T:System.IO.Stream"/>.
            </summary>
            <remarks>
            	<para>
            		This object behaves as wrapper of the underlying <see cref="T:System.IO.Stream"/> which contains message pack encoded byte array.
            		But, this object does not own the stream, so that stream is not closed when this stream is closed.
            	</para>
            	<para>
            		The value of <see cref="M:Stream.CanSeek"/>, timeout, and async API depends on the underlying stream.
            	</para>
            </remarks>
        </member>
        <member name="M:MsgPack.UnpackingStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            	Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <param name="buffer">
            	An array of bytes. When this method returns, 
            	the buffer contains the specified byte array with the values between <paramref name="offset"/> and ( <paramref name="offset"/> + <paramref name="count"/> - 1) 
            	replaced by the bytes read from the current source. 
            </param>
            <param name="offset">
            	The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream.
            </param>
            <param name="count">
            	The maximum number of bytes to be read from the current stream.
            </param>
            <returns>
            	The total number of bytes read into the buffer. 
            	This can be less than the number of bytes requested if that many bytes are not currently available,
            	or zero (0) if the end of the stream has been reached.
            </returns>
            <exception cref="T:System.ArgumentException">
            	The sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="buffer"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="offset"/> or <paramref name="count"/> is negative. 
            </exception>
            <exception cref="T:System.IO.IOException">
            	An I/O error occurs.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            	Methods were called after the stream was closed.
            </exception>
            <remarks>
            	<note>
            		Arguments might be passed to the underlying <see cref="T:System.IO.Stream"/> without any validation.
            	</note>
            </remarks>
        </member>
        <member name="M:MsgPack.UnpackingStream.Flush">
            <summary>
            	Overrides <see cref="M:Stream.Flush()"/> so that no action is performed. 
            </summary>
        </member>
        <member name="M:MsgPack.UnpackingStream.SetLength(System.Int64)">
            <summary>
            	Throws <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="value">Never used.</param>
            <exception cref="T:System.NotSupportedException">
            	Always thrown.
            </exception>
        </member>
        <member name="M:MsgPack.UnpackingStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            	Throws <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="buffer">Never used.</param>
            <param name="offset">Never used.</param>
            <param name="count">Never used.</param>
            <exception cref="T:System.NotSupportedException">
            	Always thrown.
            </exception>
        </member>
        <member name="P:MsgPack.UnpackingStream.CanRead">
            <summary>
            	Gets a value indicating whether the current stream supports reading.
            </summary>
            <value>Always <c>true</c>.</value>
        </member>
        <member name="P:MsgPack.UnpackingStream.CanWrite">
            <summary>
            	Gets a value indicating whether the current stream supports writing.
            </summary>
            <value>Always <c>false</c>.</value>
        </member>
        <member name="P:MsgPack.UnpackingStream.Length">
            <summary>
            	Gets the length in bytes of the stream.
            </summary>
            <value>
            	A long value representing the length of the raw binary length.
            	This value must be between 0 and <see cref="F:System.Int32.MaxValue"/>.
            </value>
            <exception cref="T:System.ObjectDisposedException">
            	Methods were called after the stream was closed.
            </exception>
            <remarks>
            	This property never throws <see cref="T:System.NotSupportedException"/> even if <see cref="M:Stream.CanSeek"/> is <c>false</c>.
            </remarks>
        </member>
        <member name="P:MsgPack.UnpackingStream.CanTimeout">
            <summary>
            	Gets a value that determines whether the current stream can time out.
            </summary>
            <value>
            	A value that determines whether the current stream can time out.
            </value>
            <exception cref="T:System.ObjectDisposedException">
            	Methods were called after the stream was closed.
            </exception>
        </member>
        <member name="T:MsgPack.StreamPacker">
            <summary>
            	Basic <see cref="T:MsgPack.Packer"/> implementation using managed <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="T:MsgPack.Packer">
            <summary>
            	Implements serialization feature of MsgPack.
            </summary>
        </member>
        <member name="M:MsgPack.Packer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MsgPack.Packer"/> class.
            </summary>
        </member>
        <member name="M:MsgPack.Packer.Create(System.IO.Stream)">
            <summary>
            	Create standard Safe <see cref="T:MsgPack.Packer"/> instancde wrapping specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream"><see cref="T:System.IO.Stream"/> object. This stream will be closed when <see cref="M:MsgPack.Packer.Dispose(System.Boolean)"/> is called.</param>
            <returns>Safe <see cref="T:MsgPack.Packer"/>. This will not be null.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
            <remarks>
            	 You can specify any derived <see cref="T:System.IO.Stream"/> class like <see cref="T:System.IO.FileStream"/>, <see cref="T:System.IO.MemoryStream"/>,
            	 NetworkStream, <see cref="T:System.IO.UnmanagedMemoryStream"/>, or so.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.Create(System.IO.Stream,System.Boolean)">
            <summary>
            	Create standard Safe <see cref="T:MsgPack.Packer"/> instancde wrapping specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream"><see cref="T:System.IO.Stream"/> object.</param>
            <param name="ownsStream">
            	<c>true</c> to close <paramref name="stream"/> when this instance is disposed;
            	<c>false</c>, otherwise.
            </param>
            <returns>Safe <see cref="T:MsgPack.Packer"/>. This will not be null.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
            <remarks>
            	 You can specify any derived <see cref="T:System.IO.Stream"/> class like <see cref="T:System.IO.FileStream"/>, <see cref="T:System.IO.MemoryStream"/>,
            	 NetworkStream, <see cref="T:System.IO.UnmanagedMemoryStream"/>, or so.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.Dispose">
            <summary>
            	Clean up internal resources.
            </summary>
        </member>
        <member name="M:MsgPack.Packer.Dispose(System.Boolean)">
            <summary>
            	When overridden by derived class, release all unmanaged resources, optionally release managed resources.
            </summary>
            <param name="disposing">If true, release managed resources too.</param>
        </member>
        <member name="M:MsgPack.Packer.SeekTo(System.Int64)">
            <summary>
            	When overridden by derived class, change current position to specified offset.
            </summary>
            <param name="offset">Offset. You shoud not specify the value which causes underflow or overflow.</param>
            <exception cref="T:System.NotSupportedException">
            	A class of this instance does not support seek.
            </exception>
        </member>
        <member name="M:MsgPack.Packer.WriteByte(System.Byte)">
            <summary>
            	When overridden by derived class, writes specified byte to stream using implementation specific manner.
            </summary>
            <param name="value">A byte to be written.</param>
        </member>
        <member name="M:MsgPack.Packer.WriteBytes(System.Collections.Generic.ICollection{System.Byte})">
            <summary>
            	Writes specified bytes to stream using implementation specific most efficient manner.
            </summary>
            <param name="value">Collection of bytes to be written.</param>
        </member>
        <member name="M:MsgPack.Packer.WriteBytes(System.Byte[],System.Boolean)">
            <summary>
            	Writes specified bytes to stream using implementation specific most efficient manner.
            </summary>
            <param name="value">Bytes to be written.</param>
            <param name="isImmutable">If the <paramref name="value"/> can be treat as immutable (that is, can be used safely without copying) then <c>true</c>.</param>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.SByte)">
            <summary>
            	Pack <see cref="T:System.SByte"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.SByte"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackInt8(System.Int64)">
            <summary>
            	Try pack <see cref="T:System.SByte"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.SByte"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Byte)">
            <summary>
            	Pack <see cref="T:System.Byte"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackUInt8(System.UInt64)">
            <summary>
            	Try pack <see cref="T:System.Byte"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.Byte"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Int16)">
            <summary>
            	Pack <see cref="T:System.Int16"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Int16"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackInt16(System.Int64)">
            <summary>
            	Try pack <see cref="T:System.Int16"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.Int16"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.UInt16)">
            <summary>
            	Pack <see cref="T:System.UInt16"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.UInt16"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackUInt16(System.UInt64)">
            <summary>
            	Try pack <see cref="T:System.UInt16"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.UInt16"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Int32)">
            <summary>
            	Pack <see cref="T:System.Int32"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Int32"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackInt32(System.Int64)">
            <summary>
            	Try pack <see cref="T:System.Int32"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.Int32"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.UInt32)">
            <summary>
            	Pack <see cref="T:System.UInt32"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.UInt32"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackUInt32(System.UInt64)">
            <summary>
            	Try pack <see cref="T:System.UInt32"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.UInt32"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Int64)">
            <summary>
            	Pack <see cref="T:System.Int64"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Int64"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackInt64(System.Int64)">
            <summary>
            	Try pack <see cref="T:System.Int64"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.Int64"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.UInt64)">
            <summary>
            	Pack <see cref="T:System.UInt64"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.UInt64"/> value.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackUInt64(System.UInt64)">
            <summary>
            	Try pack <see cref="T:System.UInt64"/> value to current stream strictly.
            </summary>
            <param name="value">Maybe <see cref="T:System.UInt64"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Single)">
            <summary>
            	Pack <see cref="T:System.Single"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Single"/> value.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Double)">
            <summary>
            	Pack <see cref="T:System.Double"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Double"/> value.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Boolean)">
            <summary>
            	Pack <see cref="T:System.Boolean"/> value to current stream.
            </summary>
            <param name="value"><see cref="T:System.Boolean"/> value.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.PackArrayHeader(System.Int32)">
            <summary>
            	Bookkeep array length to be packed on current stream.
            </summary>
            <param name="count">Array length.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackArrayHeaderCore(System.Int32)">
            <summary>
            	Bookkeep array length to be packed on current stream.
            </summary>
            <param name="count">Array length.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.PackMapHeader(System.Int32)">
            <summary>
            	Bookkeep dictionary items count to be packed on current stream.
            </summary>
            <param name="count">Dictionary items count.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackMapHeaderCore(System.Int32)">
            <summary>
            	Bookkeep dictionary items count to be packed on current stream.
            </summary>
            <param name="count">Dictionary items count.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.PackRawHeader(System.Int32)">
            <summary>
            	Bookkeep byte length to be packed on current stream.
            </summary>
            <param name="length">Byte length.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackRawHeaderCore(System.Int32)">
            <summary>
            	Bookkeep byte length to be packed on current stream.
            </summary>
            <param name="length">Byte length.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.PackRaw(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            	Pack specified byte stream to current stream.
            </summary>
            <param name="value">Source bytes its size is not known.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackRaw(System.Collections.Generic.IList{System.Byte})">
            <summary>
            	Pack specified byte stream to current stream.
            </summary>
            <param name="value">Source bytes its size is known.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackRaw(System.Byte[])">
            <summary>
            	Pack specified byte array to current stream.
            </summary>
            <param name="value">Source byte array.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackRawBody(System.Byte[])">
            <summary>
            	Pack specified byte array to current stream without any header.
            </summary>
            <param name="value">Source byte array.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
            <remarks>
            	If you forget to write header first, then resulting stream will be corrupsed.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackRawBody(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            	Packs specified byte sequence to current stream without any header.
            </summary>
            <param name="value">Source byte array.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
            <remarks>
            	If you forget to write header first, then resulting stream will be corrupsed.
            </remarks>
        </member>
        <member name="M:MsgPack.Packer.PackString(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            	Pack specified char stream to current stream with UTF-8 <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source chars its size is not known.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackString(System.String)">
            <summary>
            	Pack specified string to current stream with UTF-8 <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source string.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackString(System.Collections.Generic.IEnumerable{System.Char},System.Text.Encoding)">
            <summary>
            	Pack specified char stream to current stream with specified <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source chars its size is not known.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to be used.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackString(System.String,System.Text.Encoding)">
            <summary>
            	Pack specified string to current stream with specified <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source string.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to be used.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackStringCore(System.Collections.Generic.IEnumerable{System.Char},System.Text.Encoding)">
            <summary>
            	Pack specified char stream to current stream with specified <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source chars its size is not known.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to be used.</param>
        </member>
        <member name="M:MsgPack.Packer.PackStringCore(System.String,System.Text.Encoding)">
            <summary>
            	Pack specified string to current stream with specified <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="value">Source string.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to be used.</param>
        </member>
        <member name="M:MsgPack.Packer.PackArrayHeader``1(System.Collections.Generic.IList{``0})">
            <summary>
            	Bookkeep collection count to be packed on current stream.
            </summary>
            <param name="array">Collection count to be written.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.PackMapHeader``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            	Bookkeep dictionary count to be packed on current stream.
            </summary>
            <param name="map">Dictionary count to be written.</param>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.TryPackTinySignedInteger(System.Int64)">
            <summary>
            	Try pack <see cref="T:System.SByte"/> value to current stream as tiny fix num.
            </summary>
            <param name="value">Maybe tiny <see cref="T:System.SByte"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.TryPackTinyUnsignedInteger(System.UInt64)">
            <summary>
            	Try pack <see cref="T:System.Byte"/> value to current stream as tiny fix num.
            </summary>
            <param name="value">Maybe tiny <see cref="T:System.Byte"/> value.</param>
            <returns>If <paramref name="value"/> has be packed successfully then true, otherwise false (normally, larger type required).</returns>
        </member>
        <member name="M:MsgPack.Packer.PackNull">
            <summary>
            	Pack a null value to current stream.
            </summary>
            <returns>This instance.</returns>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed.</exception>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.SByte})">
            <summary>
            	Pack nullable <see cref="T:System.SByte"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Byte})">
            <summary>
            	Pack nullable <see cref="T:System.Byte"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Int16})">
            <summary>
            	Pack nullable <see cref="T:System.Int16"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.UInt16})">
            <summary>
            	Pack nullable <see cref="T:System.UInt16"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Int32})">
            <summary>
            	Pack nullable <see cref="T:System.Int32"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.UInt32})">
            <summary>
            	Pack nullable <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Int64})">
            <summary>
            	Pack nullable <see cref="T:System.Int64"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.UInt64})">
            <summary>
            	Pack nullable <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Single})">
            <summary>
            	Pack nullable <see cref="T:System.Single"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Double})">
            <summary>
            	Pack nullable <see cref="T:System.Double"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="M:MsgPack.Packer.Pack(System.Nullable{System.Boolean})">
            <summary>
            	Pack nullable <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="value">Value to serialize.</param>
            <returns>This packer instance.</returns>
        </member>
        <member name="P:MsgPack.Packer.CanSeek">
            <summary>
            	Get whether this class supports seek operation and quering <see cref="P:MsgPack.Packer.Position"/> property.
            </summary>
            <value>If this class supports seek operation and quering <see cref="P:MsgPack.Packer.Position"/> property then true.</value>
        </member>
        <member name="P:MsgPack.Packer.Position">
            <summary>
            	Get current position of underlying stream.
            </summary>
            <value>Opaque position value of underlying stream.</value>
            <exception cref="T:System.NotSupportedException">
            	A class of this instance does not support seek.
            </exception>
        </member>
        <member name="T:MsgPack.Serialization.SerializerGenerator">
            <summary>
            	Provides pre-compiled serialier assembly generation.
            </summary>
            <remarks>
            	Currently, generated assembly has some restrictions:
            	<list type="bullet">
            		<item>
            			The type name cannot be customize. It always to be <c>MsgPack.Serialization.EmittingSerializers.Generated.&lt;ESCAPED_TARGET_NAME&gt;Serializer</c>.
            			Note that the <c>ESCAPED_TARGET_NAME</c> is the string generated by replacing type delimiters with undersecore ('_'). 
            		</item>
            		<item>
            			The assembly cannot be used on WinRT because 
            		</item>
            	</list>
            	<note>
            		You should <strong>NOT</strong> assume at all like class hierarchy of generated type, its implementing interfaces, custom attributes, or dependencies.
            		They subject to be changed in the future.
            		If you want to get such fine grained control for them, you should implement own hand made serializers.
            	</note>
            </remarks>
        </member>
        <member name="M:MsgPack.Serialization.SerializerGenerator.#ctor(System.Type,System.Reflection.AssemblyName)">
            <summary>
            Initializes a new instance of the <see cref="T:MsgPack.Serialization.SerializerGenerator"/> class.
            </summary>
            <param name="rootType">Type of the root object which will be serialized/deserialized.</param>
            <param name="assemblyName">Name of the assembly to be generated.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="rootType"/> is <c>null</c>.
            	Or <paramref name="assemblyName"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.SerializerGenerator.GenerateAssemblyFile">
            <summary>
            	Generates the serializer assembly and save it to current directory.
            	</summary>
        </member>
        <member name="P:MsgPack.Serialization.SerializerGenerator.RootType">
            <summary>
            	Gets the type of the root object which will be serialized/deserialized.
            </summary>
            <value>
            	The type of the root object which will be serialized/deserialized.
            	This value will not be <c>null</c>.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.SerializerGenerator.AssemblyName">
            <summary>
            	Gets the name of the assembly to be generated.
            </summary>
            <value>
            	The name of the assembly to be generated.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.SerializerGenerator.Method">
            <summary>
            Gets or sets the <see cref="T:MsgPack.Serialization.SerializationMethod"/> which indicates serialization method to be used.
            </summary>
            <value>
            	The <see cref="T:MsgPack.Serialization.SerializationMethod"/> which indicates serialization method to be used.
            </value>
        </member>
        <member name="T:MsgPack.Serialization.SerializerGenerator.Builder">
            <summary>
            	Defines non-generic interface of actual generic serializer builder.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializerGenerator.Builder.GenerateAssembly(MsgPack.Serialization.SerializationContext,System.Reflection.Emit.AssemblyBuilder)">
            <summary>
            	Generates the assembly and saves it to current directory.
            </summary>
            <param name="context">The dedicated <see cref="T:MsgPack.Serialization.SerializationContext"/>.</param>
            <param name="assemblyBuilder">The dedicated <see cref="T:System.Reflection.Emit.AssemblyBuilder"/>.</param>
        </member>
        <member name="T:MsgPack.Serialization.SerializerGenerator.Builder`1">
            <summary>
            	Actual generic serializer builder.
            </summary>
            <typeparam name="T">The type of root type.</typeparam>
        </member>
        <member name="M:MsgPack.Serialization.SerializerGenerator.Builder`1.GenerateAssembly(MsgPack.Serialization.SerializationContext,System.Reflection.Emit.AssemblyBuilder)">
            <summary>
            	Generates the assembly and saves it to current directory.
            </summary>
            <param name="context">The dedicated <see cref="T:MsgPack.Serialization.SerializationContext"/>.</param>
            <param name="assemblyBuilder">The dedicated <see cref="T:System.Reflection.Emit.AssemblyBuilder"/>.</param>
        </member>
        <member name="T:MsgPack.Serialization.NilImplication">
            <summary>
            	Speifies nil implication in serialization/deserialization.
            </summary>
        </member>
        <member name="F:MsgPack.Serialization.NilImplication.MemberDefault">
            <summary>
            	A nil is interpreted as default value of the member.
            </summary>
            <remarks>
            	<para>
            		This value affects only deserialization.
            	</para>
            	<para>
            		If the unpacking value is nil, the serializer will not set any value to the member.
            	</para>
            	<para>
            		This value corresponds to <c>optional</c> on the IDL.
            	</para>
            	<note>
            		This is default option because the most safe option.
            	</note>
            </remarks>
        </member>
        <member name="F:MsgPack.Serialization.NilImplication.Null">
            <summary>
            	A nil is interpreted as <c>null</c>.
            </summary>
            <remarks>
            	<para>
            		This value affects only deserialization.
            	</para>
            	<para>
            		If the unpacking value is nil, the serializer will set <c>null</c> to the member.
            		If the member is non-nullable value type and the packed value is nil, then <see cref="T:System.Runtime.Serialization.SerializationException"/> will be thrown.
            	</para>
            	<para>
            		This value corresponds to <c>nullable required</c> on the IDL.
            	</para>
            	<note>
            		If the destination end point sends nil for the value type member like <see cref="T:System.Int32"/> type,
            		you can avoid the exception with change the type of the member to nullable value type.
            	</note>
            </remarks>
        </member>
        <member name="F:MsgPack.Serialization.NilImplication.Prohibit">
            <summary>
            	A nil is prohibitted.
            </summary>
            <remarks>
            	<para>
            		This value affects both of serialization and deserialization.
            	</para>
            	<para>
            		If the packing value is <c>null</c> or the unpacking value is nil,
            		the serializer will throw exception.
            	</para>
            	<para>
            		This value corresponds to <c>required</c> on the IDL.
            	</para>
            	<note>
            		When you specify this value to newly added member,
            		it means that you BREAK backword compatibility.
            	</note>
            </remarks>
        </member>
        <member name="T:MsgPack.MessageTypeException">
            <summary>
            	Represents unpacking error when message type is unknown or unavailable.
            </summary>
        </member>
        <member name="M:MsgPack.MessageTypeException.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageTypeException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:MsgPack.MessageTypeException.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageTypeException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:MsgPack.MessageTypeException.#ctor(System.String,System.Exception)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageTypeException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="inner">
            	The exception that is the cause of the current exception, or a <c>null</c> if no inner exception is specified.
            </param>
        </member>
        <member name="M:MsgPack.MessageTypeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageTypeException"/> class with serialized data.
            </summary>
            <param name="info">
            	The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.
            </param>
            <param name="context">
            	The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            	The <paramref name="info"/> parameter is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	The class name is <c>null</c> or <see cref="P:HResult"/> is zero (0).
            </exception>
        </member>
        <member name="T:MsgPack.MessageNotSupportedException">
            <summary>
            	Exception occurs when serialized stream contains structures or features which will never be supported by MsgPack/CLI implementation.
            </summary>
        </member>
        <member name="M:MsgPack.MessageNotSupportedException.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageNotSupportedException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:MsgPack.MessageNotSupportedException.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageNotSupportedException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:MsgPack.MessageNotSupportedException.#ctor(System.String,System.Exception)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageNotSupportedException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="inner">
            	The exception that is the cause of the current exception, or a <c>null</c> if no inner exception is specified.
            </param>
        </member>
        <member name="M:MsgPack.MessageNotSupportedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessageNotSupportedException"/> class with serialized data.
            </summary>
            <param name="info">
            	The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.
            </param>
            <param name="context">
            	The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            	The <paramref name="info"/> parameter is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	The class name is <c>null</c> or <see cref="P:HResult"/> is zero (0).
            </exception>
        </member>
        <member name="T:MsgPack.MessagePackObjectEqualityComparer">
            <summary>
            	Implements <see cref="T:System.Collections.Generic.EqualityComparer`1"/> of <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectEqualityComparer.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObjectEqualityComparer"/> class.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObjectEqualityComparer.Equals(MsgPack.MessagePackObject,MsgPack.MessagePackObject)">
            <summary>
            	Determines whether two objects of type <see cref="T:MsgPack.MessagePackObject"/> are equal.
            </summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns>
            	<c>true</c> if the specified objects are equal; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObjectEqualityComparer.GetHashCode(MsgPack.MessagePackObject)">
            <summary>
            	Returns a hash code for the specified <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <param name="obj">The <see cref="T:MsgPack.MessagePackObject"/>.</param>
            <returns>
            	A hash code for <paramref name="obj"/>, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:MsgPack.MessagePackObject">
            <summary>
            	Represents deserialized object of MsgPack.
            </summary>
        </member>
        <member name="T:MsgPack.IPackable">
            <summary>
            	Represents objects which knows how to pack ifself using specified <see cref="T:MsgPack.Packer"/>.
            </summary>
        </member>
        <member name="M:MsgPack.IPackable.PackToMessage(MsgPack.Packer,MsgPack.PackingOptions)">
            <summary>
            	Pack this instance itself using specified <see cref="T:MsgPack.Packer"/>.
            </summary>
            <param name="packer"><see cref="T:MsgPack.Packer"/>.</param>
            <param name="options">Packing options. This value can be null.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="packer"/> is null.</exception>
        </member>
        <member name="F:MsgPack.MessagePackObject.Nil">
            <summary>
            	Instance represents nil. This is equal to default value.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Collections.Generic.IList{MsgPack.MessagePackObject})">
            <summary>
            	Initializes a new instance wraps <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="value">
            	The collection to be copied.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Collections.Generic.IList{MsgPack.MessagePackObject},System.Boolean)">
            <summary>
            	Initializes a new instance wraps <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="value">
            	The collection to be copied or used.
            </param>
            <param name="isImmutable">
            	<c>true</c> if the <paramref name="value"/> is immutable collection;
            	othereise, <c>false</c>.
            </param>
            <remarks>
            	When the collection is truely immutable or dedicated, you can specify <c>true</c> to the <paramref name="isImmutable"/>.
            	When <paramref name="isImmutable"/> is <c>true</c>, this constructor does not copy its contents,
            	or copies its contents otherwise.
            	<note>
            		Note that both of IReadOnlyList and <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> is NOT immutable
            		because the modification to the underlying collection will be reflected to the read-only collection.
            	</note>
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(MsgPack.MessagePackObjectDictionary)">
            <summary>
            	Initializes a new instance wraps <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <param name="value">
            	The dictitonary to be copied.
            </param>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(MsgPack.MessagePackObjectDictionary,System.Boolean)">
            <summary>
            	Initializes a new instance wraps <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <param name="value">
            	The dictitonary to be copied or used.
            </param>
            <param name="isImmutable">
            	<c>true</c> if the <paramref name="value"/> is immutable collection;
            	othereise, <c>false</c>.
            </param>
            <remarks>
            	When the collection is truely immutable or dedicated, you can specify <c>true</c> to the <paramref name="isImmutable"/>.
            	When <paramref name="isImmutable"/> is <c>true</c>, this constructor does not copy its contents,
            	or copies its contents otherwise.
            	<note>
            		Note that both of IReadOnlyDictionary and ReadOnlyDictionary is NOT immutable
            		because the modification to the underlying collection will be reflected to the read-only collection.
            	</note>
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(MsgPack.MessagePackString)">
            <summary>
            	Initializes a new instance wraps <see cref="T:MsgPack.MessagePackString"/>.
            </summary>
            <param name="messagePackString"><see cref="T:MsgPack.MessagePackString"/> which represents byte array or UTF-8 encoded string.</param>
        </member>
        <member name="M:MsgPack.MessagePackObject.Equals(System.Object)">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="obj"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns>
            	If <paramref name="obj"/> is <see cref="T:MsgPack.MessagePackObject"/> and its value is equal to this instance, then true.
            	Otherwise false.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.Equals(MsgPack.MessagePackObject)">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="other"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns>
            	Whether value of <paramref name="other"/> is equal to this instance or not.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.GetHashCode">
            <summary>
            	Get hash code of this instance.
            </summary>
            <returns>Hash code of this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.ToString">
            <summary>
            	Returns a string that represents the current object.
            </summary>
            <returns>
            	A string that represents the current object.
            </returns>
            <remarks>
            	<note>
            		DO NOT use this value programmically. 
            		The purpose of this method is informational, so format of this value subject to change.
            	</note>
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObject.IsTypeOf``1">
            <summary>
            	Determine whether the underlying value of this instance is specified type or not.
            </summary>
            <typeparam name="T">Target type.</typeparam>
            <returns>If the underlying value of this instance is <typeparamref name="T"/> then true, otherwise false.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.IsTypeOf(System.Type)">
            <summary>
            	Determine whether the underlying value of this instance is specified type or not.
            </summary>
            <param name="type">Target type.</param>
            <returns>If the underlying value of this instance is <paramref name="type"/> then true, otherwise false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is null.</exception>
        </member>
        <member name="M:MsgPack.MessagePackObject.PackToMessage(MsgPack.Packer,MsgPack.PackingOptions)">
            <summary>
            	Pack this instance itself using specified <see cref="T:MsgPack.Packer"/>.
            </summary>
            <param name="packer"><see cref="T:MsgPack.Packer"/>.</param>
            <param name="options">Packing options. This value can be null.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="packer"/> is null.</exception>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsString(System.Text.Encoding)">
            <summary>
            	Gets the underlying value as string encoded with specified <see cref="T:System.Text.Encoding"/>.
            </summary>
            <returns>
            	The string.
            	Note that some <see cref="T:System.Text.Encoding"/> returns <c>null</c> if the binary is not valid encoded string.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsStringUtf8">
            <summary>
            	Get underlying value as UTF8 string.
            </summary>
            <returns>Underlying raw binary.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsStringUtf16">
            <summary>
            	Get underlying value as UTF-16 string.
            </summary>
            <returns>Underlying string.</returns>
            <remarks>
            	This method detects BOM. If BOM is not exist, them bytes should be Big-Endian UTF-16.
            </remarks>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsCharArray">
            <summary>
            	Get underlying value as UTF-16 charcter array.
            </summary>
            <returns>Underlying string.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsEnumerable">
            <summary>
            	Get underlying value as <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <returns>Underlying <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsList">
            <summary>
            	Get underlying value as <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <returns>Underlying <see cref="T:System.Collections.Generic.IList`1"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsDictionary">
            <summary>
            	Get underlying value as <see cref="T:MsgPack.MessagePackObjectDictionary"/>.
            </summary>
            <returns>Underlying <see cref="T:MsgPack.MessagePackObjectDictionary"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.FromObject(System.Object)">
            <summary>
            	Wraps specified object as <see cref="T:MsgPack.MessagePackObject"/> recursively.
            </summary>
            <param name="boxedValue">Object to be wrapped.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> wrapps <paramref name="boxedValue"/>.</returns>
            <exception cref="T:MsgPack.MessageTypeException">
            	<paramref name="boxedValue"/> is not primitive value type, list of <see cref="T:MsgPack.MessagePackObject"/>,
            	dictionary of <see cref="T:MsgPack.MessagePackObject"/>, <see cref="T:System.String"/>, <see cref="T:System.Byte"/>[], or null.
            </exception>
        </member>
        <member name="M:MsgPack.MessagePackObject.ToObject">
            <summary>
            	Get boxed underlying value for this object.
            </summary>
            <returns>Boxed underlying value for this object.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Equality(MsgPack.MessagePackObject,MsgPack.MessagePackObject)">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="left"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <param name="right"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns>
            	Whether value of <paramref name="left"/> and <paramref name="right"/> are equal each other or not.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Inequality(MsgPack.MessagePackObject,MsgPack.MessagePackObject)">
            <summary>
            	Compare two instances are not equal.
            </summary>
            <param name="left"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <param name="right"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns>
            	Whether value of <paramref name="left"/> and <paramref name="right"/> are not equal each other or are equal.
            </returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(MsgPack.MessagePackObject[])~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:MsgPack.MessagePackObject"/>[] instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/>[] instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Boolean)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Boolean"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Byte)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Byte"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.SByte)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.SByte"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Int16)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Int16"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.UInt16)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.UInt16"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Int32)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Int32"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.UInt32)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.UInt32"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Int64)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Int64"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.UInt64)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.UInt64"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Single)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Single"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Double)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Double"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.String"/> instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.#ctor(System.Byte[])">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.MessagePackObject"/> type which wraps <see cref="T:System.Byte"/>[] instance.
            </summary>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsBoolean">
            <summary>
            	Convert this instance to <see cref="T:System.Boolean"/> instance.
            </summary>
            <returns><see cref="T:System.Boolean"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsByte">
            <summary>
            	Convert this instance to <see cref="T:System.Byte"/> instance.
            </summary>
            <returns><see cref="T:System.Byte"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsSByte">
            <summary>
            	Convert this instance to <see cref="T:System.SByte"/> instance.
            </summary>
            <returns><see cref="T:System.SByte"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsInt16">
            <summary>
            	Convert this instance to <see cref="T:System.Int16"/> instance.
            </summary>
            <returns><see cref="T:System.Int16"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsUInt16">
            <summary>
            	Convert this instance to <see cref="T:System.UInt16"/> instance.
            </summary>
            <returns><see cref="T:System.UInt16"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsInt32">
            <summary>
            	Convert this instance to <see cref="T:System.Int32"/> instance.
            </summary>
            <returns><see cref="T:System.Int32"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsUInt32">
            <summary>
            	Convert this instance to <see cref="T:System.UInt32"/> instance.
            </summary>
            <returns><see cref="T:System.UInt32"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsInt64">
            <summary>
            	Convert this instance to <see cref="T:System.Int64"/> instance.
            </summary>
            <returns><see cref="T:System.Int64"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsUInt64">
            <summary>
            	Convert this instance to <see cref="T:System.UInt64"/> instance.
            </summary>
            <returns><see cref="T:System.UInt64"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsSingle">
            <summary>
            	Convert this instance to <see cref="T:System.Single"/> instance.
            </summary>
            <returns><see cref="T:System.Single"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsDouble">
            <summary>
            	Convert this instance to <see cref="T:System.Double"/> instance.
            </summary>
            <returns><see cref="T:System.Double"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsString">
            <summary>
            	Convert this instance to <see cref="T:System.String"/> instance.
            </summary>
            <returns><see cref="T:System.String"/> instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.AsBinary">
            <summary>
            	Convert this instance to <see cref="T:System.Byte"/>[] instance.
            </summary>
            <returns><see cref="T:System.Byte"/>[] instance corresponds to this instance.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Boolean)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Boolean"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Boolean"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Byte)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Byte"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Byte"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.SByte)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.SByte"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.SByte"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Int16)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Int16"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Int16"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.UInt16)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.UInt16"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.UInt16"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Int32)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Int32"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Int32"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.UInt32)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.UInt32"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.UInt32"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Int64)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Int64"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Int64"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.UInt64)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.UInt64"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.UInt64"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Single)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Single"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Single"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Double)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Double"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Double"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.String)~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.String"/>instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.String"/> instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Implicit(System.Byte[])~MsgPack.MessagePackObject">
            <summary>
            	Convert <see cref="T:System.Byte"/>[]instance to <see cref="T:MsgPack.MessagePackObject"/> instance.
            </summary>
            <param name="value"><see cref="T:System.Byte"/>[] instance.</param>
            <returns><see cref="T:MsgPack.MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Boolean">
            <summary>
            	Convert this instance to <see cref="T:System.Boolean"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Boolean"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Byte">
            <summary>
            	Convert this instance to <see cref="T:System.Byte"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Byte"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.SByte">
            <summary>
            	Convert this instance to <see cref="T:System.SByte"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.SByte"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Int16">
            <summary>
            	Convert this instance to <see cref="T:System.Int16"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Int16"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.UInt16">
            <summary>
            	Convert this instance to <see cref="T:System.UInt16"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.UInt16"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Int32">
            <summary>
            	Convert this instance to <see cref="T:System.Int32"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Int32"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.UInt32">
            <summary>
            	Convert this instance to <see cref="T:System.UInt32"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.UInt32"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Int64">
            <summary>
            	Convert this instance to <see cref="T:System.Int64"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Int64"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.UInt64">
            <summary>
            	Convert this instance to <see cref="T:System.UInt64"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.UInt64"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Single">
            <summary>
            	Convert this instance to <see cref="T:System.Single"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Single"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Double">
            <summary>
            	Convert this instance to <see cref="T:System.Double"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Double"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.String">
            <summary>
            	Convert this instance to <see cref="T:System.String"/> instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.String"/> instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MsgPack.MessagePackObject.op_Explicit(MsgPack.MessagePackObject)~System.Byte[]">
            <summary>
            	Convert this instance to <see cref="T:System.Byte"/>[] instance.
            </summary>
            <param name="value"><see cref="T:MsgPack.MessagePackObject"/> instance.</param>
            <returns><see cref="T:System.Byte"/>[] instance corresponds to <paramref name="value"/>.</returns>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsNil">
            <summary>
            	Get whether this instance represents nil.
            </summary>
            <value>If this instance represents nil object, then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsRaw">
            <summary>
            	Get the value indicates whether this instance wraps raw binary (or string) or not.
            </summary>
            <value>This instance wraps raw binary (or string) then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsList">
            <summary>
            	Get the value indicates whether this instance wraps list (array) or not.
            </summary>
            <value>This instance wraps list (array) then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsArray">
            <summary>
            	Get the value indicates whether this instance wraps list (array) or not.
            </summary>
            <value>This instance wraps list (array) then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsDictionary">
            <summary>
            	Get the value indicates whether this instance wraps dictionary (map) or not.
            </summary>
            <value>This instance wraps dictionary (map) then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.IsMap">
            <summary>
            	Get the value indicates whether this instance wraps dictionary (map) or not.
            </summary>
            <value>This instance wraps dictionary (map) then true.</value>
        </member>
        <member name="P:MsgPack.MessagePackObject.UnderlyingType">
            <summary>
            	Get underlying type of this instance.
            </summary>
            <returns>Underlying <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="T:MsgPack.Serialization.UnpackHelpers">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Defines serialization helper APIs.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.UnpackHelpers.UnpackArrayTo``1(MsgPack.Unpacker,MsgPack.Serialization.MessagePackSerializer{``0},``0[])">
            <summary>
            	Unpacks the array to the specified array.
            </summary>
            <typeparam name="T">The type of the array element.</typeparam>
            <param name="unpacker">The unpacker to unpack the underlying stream.</param>
            <param name="serializer">The serializer to deserialize array.</param>
            <param name="array">The array instance to be filled.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="unpacker"/> is <c>null</c>.
            	Or <paramref name="serializer"/> is <c>null</c>.
            	Or <paramref name="array"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	<paramref name="unpacker"/> is not in the array header.
            	Or failed to deserialization.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.UnpackHelpers.UnpackCollectionTo(MsgPack.Unpacker,System.Collections.IEnumerable,System.Action{System.Object})">
            <summary>
            	Unpacks the collection with the specified method as colletion of <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <param name="unpacker">The unpacker to unpack the underlying stream.</param>
            <param name="collection">The non-generic collection instance to be added unpacked elements.</param>
            <param name="addition">The delegate which contains the instance method of the <paramref name="collection"/>. The parameter is unpacked object.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="unpacker"/> is <c>null</c>.
            	Or <paramref name="collection"/> is <c>null</c>.
            	Or <paramref name="addition"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	<paramref name="unpacker"/> is not in the array header.
            	Or failed to deserialization.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.UnpackHelpers.UnpackCollectionTo``1(MsgPack.Unpacker,MsgPack.Serialization.MessagePackSerializer{``0},System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            	Unpacks the dictionary with the specified method as colletion of <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <param name="unpacker">The unpacker to unpack the underlying stream.</param>
            <param name="serializer">The serializer to deserialize elements.</param>
            <param name="collection">The generic collection instance to be added unpacked elements.</param>
            <param name="addition">The delegate which contains the instance method of the <paramref name="collection"/>. The parameter is unpacked object.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="unpacker"/> is <c>null</c>.
            	Or <paramref name="serializer"/> is <c>null</c>.
            	Or <paramref name="collection"/> is <c>null</c>.
            	Or <paramref name="addition"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	<paramref name="unpacker"/> is not in the array header.
            	Or failed to deserialization.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.UnpackHelpers.UnpackCollectionTo``1(MsgPack.Unpacker,System.Collections.IEnumerable,System.Func{System.Object,``0})">
            <summary>
            	Unpacks the collection with the specified method as colletion of <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <typeparam name="TDiscarded">The return type of Add method.</typeparam>
            <param name="unpacker">The unpacker to unpack the underlying stream.</param>
            <param name="collection">The non-generic collection instance to be added unpacked elements.</param>
            <param name="addition">The delegate which contains the instance method of the <paramref name="collection"/>. The parameter is unpacked object.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="unpacker"/> is <c>null</c>.
            	Or <paramref name="collection"/> is <c>null</c>.
            	Or <paramref name="addition"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	<paramref name="unpacker"/> is not in the array header.
            	Or failed to deserialization.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.UnpackHelpers.UnpackCollectionTo``2(MsgPack.Unpacker,MsgPack.Serialization.MessagePackSerializer{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            	Unpacks the dictionary with the specified method as colletion of <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <typeparam name="T">The type of elements.</typeparam>
            <typeparam name="TDiscarded">The return type of Add method.</typeparam>
            <param name="unpacker">The unpacker to unpack the underlying stream.</param>
            <param name="serializer">The serializer to deserialize elements.</param>
            <param name="collection">The generic collection instance to be added unpacked elements.</param>
            <param name="addition">The delegate which contains the instance method of the <paramref name="collection"/>. The parameter is unpacked object.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="unpacker"/> is <c>null</c>.
            	Or <paramref name="serializer"/> is <c>null</c>.
            	Or <paramref name="collection"/> is <c>null</c>.
            	Or <paramref name="addition"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	<paramref name="unpacker"/> is not in the array header.
            	Or failed to deserialization.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.UnpackHelpers.UnpackMapTo``2(MsgPack.Unpacker,MsgPack.Serialization.MessagePackSerializer{``0},MsgPack.Serialization.MessagePackSerializer{``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            	Unpacks the dictionary with the specified method as colletion of <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <typeparam name="TKey">The type of keys.</typeparam>
            <typeparam name="TValue">The type of values.</typeparam>
            <param name="unpacker">The unpacker to unpack the underlying stream.</param>
            <param name="keySerializer">The serializer to deserialize key elements.</param>
            <param name="valueSerializer">The serializer to deserialize value elements.</param>
            <param name="dictionary">The generic dictionary instance to be added unpacked elements.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="unpacker"/> is <c>null</c>.
            	Or <paramref name="keySerializer"/> is <c>null</c>.
            	Or <paramref name="valueSerializer"/> is <c>null</c>.
            	Or <paramref name="dictionary"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	<paramref name="unpacker"/> is not in the map header.
            	Or failed to deserialization.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.UnpackHelpers.UnpackMapTo(MsgPack.Unpacker,System.Collections.IDictionary)">
            <summary>
            	Unpacks the dictionary with the specified method as colletion of <see cref="T:MsgPack.MessagePackObject"/>.
            </summary>
            <param name="unpacker">The unpacker to unpack the underlying stream.</param>
            <param name="dictionary">The non-generic dictionary instance to be added unpacked elements.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="unpacker"/> is <c>null</c>.
            	Or <paramref name="dictionary"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	<paramref name="unpacker"/> is not in the map header.
            	Or failed to deserialization.
            </exception>
        </member>
        <member name="T:MsgPack.Serialization.SerializerRepository">
            <summary>
            	Repository of known <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>s.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializerRepository.#ctor">
            <summary>
            Initializes a new empty instance of the <see cref="T:MsgPack.Serialization.SerializerRepository"/> class.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializerRepository.#ctor(MsgPack.Serialization.SerializerRepository)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.SerializerRepository"/> class  which has copied serializers.
            </summary>
            <param name="copiedFrom">The repository which will be copied its contents.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="copiedFrom"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.SerializerRepository.Dispose">
            <summary>
            	Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializerRepository.Get``1(MsgPack.Serialization.SerializationContext)">
            <summary>
            	Gets the registered <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> from this repository.
            </summary>
            <typeparam name="T">Type of the object to be marshaled/unmarshaled.</typeparam>
            <returns>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>. If no appropriate mashalers has benn registered, then <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.SerializerRepository.Register``1(MsgPack.Serialization.MessagePackSerializer{``0})">
            <summary>
            	Register <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>.
            </summary>
            <typeparam name="T">The type of serialization target.</typeparam>
            <param name="serializer"><see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> instance.</param>
            <returns>
            	<c>true</c> if success to register; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="serializer"/> is <c>null</c>.
            </exception>
        </member>
        <member name="P:MsgPack.Serialization.SerializerRepository.Default">
            <summary>
            	Gets the system default repository.
            </summary>
            <value>
            	The system default repository.
            	This value will not be <c>null</c>.
            	Note that the repository is frozen.
            </value>
        </member>
        <member name="T:MsgPack.Serialization.EmittingSerializers.MapEmittingSerializerBuilder`1">
            <summary>
            	<see cref="T:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilder`1"/> implementation which emits as map.
            </summary>
            <typeparam name="TObject">The type of the target object.</typeparam>
        </member>
        <member name="T:MsgPack.Serialization.EmittingSerializers.FieldBasedSerializerEmitter">
            <summary>
            	<see cref="T:MsgPack.Serialization.EmittingSerializers.SerializerEmitter"/> using instance fields to hold serializers for target members.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.FieldBasedSerializerEmitter.#ctor(System.Reflection.Emit.ModuleBuilder,System.Nullable{System.Int32},System.Type,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MsgPack.Serialization.EmittingSerializers.FieldBasedSerializerEmitter"/> class.
            </summary>
            <param name="host">The host <see cref="T:System.Reflection.Emit.ModuleBuilder"/>.</param>
            <param name="sequence">The sequence number to name new type.</param>
            <param name="targetType">Type of the serialization target.</param>
            <param name="isDebuggable">Set to <c>true</c> when <paramref name="host"/> is debuggable.</param>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.FieldBasedSerializerEmitter.GetPackToMethodILGenerator">
            <summary>
            	Gets the IL generator to implement <see cref="M:MessagePackSerializer{T}.PackToCore"/> overrides.
            </summary>
            <returns>
            	The IL generator to implement <see cref="M:MessagePackSerializer{T}.PackToCore"/> overrides.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.FieldBasedSerializerEmitter.GetUnpackFromMethodILGenerator">
            <summary>
            	Gets the IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackFromCore"/> overrides.
            </summary>
            <returns>
            	The IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackFromCore"/> overrides.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.FieldBasedSerializerEmitter.GetUnpackToMethodILGenerator">
            <summary>
            	Gets the IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackToCore"/> overrides.
            </summary>
            <returns>
            	The IL generator to implement <see cref="M:MessagePackSerializer{T}.UnpackToCore"/> overrides.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.FieldBasedSerializerEmitter.CreateInstance``1(MsgPack.Serialization.SerializationContext)">
            <summary>
            	Creates the serializer type built now and returns its new instance.
            </summary>
            <typeparam name="T">Target type to be serialized/deserialized.</typeparam>
            <param name="context">The <see cref="T:MsgPack.Serialization.SerializationContext"/> to holds serializers.</param>
            <returns>
            	Newly built <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> instance.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.FieldBasedSerializerEmitter.Create">
            <summary>
            	Creates the serializer type built now and returns its constructor.
            </summary>
            <returns>
            	Newly built <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> type constructor.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.FieldBasedSerializerEmitter.RegisterSerializer(System.Type)">
            <summary>
            	Regisgter using <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> target type to the current emitting session.
            </summary>
            <param name="targetType">Type to be serialized/deserialized.</param>
            <returns>
            	<see cref="T:System.Action`2"/> to emit serializer retrieval instructions.
            	The 1st argument should be <see cref="T:MsgPack.Serialization.Reflection.TracingILGenerator"/> to emit instructions.
            	The 2nd argument should be argument index of the serializer holder.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="T:MsgPack.Serialization.ExpressionSerializers.ListExpressionMessagePackSerializer`1">
            <summary>
            	<see cref="T:MsgPack.Serialization.ExpressionSerializers.SequenceExpressionMessagePackSerializer`1"/> for a collection which has <c>Add</c> method.
            </summary>
            <typeparam name="T">The type of element.</typeparam>
        </member>
        <member name="M:MsgPack.Serialization.ExpressionSerializers.ExpressionSerializerLogics.CreateGetCount``1(MsgPack.Serialization.CollectionTraits)">
            <summary>
            	Creates a delegate which returns collection count.
            </summary>
            <typeparam name="T">The type of collection element.</typeparam>
            <param name="traits">The traits of the collection.</param>
            <returns>A delegate which returns collection count.</returns>
        </member>
        <member name="M:MsgPack.Serialization.ExpressionSerializers.ExpressionSerializerLogics.CreateGetCountExpression``1(MsgPack.Serialization.CollectionTraits,System.Linq.Expressions.ParameterExpression)">
            <summary>
            	Creates an <see cref="T:System.Linq.Expressions.Expression"/> which returns collection count.
            </summary>
            <typeparam name="T">The type of collection element.</typeparam>
            <param name="traits">The traits of the collection.</param>
            <param name="targetParameter">The parameter <see cref="T:System.Linq.Expressions.Expression"/> which represents the target collection.</param>
            <returns>An <see cref="T:System.Linq.Expressions.Expression"/> which returns collection count.</returns>
        </member>
        <member name="M:MsgPack.Serialization.ExpressionSerializers.ExpressionSerializerLogics.Using(System.Type,System.Type,System.Linq.Expressions.Expression,System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            	Creates an <see cref="T:System.Linq.Expressions.Expression"/> which represents using statement block.
            </summary>
            <param name="variableType">The type of variable. It must be assignable to <see cref="T:System.IDisposable"/>.</param>
            <param name="expressionType">The type of entire expression. This can be <c>null</c>.</param>
            <param name="right">The right of using declaration .</param>
            <param name="bodyCreator">The body creator. The argument is left of using declaration.</param>
            <returns>An <see cref="T:System.Linq.Expressions.Expression"/> which represents using statement block.</returns>
        </member>
        <member name="M:MsgPack.Serialization.ExpressionSerializers.ExpressionSerializerLogics.For(System.Linq.Expressions.Expression,System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            	Creates an <see cref="T:System.Linq.Expressions.Expression"/> which represents index based for block.
            </summary>
            <param name="count">The count which limits iteration.</param>
            <param name="bodyCreator">The body creator. The argument is <c>i</c> index variable of for loop.</param>
            <returns>An <see cref="T:System.Linq.Expressions.Expression"/> which represents index based for block.</returns>
        </member>
        <member name="M:MsgPack.Serialization.ExpressionSerializers.ExpressionSerializerLogics.ForEach(System.Linq.Expressions.Expression,MsgPack.Serialization.CollectionTraits,System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            	Creates an <see cref="T:System.Linq.Expressions.Expression"/> which represents foreach block.
            </summary>
            <param name="collection">The collection to be enumerated.</param>
            <param name="traits">The traits of the collection.</param>
            <param name="bodyCreator">The body creator. The argument is <c>Current</c> property of the enumerator.</param>
            <returns>An <see cref="T:System.Linq.Expressions.Expression"/> which represents foreach block.</returns>
        </member>
        <member name="M:MsgPack.Serialization.ExpressionSerializers.ExpressionSerializerLogics.GetCollectionConstructor``1">
            <summary>
            	Returns an appropriate <see cref="T:System.Reflection.ConstructorInfo"/> of collection.
            </summary>
            <typeparam name="T">The type of the collection.</typeparam>
            <returns>An appropriate <see cref="T:System.Reflection.ConstructorInfo"/> of collection.</returns>
            <remarks>
            	If the collection has <c>.ctor(int capacity)</c>, then it will be returned.
            	Otherwise, default constructor will be returned.
            	Note that this method cannot determine whether a single <see cref="T:System.Int32"/> parameter truely represents 'capacity' or not.
            </remarks>
        </member>
        <member name="M:MsgPack.Serialization.ExpressionSerializers.ExpressionSerializerLogics.CreateUnpackItem(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Type)">
            <summary>
            	Creates an <see cref="T:System.Linq.Expressions.Expression"/> which unpack an item.
            </summary>
            <param name="unpackerParameter">The parameter <see cref="T:System.Linq.Expressions.Expression"/> which holds the unpacker.</param>
            <param name="unpackFrom">The target <c>UnpackFrom</c> method of the serializer for item type.</param>
            <param name="serializerParameter">The parameter <see cref="T:System.Linq.Expressions.Expression"/> which has <c>UnpackFrom </c>will be invoked.</param>
            <param name="serializerType">The type of the item serializer.</param>
            <returns>An <see cref="T:System.Linq.Expressions.Expression"/> which unpack an item.</returns>
        </member>
        <member name="T:MsgPack.CollectionDebuggerProxy`1">
            <summary>
            	Debugger type proxy for <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">The element type of the collection.</typeparam>
        </member>
        <member name="T:MsgPack.Validation">
            <summary>
            	Common validtion utility.
            </summary>
        </member>
        <member name="M:MsgPack.Validation.IsPrintable(System.Globalization.UnicodeCategory)">
            <summary>
            	Determine specified category is printiable.
            </summary>
            <param name="category">Unicode cateory.</param>
            <returns>
            	If all charactors in specified category are printable then true.
            	Other wise false.
            </returns>
            <remarks>
            	This method is conservative, but application cannot print the charactor
            	because appropriate font is not installed the machine.
            </remarks>
        </member>
        <member name="T:MsgPack.Serialization.SerializationContext">
            <summary>
            	<strong>This is intened to MsgPack for CLI internal use. Do not use this type from application directly.</strong>
            	Represents serialization context information for internal serialization logic.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializationContext.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.SerializationContext"/> class with copy of <see cref="P:MsgPack.Serialization.SerializerRepository.Default"/>.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.SerializationContext.GetSerializer``1">
            <summary>
            	Gets the <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> with this instance.
            </summary>
            <typeparam name="T">Type of serialization/deserialization target.</typeparam>
            <returns>
            	<see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/>.
            	If there is exiting one, returns it.
            	Else the new instance will be created.
            </returns>
            <remarks>
            	This method automatically register new instance via <see cref="M:SerializationRepository.Register{T}"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.Serialization.SerializationContext.GetSerializer(System.Type)">
            <summary>
            	Gets the serializer for the specified <see cref="T:System.Type"/>.
            </summary>
            <param name="targetType">Type of the serialization target.</param>
            <returns>
            	<see cref="T:MsgPack.Serialization.IMessagePackSerializer"/>.
            	If there is exiting one, returns it.
            	Else the new instance will be created.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="targetType"/> is <c>null</c>.
            </exception>
            <remarks>
            	Although <see cref="M:MsgPack.Serialization.SerializationContext.GetSerializer``1"/> is preferred,
            	this method can be used from non-generic type or methods.
            </remarks>
        </member>
        <member name="P:MsgPack.Serialization.SerializationContext.Default">
            <summary>
            	Gets or sets the default instance.
            </summary>
            <value>
            	The default <see cref="T:MsgPack.Serialization.SerializationContext"/> instance.
            </value>
            <exception cref="T:System.ArgumentNullException">The setting value is <c>null</c>.</exception>
        </member>
        <member name="P:MsgPack.Serialization.SerializationContext.Serializers">
            <summary>
            	Gets the current <see cref="T:MsgPack.Serialization.SerializerRepository"/>.
            </summary>
            <value>
            	The  current <see cref="T:MsgPack.Serialization.SerializerRepository"/>.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.SerializationContext.EmitterFlavor">
            <summary>
            	Gets or sets the <see cref="P:MsgPack.Serialization.SerializationContext.EmitterFlavor"/>.
            </summary>
            <value>
            	The <see cref="P:MsgPack.Serialization.SerializationContext.EmitterFlavor"/>
            </value>
            <remarks>
            	For testing purposes.
            </remarks>
        </member>
        <member name="P:MsgPack.Serialization.SerializationContext.CompatibilityOptions">
            <summary>
            	Gets the compatibility options.
            </summary>
            <value>
            	The <see cref="T:MsgPack.Serialization.SerializationCompatibilityOptions"/> which stores compatibility options. This value will not be <c>null</c>.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.SerializationContext.SerializationMethod">
            <summary>
            	Gets or sets the <see cref="P:MsgPack.Serialization.SerializationContext.SerializationMethod"/> to determine serialization strategy.
            </summary>
            <value>
            	The <see cref="P:MsgPack.Serialization.SerializationContext.SerializationMethod"/> to determine serialization strategy.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.SerializationContext.GeneratorOption">
            <summary>
            	Gets or sets the <see cref="T:MsgPack.Serialization.SerializationMethodGeneratorOption"/> to control code generation.
            </summary>
            <value>
            	The <see cref="T:MsgPack.Serialization.SerializationMethodGeneratorOption"/>.
            </value>
        </member>
        <member name="T:MsgPack.Serialization.SerializationCompatibilityOptions">
            <summary>
            	Represents compatibility options of serialization runtime.
            </summary>
        </member>
        <member name="P:MsgPack.Serialization.SerializationCompatibilityOptions.OneBoundDataMemberOrder">
            <summary>
            	Gets or sets a value indicating whether <see cref="P:System.Runtime.Serialization.DataMemberAttribute.Order"/> should be started with 1 instead of 0.
            </summary>
            <value>
            	<c>true</c> if <see cref="P:System.Runtime.Serialization.DataMemberAttribute.Order"/> should be started with 1 instead of 0; otherwise, <c>false</c>.
            	Default is <c>false</c>.
            </value>
            <remarks>
            	Using this value, you can switch between MessagePack for CLI and ProtoBuf.NET seamlessly.
            </remarks>
        </member>
        <member name="T:MsgPack.Serialization.ExpressionSerializers.ExpressionSerializerBuilder`1">
            <summary>
            	Implements common features expression tree based serializer builders.
            </summary>
            <typeparam name="TObject">The type of the serialization target.</typeparam>
        </member>
        <member name="T:MsgPack.PackingOptions">
            <summary>
            	Represents options of packing.
            </summary>
        </member>
        <member name="M:MsgPack.PackingOptions.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.PackingOptions"/> class.
            </summary>
        </member>
        <member name="P:MsgPack.PackingOptions.StringEncoding">
            <summary>
            	Get encoding for string.
            </summary>
            <value>
            	<see cref="T:System.Text.Encoding"/> for string. Default is UTF-8 encoding without BOM.
            </value>
        </member>
        <member name="T:MsgPack.TupleItems">
            <summary>
            	Defines helper method for items of tuple type.
            </summary>
        </member>
        <member name="M:MsgPack.TupleItems.CreateTupleTypeList(System.Collections.Generic.IList{System.Type})">
            <summary>
            	Creates type list for nested tuples.
            </summary>
            <param name="itemTypes">The type list of tuple items, in order.</param>
            <returns>
            	The type list for nested tuples.
            	The order is from outer to inner.
            </returns>
        </member>
        <member name="T:MsgPack.Serialization.ExpressionSerializers.MapFormatObjectExpressionMessagePackSerializer`1">
            <summary>
            	<see cref="T:MsgPack.Serialization.ExpressionSerializers.ObjectExpressionMessagePackSerializer`1"/> for map format stream.
            </summary>
            <typeparam name="T">The type of target type.</typeparam>
        </member>
        <member name="T:MsgPack.Serialization.EmittingSerializers.DefaultSerializationMethodGeneratorManager">
            <summary>
            	Manages serializer generators.
            </summary>
        </member>
        <member name="T:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager">
            <summary>
            	Defines common features and interfaces for <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager"/>.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager.Get">
            <summary>
            	Get the appropriate <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager"/> for the current configuration.
            </summary>
            <returns>
            	The appropriate <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager"/> for the current configuration.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager.Get(MsgPack.Serialization.SerializationMethodGeneratorOption)">
            <summary>
            	Get the appropriate <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager"/> for specified options.
            </summary>
            <param name="option"><see cref="T:MsgPack.Serialization.SerializationMethodGeneratorOption"/>.</param>
            <returns>
            	The appropriate <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager"/> for specified options. 
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager.Get(System.Reflection.Emit.AssemblyBuilder)">
            <summary>
            	Get the dumpable <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager"/> with specified brandnew assembly builder.
            </summary>
            <param name="assemblyBuilder">An assembly builder which will store all generated types.</param>
            <returns>
            	The appropriate <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager"/> to generate pre-cimplied serializers.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager.CreateEmitter(System.Type,MsgPack.Serialization.EmitterFlavor)">
            <summary>
            	Creates new <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializerEmitter"/> which corresponds to the specified <see cref="T:MsgPack.Serialization.EmitterFlavor"/>.
            </summary>
            <param name="targetType">The type of the serialization target.</param>
            <param name="emitterFlavor"><see cref="T:MsgPack.Serialization.EmitterFlavor"/>.</param>
            <returns>New <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializerEmitter"/> which corresponds to the specified <see cref="T:MsgPack.Serialization.EmitterFlavor"/>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager.CreateEmitterCore(System.Type,MsgPack.Serialization.EmitterFlavor)">
            <summary>
            	Creates new <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializerEmitter"/> which corresponds to the specified <see cref="T:MsgPack.Serialization.EmitterFlavor"/>.
            </summary>
            <param name="targetType">The type of the serialization target.</param>
            <param name="emitterFlavor"><see cref="T:MsgPack.Serialization.EmitterFlavor"/>.</param>
            <returns>New <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializerEmitter"/> which corresponds to the specified <see cref="T:MsgPack.Serialization.EmitterFlavor"/>.</returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.DefaultSerializationMethodGeneratorManager.DumpTo">
            <summary>
            	Save ILs as modules to specified directory.
            </summary>
            <exception cref="T:System.IO.PathTooLongException">
            	The file path generated is too long on the current platform.
            </exception>
            <exception cref="T:System.UnauthorizedAccessException">
            	Current user does not have required permission to save file on the current directory.
            </exception>
            <exception cref="T:System.IO.IOException">
            	The output device does not have enough free space.
            	Or the target file already exists and is locked by other thread.
            	Or the low level I/O error is occurred.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.DefaultSerializationMethodGeneratorManager.Create(System.Reflection.Emit.AssemblyBuilder)">
            <summary>
            	Create a new dumpable <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager"/> with specified brandnew assembly builder.
            </summary>
            <param name="assemblyBuilder">An assembly builder which will store all generated types.</param>
            <returns>
            	The appropriate <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager"/> to generate pre-cimplied serializers.
            	This value will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.EmittingSerializers.DefaultSerializationMethodGeneratorManager.CreateEmitterCore(System.Type,MsgPack.Serialization.EmitterFlavor)">
            <summary>
            	Creates new <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializerEmitter"/> which corresponds to the specified <see cref="T:MsgPack.Serialization.EmitterFlavor"/>.
            </summary>
            <param name="targetType">The type of the serialization target.</param>
            <param name="emitterFlavor"><see cref="T:MsgPack.Serialization.EmitterFlavor"/>.</param>
            <returns>
            	New <see cref="T:MsgPack.Serialization.EmittingSerializers.SerializerEmitter"/> which corresponds to the specified <see cref="T:MsgPack.Serialization.EmitterFlavor"/>.
            </returns>
        </member>
        <member name="P:MsgPack.Serialization.EmittingSerializers.DefaultSerializationMethodGeneratorManager.CanCollect">
            <summary>
            	Get the singleton instance for can-collect mode.
            </summary>
        </member>
        <member name="P:MsgPack.Serialization.EmittingSerializers.DefaultSerializationMethodGeneratorManager.CanDump">
            <summary>
            	Get the singleton instance for can-dump mode.
            </summary>
        </member>
        <member name="P:MsgPack.Serialization.EmittingSerializers.DefaultSerializationMethodGeneratorManager.Fast">
            <summary>
            	Get the singleton instance for fast mode.
            </summary>
        </member>
        <member name="T:MsgPack.Serialization.ExpressionSerializers.ArrayExpressionMessagePackSerializer`1">
            <summary>
            	<see cref="T:MsgPack.Serialization.ExpressionSerializers.SequenceExpressionMessagePackSerializer`1"/> for an array.
            </summary>
            <typeparam name="T">The type of element.</typeparam>
        </member>
        <member name="T:MsgPack.UnpackingResult`1">
            <summary>
            	Represents result of direct conversion from the byte array.
            </summary>
            <typeparam name="T">Type of value.</typeparam>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.Equals(System.Object)">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="obj"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <returns>
            	If <paramref name="obj"/> is <see cref="T:MsgPack.UnpackingResult`1"/> and its value is equal to this instance, then true.
            	Otherwise false.
            </returns>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.Equals(MsgPack.UnpackingResult{`0})">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="other"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <returns>
            	Whether value of <paramref name="other"/> is equal to this instance or not.
            </returns>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.GetHashCode">
            <summary>
            	Get hash code of this instance.
            </summary>
            <returns>Hash code of this instance.</returns>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.ToString">
            <summary>
            	Get string representation of this object.
            </summary>
            <returns>String representation of this object.</returns>
            <remarks>
            	<note>
            		DO NOT use this value programmically. 
            		The purpose of this method is informational, so format of this value subject to change.
            	</note>
            </remarks>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.op_Equality(MsgPack.UnpackingResult{`0},MsgPack.UnpackingResult{`0})">
            <summary>
            	Compare two instances are equal.
            </summary>
            <param name="left"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <param name="right"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <returns>
            	Whether value of <paramref name="left"/> and <paramref name="right"/> are equal each other or not.
            </returns>
        </member>
        <member name="M:MsgPack.UnpackingResult`1.op_Inequality(MsgPack.UnpackingResult{`0},MsgPack.UnpackingResult{`0})">
            <summary>
            	Compare two instances are not equal.
            </summary>
            <param name="left"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <param name="right"><see cref="T:MsgPack.UnpackingResult`1"/> instance.</param>
            <returns>
            	Whether value of <paramref name="left"/> and <paramref name="right"/> are not equal each other or are equal.
            </returns>		
        </member>
        <member name="P:MsgPack.UnpackingResult`1.ReadCount">
            <summary>
            	Get read bytes count from input byte array.
            </summary>
            <value>
            	Read bytes count from input byte array.
            	If this value equals to old offset, then a value of <see cref="P:MsgPack.UnpackingResult`1.Value"/> property is not undifined.
            </value>
        </member>
        <member name="P:MsgPack.UnpackingResult`1.Value">
            <summary>
            	Get retrieved value from the byte array.
            </summary>
            <value>
            	Retrieved value from the byte array.
            	If <see cref="P:MsgPack.UnpackingResult`1.ReadCount"/> equals to old offset, then a value of this property is not undefined.
            </value>
        </member>
        <member name="T:MsgPack.Serialization.SerializationMethodGeneratorOption">
            <summary>
            	Define options of serializer generation.
            </summary>
        </member>
        <member name="F:MsgPack.Serialization.SerializationMethodGeneratorOption.CanDump">
            <summary>
            	The generated method IL can be dumped to the current directory.
            	It is intended for the runtime, you cannot use this option.
            </summary>
        </member>
        <member name="F:MsgPack.Serialization.SerializationMethodGeneratorOption.CanCollect">
            <summary>
            	The entire generated method can be collected by GC when it is no longer used.
            </summary>
        </member>
        <member name="F:MsgPack.Serialization.SerializationMethodGeneratorOption.Fast">
            <summary>
            	Prefer performance. This options is default.
            </summary>
        </member>
        <member name="T:MsgPack.Serialization.MessagePackMemberAttribute">
            <summary>
            	Marks a field or a property to be serialized with MessagePack Serializer and defines some required informations to serialize.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackMemberAttribute.#ctor(System.Int32)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.Serialization.MessagePackMemberAttribute"/> class.
            </summary>
            <param name="id">
            	The ID of the member. This value cannot be negative and must be unique in the type.
            </param>
        </member>
        <member name="P:MsgPack.Serialization.MessagePackMemberAttribute.Id">
            <summary>
            	Gets the ID of the member.
            </summary>
            <value>
            	The ID of the member.
            </value>
        </member>
        <member name="P:MsgPack.Serialization.MessagePackMemberAttribute.NilImplication">
            <summary>
            	Gets or sets the implication of the nil value.
            </summary>
            <value>
            	The implication of the nil value.
            	Default value is <see cref="F:NilImplication.MemberDefault"/>.
            </value>
        </member>
        <member name="T:MsgPack.Serialization.ExpressionSerializers.ExpressionDumper">
            <summary>
            	Takes text dump for expression tree supporting block expression etc.
            </summary>
        </member>
        <member name="T:MsgPack.Binary">
            <summary>
            	Defines binary related utilities.
            </summary>
        </member>
        <member name="F:MsgPack.Binary.Empty">
            <summary>
            	Singleton empty <see cref="T:System.Byte"/>[].
            </summary>
        </member>
        <member name="T:MsgPack.Serialization.EmittingSerializers.ArrayEmittingSerializerBuilder`1">
            <summary>
            	<see cref="T:MsgPack.Serialization.EmittingSerializers.EmittingSerializerBuilder`1"/> implementation which emits as array (default).
            </summary>
            <typeparam name="TObject">The type of the target object.</typeparam>
        </member>
        <member name="T:MsgPack.MessagePackString">
            <summary>
            	Encapselates <see cref="T:System.String"/> and its serialized UTF-8 bytes.
            </summary>
        </member>
        <member name="T:MsgPack.InvalidMessagePackStreamException">
            <summary>
            	Exception occured when inbound stream is invalid as serialized Message Pack stream.
            </summary>
        </member>
        <member name="M:MsgPack.InvalidMessagePackStreamException.#ctor">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.InvalidMessagePackStreamException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:MsgPack.InvalidMessagePackStreamException.#ctor(System.String)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.InvalidMessagePackStreamException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:MsgPack.InvalidMessagePackStreamException.#ctor(System.String,System.Exception)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.InvalidMessagePackStreamException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="inner">
            	The exception that is the cause of the current exception, or a <c>null</c> if no inner exception is specified.
            </param>
        </member>
        <member name="M:MsgPack.InvalidMessagePackStreamException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            	Initializes a new instance of the <see cref="T:MsgPack.InvalidMessagePackStreamException"/> class with serialized data.
            </summary>
            <param name="info">
            	The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.
            </param>
            <param name="context">
            	The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            	The <paramref name="info"/> parameter is <c>null</c>.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            	The class name is <c>null</c> or <see cref="P:HResult"/> is zero (0).
            </exception>
        </member>
        <member name="T:MsgPack.Serialization.Reflection.ReflectionExtensions">
            <summary>
            	Defines utility extension method for reflection API.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.Reflection.ReflectionExtensions.IsAssignableTo(System.Type,System.Type)">
            <summary>
            	Determines whether specified <see cref="T:System.Type"/> can be assigned to source <see cref="T:System.Type"/>.
            </summary>
            <param name="source">The source type.</param>
            <param name="target">The type to compare with the source type.</param>
            <returns>
              <c>true</c> if <paramref name="source"/> and <paramref name="target"/> represent the same type, 
              or if <paramref name="target"/> is in the inheritance hierarchy of <paramref name="source"/>, 
              or if <paramref name="target"/> is an interface that <paramref name="source"/> implements, 
              or if <paramref name="source"/> is a generic type parameter and <paramref name="target"/> represents one of the constraints of <paramref name="source"/>. 
              <c>false</c> if none of these conditions are <c>true</c>, or if <paramref name="target"/> is <c>false</c>. 
            </returns>
        </member>
        <member name="T:MsgPack.StreamUnpacker">
            <summary>
            	Stream based unpacker.
            </summary>
        </member>
        <member name="F:MsgPack.StreamUnpacker.DefaultBufferSize">
            <summary>
            	Default buffer size.
            </summary>
            <remarks>
            	This value is subject to change.
            </remarks>
        </member>
        <member name="F:MsgPack.StreamUnpacker._unpacker">
            <summary>
            	Actual unpackaging strategy.
            </summary>
        </member>
        <member name="F:MsgPack.StreamUnpacker._mayInTail">
            <summary>
            	If current position MAY be in tail of source then true, otherwise false.
            </summary>
            <remarks>
            	This value should be refered via <see cref="M:MsgPack.StreamUnpacker.IsInStreamTail"/>.
            </remarks>
        </member>
        <member name="F:MsgPack.StreamUnpacker._successorSources">
            <summary>
            	Queue of successors of data source.
            </summary>
        </member>
        <member name="F:MsgPack.StreamUnpacker._currentSource">
            <summary>
            	Current data source.
            </summary>
        </member>
        <member name="M:MsgPack.StreamUnpacker.#ctor">
            <summary>
            	Initializes a new instance with default sized on memory buffer.
            </summary>
        </member>
        <member name="M:MsgPack.StreamUnpacker.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            	Initializes a new instance using specified <see cref="T:System.IO.Stream"/> as source.
            </summary>
            <param name="source">Source <see cref="T:System.IO.Stream"/>.</param>
            <param name="ownsStream">If you want to dispose stream when this instance is disposed, then true.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:MsgPack.StreamUnpacker.Dispose(System.Boolean)">
            <summary>
            	Clean up internal resources.
            </summary>
        </member>
        <member name="M:MsgPack.StreamUnpacker.ReadSubtreeCore">
            <summary>
            	Starts unpacking of current subtree.
            </summary>
            <returns>
            	<see cref="T:MsgPack.Unpacker"/> to unpack current subtree.
            	This will not be <c>null</c>.
            </returns>
        </member>
        <member name="M:MsgPack.StreamUnpacker.ReadCore">
            <summary>
            	Reads next Message Pack entry.
            </summary>
            <returns>
            	<c>true</c>, if position is sucessfully move to next entry;
            	<c>false</c>, if position reaches the tail of the Message Pack stream.
            </returns>
        </member>
        <member name="M:MsgPack.StreamUnpacker.ReadSubtreeItem">
            <summary>
            	Read subtree item from current stream.
            </summary>
            <returns>
            	<c>true</c>, if position is sucessfully move to next entry;
            	<c>false</c>, if position reaches the tail of the Message Pack stream.
            </returns>
            <remarks>
            	This method only be called from <see cref="T:MsgPack.SubtreeUnpacker"/>.
            </remarks>
        </member>
        <member name="M:MsgPack.StreamUnpacker.IsInStreamTail">
            <summary>
            	Determins this instance is in tail of all data sources.
            	This method deque successors when needed.
            </summary>
            <returns>If this instance is in tail of all data sources then true, otherwise false.</returns>
        </member>
        <member name="P:MsgPack.StreamUnpacker.Data">
            <summary>
            	Get last unpacked data.
            </summary>
            <value>
            	Last unpacked data or null.
            </value>
        </member>
        <member name="P:MsgPack.StreamUnpacker.IsArrayHeader">
            <summary>
            	Gets a value indicating whether this instance is positioned to array header.
            </summary>
            <value>
            	<c>true</c> if this instance is positioned to array header; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MsgPack.StreamUnpacker.IsMapHeader">
            <summary>
            	Gets a value indicating whether this instance is positioned to map header.
            </summary>
            <value>
            	<c>true</c> if this instance is positioned to map header; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MsgPack.StreamUnpacker.ItemsCount">
            <summary>
            	Gets the items count for current array or map.
            </summary>
            <value>
            	The items count for current array or map.
            </value>
            <exception cref="T:System.InvalidOperationException">
            	Both of the <see cref="P:MsgPack.StreamUnpacker.IsArrayHeader"/> and <see cref="P:MsgPack.StreamUnpacker.IsMapHeader"/> are <c>false</c>.
            </exception>
        </member>
        <member name="P:MsgPack.StreamUnpacker.UnderlyingStream">
            <summary>
            	Gets the underlying stream to handle direct API.
            </summary>
        </member>
        <member name="T:MsgPack.StreamUnpacker.DataSource">
            <summary>
            	Encapselates Stream and ownership information.
            </summary>
        </member>
        <member name="F:MsgPack.StreamUnpacker.DataSource.OwnsStream">
            <summary>
            	Indicates whether this unpacker should <see cref="M:System.IDisposable.Dispose"/> <see cref="F:MsgPack.StreamUnpacker.DataSource.Stream"/>.
            </summary>
        </member>
        <member name="F:MsgPack.StreamUnpacker.DataSource.Stream">
            <summary>
            	Underlying stream of this source. This value could be null.
            </summary>
        </member>
        <member name="T:MsgPack.Serialization.MessagePackSerializer">
            <summary>
            	Defines entry points for <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> usage.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer.Create``1">
            <summary>
            	Creates new <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> instance with <see cref="P:MsgPack.Serialization.SerializationContext.Default"/>.
            </summary>
            <typeparam name="T">Target type.</typeparam>
            <returns>
            	New <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> instance to serialize/deserialize the object tree which the top is <typeparamref name="T"/>.
            </returns>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer.Create``1(MsgPack.Serialization.SerializationContext)">
            <summary>
            	Creates new <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> instance with specified <see cref="T:MsgPack.Serialization.SerializationContext"/>.
            </summary>
            <typeparam name="T">Target type.</typeparam>
            <param name="context">
            	<see cref="T:MsgPack.Serialization.SerializationContext"/> to store known/created serializers.
            </param>
            <returns>
            	New <see cref="T:MsgPack.Serialization.MessagePackSerializer`1"/> instance to serialize/deserialize the object tree which the top is <typeparamref name="T"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="context"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer.Create(System.Type)">
            <summary>
            	Creates new <see cref="T:MsgPack.Serialization.IMessagePackSerializer"/> instance with <see cref="P:MsgPack.Serialization.SerializationContext.Default"/>.
            </summary>
            <param name="targetType">Target type.</param>
            <returns>
            	New <see cref="T:MsgPack.Serialization.IMessagePackSerializer"/> instance to serialize/deserialize the object tree which the top is <paramref name="targetType"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="targetType"/> is <c>null</c>.
            </exception>
            <remarks>
            	To avoid boxing and strongly typed API is prefered, use <see cref="M:MsgPack.Serialization.MessagePackSerializer.Create``1"/> instead when possible.
            </remarks>
        </member>
        <member name="M:MsgPack.Serialization.MessagePackSerializer.Create(System.Type,MsgPack.Serialization.SerializationContext)">
            <summary>
            	Creates new <see cref="T:MsgPack.Serialization.IMessagePackSerializer"/> instance with specified <see cref="T:MsgPack.Serialization.SerializationContext"/>.
            </summary>
            <param name="targetType">Target type.</param>
            <param name="context">
            	<see cref="T:MsgPack.Serialization.SerializationContext"/> to store known/created serializers.
            </param>
            <returns>
            	New <see cref="T:MsgPack.Serialization.IMessagePackSerializer"/> instance to serialize/deserialize the object tree which the top is <paramref name="targetType"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="targetType"/> is <c>null</c>.
            	Or, <paramref name="context"/> is <c>null</c>.
            </exception>
            <remarks>
            	To avoid boxing and strongly typed API is prefered, use <see cref="M:MsgPack.Serialization.MessagePackSerializer.Create``1(MsgPack.Serialization.SerializationContext)"/> instead when possible.
            </remarks>
        </member>
        <member name="T:MsgPack.Serialization.EmitterFlavor">
            <summary>
            	Determines emitter strategy.
            </summary>
        </member>
        <member name="F:MsgPack.Serialization.EmitterFlavor.ContextBased">
            <summary>
            	Uses <see cref="T:MsgPack.Serialization.SerializationContext"/> in each case of the members (de)serialization.
            	It may cause more contentions but is available in WP7.
            </summary>
        </member>
        <member name="F:MsgPack.Serialization.EmitterFlavor.FieldBased">
            <summary>
            	Caches serializers for the members (de)serialization.
            	It is default.
            </summary>
        </member>
        <member name="F:MsgPack.Serialization.EmitterFlavor.ExpressionBased">
            <summary>
            	Uses expression tree to (de)serialization.
            	It may have more overhead but is available in WinRT.
            </summary>
        </member>
        <member name="M:MsgPack.Serialization.DefaultSerializers.MessagePackObjectExtensions.DeserializeAsString(MsgPack.MessagePackObject)">
            <summary>
            	Invokes <see cref="M:MsgPack.MessagePackObject.AsString"/> in deserializaton manner.
            </summary>
            <param name="source"><see cref="T:MsgPack.MessagePackObject"/>.</param>
            <returns>A deserialized value.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException"><paramref name="source"/> is not expected type.</exception>
        </member>
        <member name="T:MsgPack.IUnpackable">
            <summary>
            	Defines interface for object which can be deserialzed from MessagePack object.
            </summary>
        </member>
        <member name="M:MsgPack.IUnpackable.UnpackFromMessage(MsgPack.Unpacker)">
            <summary>
            	Restore object state from specified <see cref="T:MsgPack.Unpacker"/>.
            </summary>
            <param name="unpacker"><see cref="T:MsgPack.Unpacker"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="unpacker"/> is <c>null</c>.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Cannot restore state from the stream.</exception>
        </member>
        <member name="T:MsgPack.BigEndianBinary">
            <summary>
            	Define bit operations which enforce big endian.
            </summary>
        </member>
    </members>
</doc>
